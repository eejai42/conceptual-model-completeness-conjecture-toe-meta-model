{
    "id": "CMCC_ToEMM_Physics",    
        "meta-model": {
  "name": "All-In-One CMCC Physics Model",
  "description": "A unified data+rule schema capturing classical mechanics, quantum wavefunctions, gauge fields, density matrices, multiway branching, black holes, spin-statistics, etc. Aggregators/lambdas are fully declarative and can reference each other in any order.",
  "depends_on": [
    "CMCC_ToEMM_Math"
  ],
  "version": "v2.19",
  "nickname": "physics",
  "meta": {
    "title": "Physics ToE Meta-Model",
    "subtitle": "A Comprehensive Snapshot-Consistent Data Architecture for Classical, Quantum, and Relativistic Theories",
    "authors": [
      {
        "name": "EJ Alexandra",
        "contact": "start@anabstractlevel.com",
        "affiliations": [
          "SSoT.me",
          "EffortlessAPI.com"
        ]
      }
    ],
    "date": "March 2025",
    "abstract": "This Physics extension of the CMCC (Conceptual Model Completeness Conjecture) unifies classical mechanics, quantum wavefunctions, relativistic effects, and multiway branching under one coherent, Snapshot-Consistent schema. By leveraging the same five fundamental primitives—Schema, Data, Lookups, Aggregations, and Lambda formulas—it provides a purely declarative framework capable of modeling everything from basic Newtonian systems to Many-Worlds quantum branching events, seamlessly integrating with the broader CMCC environment.",
    "executive_summary": {
      "key_points": [
        "Captures both classical and quantum physics entities (particles, wavefunctions, measurement events) within the same structural model.",
        "Demonstrates universal coverage: from gravitational orbits to entangled states and multi-observer Wigner’s friend scenarios.",
        "Scales across microscopic, relativistic, and cosmic domains via aggregator-based rules and constraints.",
        "Aligns naturally with Wolfram’s multiway systems and Turing-complete formalisms, bridging theoretical and computational physics."
      ],
      "implications": [
        "Offers a unified data substrate for cross-domain queries, enabling advanced analyses that tie together quantum states, cosmic evolution, or classical mechanics.",
        "Enhances reproducibility: each theorem, measurement event, or wavefunction is stored as data, eliminating the friction of specialized scripts.",
        "Lowers barriers to adding new physics theories or phenomena, since aggregator formula definitions are updated purely as data, not code."
      ],
      "narrative": [
        {
          "title": "CMCC Physics Extension",
          "content": [
            "Traditional physics modeling often separates each domain—classical mechanics, quantum mechanics, relativity—into bespoke toolchains and file formats. This isolation complicates integrated analyses, such as bridging quantum wavefunctions with large-scale relativistic frames or observer-based paradoxes.",
            "The CMCC Physics Model solves this by encoding all relevant physics concepts—like quantum states, measurements, observer frames, cosmic structures, or classical bodies—in the same Snapshot-Consistent environment. Observables, wavefunction amplitudes, gauge fields, and branching structures appear as aggregator-driven records, decoupled from any one programming or simulation language. Even advanced, multi-observer paradox scenarios are captured via relationships and aggregator constraints.",
            "This data-first approach, shared across the entire CMCC ecosystem, encourages cross-domain synergy. For instance, a single aggregator can check both quantum entanglement measures and classical gravitational parameters in the same query. The result is a single coherent data architecture that scales smoothly from fundamental quantum processes up to cosmic evolution, all while remaining Turing-complete and interpretation-agnostic."
          ]
        }
      ]
    }
  },
  "schema": {
    "entities": [
      {
        "name": "GlobalScenarioRecord",
        "description": "Captures a top-level scenario or experiment context that aggregates wavefunctions, observers, measurements, and classical/cosmic data. Supports scenario-wide checks such as no-signalling, classical limit analyses, multi-observer reconstructions, etc.",
        "fields": [
          {
            "name": "scenario_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for this scenario or experiment."
          },
          {
            "name": "scenario_description",
            "type": "scalar",
            "datatype": "string",
            "description": "Textual description of the scenario's purpose, scope, or experimental setup."
          },
          {
            "name": "scenario_metadata",
            "type": "scalar",
            "datatype": "json",
            "description": "Optional extra scenario info such as environment conditions, global parameters, HPC job metadata, etc."
          }
        ],
        "lookups": [
          {
            "name": "linked_wavefunctions",
            "type": "one_to_many",
            "target_entity": "ScenarioWavefunctionLink",
            "join_condition": "ScenarioWavefunctionLink.scenario_id = this.scenario_id",
            "description": "Points to a linking entity that associates this scenario with its included QuantumState records."
          },
          {
            "name": "linked_observers",
            "type": "one_to_many",
            "target_entity": "ScenarioObserverLink",
            "join_condition": "ScenarioObserverLink.scenario_id = this.scenario_id",
            "description": "Points to a linking entity that associates this scenario with the relevant ObserverFrames."
          },
          {
            "name": "linked_measurements",
            "type": "one_to_many",
            "target_entity": "ScenarioMeasurementLink",
            "join_condition": "ScenarioMeasurementLink.scenario_id = this.scenario_id",
            "description": "Points to a linking entity that associates this scenario with its MeasurementEvents."
          },
          {
            "name": "linked_relationships",
            "type": "one_to_many",
            "target_entity": "ScenarioRelationshipLink",
            "join_condition": "ScenarioRelationshipLink.scenario_id = this.scenario_id",
            "description": "Points to a linking entity that associates this scenario with ObserverRelationships."
          },
          {
            "name": "linked_classical_systems",
            "type": "one_to_many",
            "target_entity": "ClassicalSystemRecord",
            "join_condition": "Some bridging record or scenario_id if desired",
            "description": "Points to classical systems relevant for the scenario (optional extension)."
          },
          {
            "name": "linked_particles",
            "type": "one_to_many",
            "target_entity": "ParticleRecord",
            "join_condition": "Possibly ScenarioParticleLink if we want the same pattern as wavefunctions.",
            "description": "If the scenario includes classical or hybrid ParticleRecords."
          },
          {
            "name": "scenario_dark_matter_inferences",
            "type": "one_to_many",
            "target_entity": "DarkMatterInferenceRecord",
            "join_condition": "DarkMatterInferenceRecord.scenario_id = this.scenario_id",
            "description": "Points to DM inference records relevant to this scenario, each referencing this scenario_id."
          },
          {
            "name": "scenario_halo_structures",
            "type": "one_to_many",
            "target_entity": "HaloSubstructureRecord",
            "join_condition": "HaloSubstructureRecord.scenario_id = this.scenario_id",
            "description": "Points to halo substructure records. The 'scenario_id' field in HaloSubstructureRecord enables this link."
          },
          {
            "name": "scenario_cosmic_evolutions",
            "type": "one_to_many",
            "target_entity": "CosmicEvolutionRecord",
            "join_condition": "CosmicEvolutionRecord.scenario_id = this.scenario_id",
            "description": "Links cosmic-evolution snapshots (by redshift/time) to this scenario. 'scenario_id' in CosmicEvolutionRecord references this scenario."
          }
        ],
        "aggregations": [
          {
            "name": "scenario_wavefunction_count",
            "type": "rollup",
            "formula": "COUNT(linked_wavefunctions)",
            "description": "Counts how many QuantumStates are linked to this scenario via the ScenarioWavefunctionLink entity."
          },
          {
            "name": "global_no_signalling_check",
            "type": "rollup",
            "formula": "CheckGlobalNoSignalling(linked_measurements, linked_wavefunctions)",
            "description": "Evaluates measurement data and wavefunction references across this scenario to detect any no-signalling violations."
          },
          {
            "name": "global_classical_limit_analysis",
            "type": "rollup",
            "formula": "AssessClassicalLimitAcrossWavefunctions(linked_wavefunctions)",
            "description": "Analyzes whether wavefunctions in this scenario exhibit minimal interference, suggesting an overall classical limit."
          },
          {
            "name": "interpretation_consistency_across_wavefunctions",
            "type": "rollup",
            "formula": "CheckGlobalInterpretationConsistency(linked_wavefunctions, linked_measurements)",
            "description": "Verifies that each wavefunction's assigned interpretation policy is consistent with the observed measurement behavior within this scenario."
          },
          {
            "name": "global_observer_agreement_score",
            "type": "rollup",
            "formula": "AggregateObserverAgreements(linked_observers, linked_relationships)",
            "description": "Produces a scenario-wide measure of how consistently observers (and relationships among them) record outcomes or states."
          },
          {
            "name": "global_darwinism_index",
            "type": "rollup",
            "formula": "ComputeAggregateDarwinismIndex(linked_observers)",
            "description": "Combines each observer’s quantum_darwinism_index to see if consistent pointer states emerge across the entire scenario."
          },
          {
            "name": "multi_wavefunction_coherence_map",
            "type": "rollup",
            "formula": "CombineAllDecoherenceMaps(linked_wavefunctions)",
            "description": "Aggregates coherence or decoherence data from each wavefunction in the scenario, producing a combined map of quantum interference levels."
          },
          {
            "name": "multi_system_bell_violations",
            "type": "rollup",
            "formula": "ScanAllBellInequalityChecks(linked_wavefunctions, linked_measurements)",
            "description": "Examines relevant wavefunction-measurement combos in this scenario for any CHSH/Bell-type inequality violations."
          },
          {
            "name": "top_level_paradox_score",
            "type": "rollup",
            "formula": "AnalyzeOverallWignersFriendAndHardysParadox(linked_wavefunctions, linked_observers, linked_relationships, linked_measurements)",
            "description": "Generates a consolidated 'paradox score' for Wigner’s friend or Hardy’s paradox events across wavefunctions, observers, and relationships in this scenario."
          },
          {
            "name": "heisenberg_cut_placement",
            "type": "rollup",
            "formula": "InferHeisenbergCutPlacement(linked_wavefunctions, linked_observers)",
            "description": "Assesses pointer-basis stability, decoherence measures, and Darwinism indices to locate a plausible quantum–classical boundary within the scenario."
          },
          {
            "name": "global_causality_violations",
            "type": "rollup",
            "formula": "DetectGlobalCausalLoops(linked_measurements, linked_relationships)",
            "description": "Scans measurement events and observer relationships for cyclical or paradoxical loops that violate standard causality assumptions."
          },
          {
            "name": "multi_observer_rqm_reconstruction",
            "type": "rollup",
            "formula": "AttemptGlobalStateReconstruction(linked_observers, linked_wavefunctions)",
            "description": "Attempts to reconcile partial observer-dependent wavefunctions in RQM into a single global state, if possible. Flags inconsistencies if no single global state can represent every observer’s vantage."
          },
          {
            "name": "scenario_interpretation_conflict_check",
            "type": "rollup",
            "formula": "EvaluateScenarioInterpretationConflicts(linked_measurements, linked_wavefunctions)",
            "description": "Summarizes measurement events that contradict their wavefunction's assigned interpretation policy (e.g., single-outcome vs branching mismatch)."
          },
          {
            "name": "scenario_wigner_friend_paradox_count",
            "type": "rollup",
            "formula": "CountAllWignerFriendParadoxes(linked_relationships)",
            "description": "Tallies the number of observer relationship records that contain a Wigner’s friend paradox or nested friend scenario in this scenario."
          },
          {
            "name": "scenario_hardys_paradox_occurrences",
            "type": "rollup",
            "formula": "CountAllHardyParadoxFlags(linked_wavefunctions)",
            "description": "Counts how many wavefunctions exhibit a non-zero hardys_paradox_indicator, indicating the presence of Hardy's paradox in the scenario."
          },
          {
            "name": "max_branch_depth_across_scenario",
            "type": "rollup",
            "formula": "FindMaxBranchDepth(linked_wavefunctions)",
            "description": "Scans all wavefunctions linked to this scenario and returns the maximum branch depth encountered."
          },
          {
            "name": "scenario_average_entanglement",
            "type": "rollup",
            "formula": "AVERAGE(linked_wavefunctions.entanglement_measure)",
            "description": "Averages the entanglement measure across all wavefunctions in this scenario."
          },
          {
            "name": "scenario_measurement_count",
            "type": "rollup",
            "formula": "COUNT(linked_measurements)",
            "description": "Counts how many MeasurementEvents are linked to this scenario."
          },
          {
            "name": "interpretation_distribution",
            "type": "rollup",
            "formula": "ComputeInterpretationDistribution(linked_wavefunctions)",
            "description": "Returns a JSON object tallying how many wavefunctions use each interpretation policy, e.g. { 'Copenhagen': 2, 'ManyWorlds': 3, 'RQM': 1 }."
          },
          {
            "name": "scenario_active_observers_count",
            "type": "rollup",
            "formula": "COUNT(linked_observers)",
            "description": "Counts how many ObserverFrames are active in this scenario."
          },
          {
            "name": "scenario_interpretation_mismatch_events",
            "type": "rollup",
            "formula": "ListInterpretationMismatches(linked_wavefunctions, linked_measurements)",
            "description": "Returns a list of measurement events that conflict with their wavefunction’s assigned interpretation (e.g., ManyWorlds wavefunction storing single outcomes)."
          },
          {
            "name": "interpretation_mismatch_density",
            "type": "rollup",
            "formula": "ComputeInterpretationMismatchDensity(linked_wavefunctions, linked_measurements)",
            "description": "Aggregates the ratio or percentage of mismatch measurement events over total measurement count. A scenario-level metric of how often interpretation policies are violated."
          },
          {
            "name": "persistent_branch_overlap_ratio",
            "type": "rollup",
            "formula": "EvaluatePersistentBranchOverlap(linked_wavefunctions)",
            "description": "Quantifies how many wavefunction branches remain partially overlapping (coherent) instead of fully decohering, providing a measure of re-interference potential."
          },
          {
            "name": "heisenberg_cut_inference",
            "type": "rollup",
            "formula": "InferHeisenbergCut(decoherence_map, ObserverFrame.quantum_darwinism_index, ObserverFrame.reference_frame_transform)",
            "description": "Computes the effective quantum–classical boundary by integrating decoherence metrics with observer Darwinism indices and reference frame data."
          },
          {
            "name": "scenario_total_classical_mass",
            "type": "rollup",
            "formula": "SUM(linked_classical_systems.total_system_mass)",
            "description": "Aggregates the total mass of classical systems linked to this scenario."
          },
          {
            "name": "scenario_classical_system_count",
            "type": "rollup",
            "formula": "COUNT(linked_classical_systems)",
            "description": "Counts how many ClassicalSystemRecords are included in this scenario."
          },
          {
            "name": "branch_to_classical_boundary_analysis",
            "type": "rollup",
            "formula": "AnalyzeBranchToClassicalBoundary(multi_wavefunction_coherence_map, global_classical_limit_analysis)",
            "description": "Synthesizes wavefunction coherence data with scenario-level classical limit analysis to locate partial quantum/classical boundaries in this scenario."
          },
          {
            "name": "cosmological_observer_paradox_scan",
            "type": "rollup",
            "formula": "ScanObserverParadoxesInCosmicContext(linked_relationships, scenario_dark_matter_inferences, scenario_halo_structures, scenario_cosmic_evolutions)",
            "description": "Correlates RQM or Wigner’s friend paradox indicators among observers with large-scale cosmic structures, such as dark matter subhalos or cosmic evolution."
          },
          {
            "name": "interpretation_mismatch_summary",
            "type": "rollup",
            "formula": "SummarizeInterpretationMismatches(scenario_interpretation_mismatch_events)",
            "description": "Aggregates mismatch events (branch vs collapse, etc.) into a user-friendly summary grouped by wavefunction or measurement type."
          },
          {
            "name": "pointer_states_cosmic_evolution",
            "type": "rollup",
            "formula": "CorrelatePointerDarwinismWithCosmicEvolution(linked_observers, scenario_cosmic_evolutions)",
            "description": "Tracks whether pointer states remain stable across cosmic time by comparing quantum_darwinism_index from observers with cosmic time data."
          },
          {
            "name": "global_pointer_state_stability",
            "type": "rollup",
            "formula": "AssessOverallPointerStateStability(linked_wavefunctions, linked_observers)",
            "description": "Analyzes observer Darwinism indices and decoherence data across wavefunctions to yield a global pointer-state stability score."
          },
          {
            "name": "inferred_classical_boundary",
            "type": "rollup",
            "formula": "DeriveEffectiveClassicalBoundary(linked_wavefunctions, linked_classical_systems)",
            "description": "Automatically locates a plausible quantum–classical boundary using decoherence thresholds, branching structure, and classical system parameters."
          },
          {
            "name": "dark_matter_entanglement_correlation",
            "type": "rollup",
            "formula": "ComputeDMEntanglementCorrelation(linked_wavefunctions, linked_classical_systems, linked_particles, DarkMatterInferenceRecord.*)",
            "description": "Searches for correlations between quantum entanglement measures and the presence of large missing mass in dark-matter inference records."
          },
          {
            "name": "cross_interpretation_probability_flow",
            "type": "rollup",
            "formula": "CompareSingleOutcomeVsMWBranchWeights(linked_measurements, linked_wavefunctions)",
            "description": "Traces outcome probabilities in wavefunctions marked with different interpretations (Copenhagen vs. ManyWorlds) to see if the sum of branch weights matches single-outcome probabilities."
          },
          {
            "name": "multi_level_observer_paradox_scan",
            "type": "rollup",
            "formula": "RecursiveParadoxSearch(linked_relationships)",
            "description": "Examines observer relationships for nested/cyclical Wigner’s friend setups, generating a multi-tier paradox score."
          },
          {
            "name": "quantum_classical_coupling_entropy",
            "type": "rollup",
            "formula": "ComputeCouplingEntropy(linked_wavefunctions, linked_classical_systems)",
            "description": "Blends wavefunction decoherence metrics with classical system mass or environment parameters to yield an effective quantum–classical coupling entropy."
          },
          {
            "name": "multi_interpretation_branch_probability_divergence",
            "type": "rollup",
            "formula": "ComputeBranchProbabilityDivergence(linked_wavefunctions, linked_measurements)",
            "description": "Compares actual single-outcome frequencies vs Many-Worlds branch weights. Identifies wavefunctions flagged as Copenhagen but displaying repeated multi-branch measurements, or vice versa."
          },
          {
            "name": "nested_observer_observer_paradox_score",
            "type": "rollup",
            "formula": "ComputeMultiLevelObserverParadox(linked_relationships)",
            "description": "Detects cyclical or deeply nested Wigner’s friend (observer A measures B while B measures A, etc.), producing a multi-level paradox severity score."
          },
          {
            "name": "entanglement_decoherence_boundaries",
            "type": "rollup",
            "formula": "IdentifyEntanglementDecoherenceBoundaries(linked_wavefunctions, linked_classical_systems)",
            "description": "Finds the boundary between quantum subsystems (non-negligible entanglement) and effectively classical subsystems (decohered) within large composite scenarios."
          },
          {
            "name": "interpretation_mismatch_vs_branch_depth",
            "type": "rollup",
            "formula": "CorrelateMismatchEventsWithBranchDepth(linked_wavefunctions, linked_measurements)",
            "description": "Examines whether interpretation mismatch events (e.g. single-outcome logs in a Many-Worlds-labeled wavefunction) correlate with higher branch depth or advanced decoherence stages."
          },
          {
            "name": "quantum_classical_coupling_entropy",
            "type": "rollup",
            "formula": "ComputeQuantumClassicalCouplingEntropy(linked_wavefunctions, linked_classical_systems)",
            "description": "Blends wavefunction decoherence metrics with classical environment properties to yield an effective coupling entropy, indicating how strongly the environment drives wavefunction collapse."
          },
          {
            "name": "nested_observer_paradox_depth",
            "type": "rollup",
            "formula": "ComputeNestedObserverParadoxDepth(linked_observers, linked_relationships)",
            "description": "Determines how many levels of 'observer measuring observer' can be stacked before a paradox arises."
          },
          {
            "name": "multi_wavefunction_interference_matrix",
            "type": "rollup",
            "formula": "BuildInterferenceMatrixAcrossWavefunctions(linked_wavefunctions)",
            "description": "Constructs a matrix of cross-interference or orthogonality measures among all wavefunctions in this scenario."
          },
          {
            "name": "entanglement_graph_among_observers",
            "type": "rollup",
            "formula": "GenerateObserverEntanglementGraph(linked_observers, linked_measurements)",
            "description": "Examines correlated outcomes among different ObserverFrames to form a graph of intersubjective entanglement or correlation."
          },
          {
            "name": "cross_validation_partialtrace_branch",
            "type": "rollup",
            "formula": "CompareDensityMatrixPartialTraceWithBranchRecords(linked_wavefunctions, DensityMatrixRecord.*)",
            "description": "Checks consistency between partial-trace density matrices and branch-based (Many-Worlds) decompositions for the same system."
          },
          {
            "name": "environment_assisted_classicality_spread",
            "type": "rollup",
            "formula": "ComputeDarwinismSpreadRate(linked_observers, linked_wavefunctions)",
            "description": "Evaluates how quickly pointer states replicate across multiple environment fragments (Quantum Darwinism) in the entire scenario."
          },
          {
            "name": "mw_vs_objective_collapse_diagnostics",
            "type": "rollup",
            "formula": "ContrastBranchingDepthAgainstSingleOutcomePatterns(linked_wavefunctions, linked_measurements)",
            "description": "Flags wavefunctions labeled 'ManyWorlds' that show effectively single-outcome data, or 'Copenhagen' wavefunctions that spawn branches."
          },
          {
            "name": "macro_scale_interference_revival_prob",
            "type": "rollup",
            "formula": "EstimateMacroRevivalProbability(linked_wavefunctions, BranchRecord.*, classical_systems)",
            "description": "Computes the small but non-zero chance that large systems might re-interfere (revival) if there's residual coherence."
          }
        ],
        "lambdas": [
          {
            "name": "run_global_analysis",
            "parameters": [],
            "formula": "PerformAllGlobalScenarioChecks(this.scenario_id)",
            "description": "Convenient entry-point to run all aggregator or consistency checks for the entire scenario."
          }
        ],
        "constraints": [
          {
            "name": "copenhagen_no_branches",
            "formula": "EnforceNoBranchingForCopenhagen(this.scenario_id)",
            "error_message": "Wavefunctions marked with a Copenhagen policy must not produce branching measurement events in this scenario.",
            "description": "Ensures that wavefunctions using Copenhagen interpretation do not generate Many-Worlds style branches."
          }
        ]
      },
      {
        "name": "QuantumState",
        "description": "Represents a wavefunction or amplitude distribution for a quantum system across different interpretations (Copenhagen, Many-Worlds, RQM). In RQM, it may be observer-dependent or partially global.",
        "fields": [
          {
            "name": "state_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this quantum state."
          },
          {
            "name": "description",
            "type": "scalar",
            "datatype": "string",
            "description": "Optional textual description of the system or wavefunction (e.g. '2-qubit entangled state')."
          },
          {
            "name": "amplitude_data",
            "type": "scalar",
            "datatype": "json",
            "description": "Complex amplitude array or param-based representation of the wavefunction. Typically an array of complex numbers or a parametric structure."
          },
          {
            "name": "normalization",
            "type": "calculated",
            "formula": "SUM( ABS(amplitude_data)^2 )",
            "description": "Calculated norm of the wavefunction (∑|amplitude_data|²). Should be ~1 for physical normalization."
          },
          {
            "name": "interpretation_policy_id",
            "type": "lookup",
            "target_entity": "InterpretationPolicy",
            "description": "Indicates which interpretation policy (Copenhagen, ManyWorlds, RQM, etc.) applies to measurements of this state."
          },
          {
            "name": "coherence_time",
            "type": "scalar",
            "datatype": "float",
            "description": "Approximate timescale over which the wavefunction retains coherence before decoherence effects dominate."
          },
          {
            "name": "dynamic_phase",
            "type": "scalar",
            "datatype": "float",
            "description": "Optional global phase (in radians) used for time-evolution or interference checks."
          },
          {
            "name": "decoherence_environment_params",
            "type": "scalar",
            "datatype": "json",
            "description": "Environment-specific parameters (e.g. temperature, coupling rates) for refined decoherence calculations."
          },
          {
            "name": "subsystem_spec",
            "type": "scalar",
            "datatype": "json",
            "description": "Defines subsystem partitioning (e.g., qubit indices) used in entanglement calculations or partial-trace operations."
          },
          {
            "name": "dimensionality",
            "type": "scalar",
            "datatype": "int",
            "description": "Optional integer dimension if wavefunction is for 1D, 2D, 3D, etc."
          },
          {
            "name": "num_particles",
            "type": "scalar",
            "datatype": "int",
            "description": "How many particles share this wavefunction, if relevant."
          },
          {
            "name": "spin_states",
            "type": "scalar",
            "datatype": "json",
            "description": "Captures spin total or per-particle spin config (e.g. {spin_total:1.0, config:'singlet'})."
          },
          {
            "name": "wavefunction_symmetry",
            "type": "scalar",
            "datatype": "string",
            "description": "Indicates whether the wavefunction is 'symmetric' (bosons) or 'antisymmetric' (fermions), etc."
          }
        ],
        "lookups": [
          {
            "name": "branches",
            "type": "one_to_many",
            "target_entity": "BranchRecord",
            "join_condition": "BranchRecord.wavefunction_id = this.state_id",
            "description": "References zero or more BranchRecords for Many-Worlds or partial branching."
          },
          {
            "name": "amplitude_algebraic_structure_id",
            "type": "lookup",
            "target_entity": "AlgebraicStructure",
            "description": "An optional reference indicating the complex vector space structure for these amplitudes."
          },
          {
            "name": "reference_frame_id",
            "type": "lookup",
            "target_entity": "ReferenceFrameRecord",
            "description": "If needed, identifies which reference frame the wavefunction is expressed in."
          }
        ],
        "aggregations": [
          {
            "name": "entanglement_measure",
            "type": "rollup",
            "formula": "ComputeEntanglementEntropy(amplitude_data, subsystem_spec)",
            "description": "Computes entanglement entropy (or a similar measure) by partially tracing out subsystems as defined by subsystem_spec."
          },
          {
            "name": "decoherence_map",
            "type": "rollup",
            "formula": "AssessDecoherenceAcrossBranches(this.state_id)",
            "description": "Evaluates how orthogonal or non-interfering different branches are, indicating the degree of decoherence."
          },
          {
            "name": "branch_count",
            "type": "rollup",
            "formula": "COUNT(branches)",
            "description": "Number of BranchRecord entries linked to this wavefunction."
          },
          {
            "name": "global_collapse_metric",
            "type": "rollup",
            "formula": "ComputeGlobalCollapseMetric(branch_count, branches)",
            "description": "A user-defined aggregator that scores how 'collapsed' the wavefunction is, based on branch structure."
          },
          {
            "name": "time_evolution",
            "type": "rollup",
            "formula": "ApplyTimeEvolution(amplitude_data, dynamic_phase)",
            "description": "Applies a time-evolution operator (e.g. e^-iHt) to amplitude_data based on dynamic_phase or a stored Hamiltonian reference."
          },
          {
            "name": "causal_branch_graph",
            "type": "rollup",
            "formula": "ConstructBranchCausalityGraph(branches)",
            "description": "Builds a directed graph of branching events for analyzing causal/time-order structure in Many-Worlds or partial branching contexts."
          },
          {
            "name": "macro_distinct_branches",
            "type": "rollup",
            "formula": "IdentifyMacroscopicBranches(decoherence_map, branches, some_threshold)",
            "description": "Distinguishes which branches have become macroscopically distinct (orthogonal). 'some_threshold' is a user-defined or global parameter."
          },
          {
            "name": "observer_relative_wavefunction",
            "type": "rollup",
            "formula": "ComputeObserverRelativeWavefunction(amplitude_data, parameters.observer_id)",
            "description": "Generates a vantage-specific wavefunction for RQM, factoring in partial knowledge or partial branching for the given observer."
          },
          {
            "name": "entanglement_classification",
            "type": "rollup",
            "formula": "IF(entanglement_measure < 1e-6, 'Product state', 'Entangled')",
            "description": "Labels the state as 'Product' if entanglement_measure is negligible, else 'Entangled'."
          },
          {
            "name": "branch_probability_sum",
            "type": "rollup",
            "formula": "SUM(BranchRecord.prob_weight WHERE wavefunction_id = this.state_id)",
            "description": "Accumulates total branch probability across all branches. Ideally ~1 in Many-Worlds if the Born rule is followed."
          },
          {
            "name": "global_probability_mismatch_flag",
            "type": "rollup",
            "formula": "IF( ABS(branch_probability_sum - 1) > 0.001, 'WARNING: total branch probability != 1', 'OK' )",
            "description": "Flags if the sum of branch probabilities deviates significantly from 1, suggesting an inconsistency or incomplete branching data."
          },
          {
            "name": "bell_inequality_check",
            "type": "rollup",
            "formula": "ComputeCHSHCorrelators(this.state_id, MeasurementEvent.*)",
            "description": "Checks for CHSH or Bell inequality violations by scanning all relevant measurement events referencing this wavefunction."
          },
          {
            "name": "chsh_local_check",
            "type": "rollup",
            "formula": "ComputeCHSHCorrelatorsForSpecificMeas(this.state_id, MeasurementEvent.*)",
            "description": "An alternative aggregator for CHSH correlators on a subset of measurement events, if needed."
          },
          {
            "name": "wigner_distribution",
            "type": "rollup",
            "formula": "ComputeWignerFunction(amplitude_data)",
            "description": "Generates a (quasi-)probability distribution in phase space for continuous-variable quantum states."
          },
          {
            "name": "leggett_garg_inequality",
            "type": "rollup",
            "formula": "ComputeLeggettGargCorrelations(this.state_id, MeasurementEvent.*)",
            "description": "Tests time-ordered measurements for Leggett-Garg inequality violations, indicating non-classical temporal correlations."
          },
          {
            "name": "quantum_fisher_info",
            "type": "rollup",
            "formula": "ComputeQuantumFisherInformation(amplitude_data, hamiltonian_ref)",
            "description": "Calculates quantum Fisher information, requiring a known or assumed Hamiltonian reference for metrological use."
          },
          {
            "name": "kochen_specker_contextuality_check",
            "type": "rollup",
            "formula": "ComputeContextualityViolations(this.state_id, MeasurementEvent.*)",
            "description": "Scans associated measurement events for Kochen-Specker style contextuality constraints. Flags violations of non-contextual hidden-variable theories."
          },
          {
            "name": "ghz_mermin_violation_indicator",
            "type": "rollup",
            "formula": "ComputeGHZOrMerminInequalityViolations(this.state_id, MeasurementEvent.*)",
            "description": "Checks multi-qubit GHZ or Mermin inequalities for measurement events referencing this wavefunction. Returns a numeric violation measure."
          },
          {
            "name": "hardys_paradox_indicator",
            "type": "rollup",
            "formula": "ComputeHardyParadoxProbability(this.state_id, MeasurementEvent.*)",
            "description": "Evaluates Hardy's paradox conditions for measurement outcomes on this wavefunction, returning a contradiction measure under local realism."
          },
          {
            "name": "interpretation_usage_summary",
            "type": "rollup",
            "formula": "CollectInterpretationEvidence(this.state_id, MeasurementEvent.*)",
            "description": "Surveys how measurement events referencing this wavefunction were handled (single-outcome, branching, observer-relative). Detects mismatches with the assigned InterpretationPolicy."
          },
          {
            "name": "multi_partition_entanglement_map",
            "type": "rollup",
            "formula": "EvaluateAllBipartitionsForEntanglement(this.state_id)",
            "description": "Computes entanglement entropies for all bipartitions (and optionally tripartitions) to classify GHZ, W-state, or product structure."
          },
          {
            "name": "global_pointer_basis_inference",
            "type": "rollup",
            "formula": "InferPointerBasisStability(this.state_id, pointer_basis_candidates, ObserverFrame.*)",
            "description": "Combines pointer basis candidates with observer data to see if a stable pointer basis emerges from multiple vantage points."
          },
          {
            "name": "history_decoherence_check",
            "type": "rollup",
            "formula": "CheckConsistencyOfHistoriesAcrossBranches(this.state_id)",
            "description": "Analyzes measurement and branch records to ensure distinct histories remain decohered. Flags re-appearance of interference among separated branches."
          },
          {
            "name": "classical_limit_indicator",
            "type": "rollup",
            "formula": "CheckClassicalLimit(pointer_basis_candidates, amplitude_data)",
            "description": "Examines whether off-diagonal interference is negligible, indicating an effectively classical wavefunction in pointer basis terms."
          },
          {
            "name": "time_until_decoherence_dynamic",
            "type": "rollup",
            "formula": "ComputeDynamicDecoherenceTime(amplitude_data, decoherence_map, this.decoherence_environment_params)",
            "description": "Estimates remaining coherence time by combining amplitude data, decoherence map, and environment parameters."
          },
          {
            "name": "resource_theory_magic_measure",
            "type": "rollup",
            "formula": "ComputeMagicStabilizerDistance(amplitude_data)",
            "description": "Evaluates 'magic' resourcefulness by measuring distance from the nearest stabilizer state, relevant to fault-tolerant quantum computing."
          },
          {
            "name": "branch_frequency_vs_amplitude_check",
            "type": "rollup",
            "formula": "CompareBranchWeightFrequencies(this.state_id, repeated_measurements)",
            "description": "In Many-Worlds, compares measured frequencies of branch outcomes to the Born-rule amplitude squares. Flags deviations from expected ratios."
          },
          {
            "name": "macro_cat_indicator",
            "type": "rollup",
            "formula": "DetectMacroscopicSuperposition(this.state_id, amplitude_data, decoherence_map)",
            "description": "Checks for macroscopically distinct superpositions (Schrödinger cat states), using thresholds on amplitude separation and decoherence times."
          },
          {
            "name": "freedman_clauser_inequality_check",
            "type": "rollup",
            "formula": "ComputeFreedmanClauserCorrelations(this.state_id, MeasurementEvent.*)",
            "description": "Performs Freedman–Clauser or Clauser–Horne inequality tests, similar to CHSH but with different measurement settings."
          },
          {
            "name": "max_branch_depth",
            "type": "rollup",
            "formula": "MAX(branches.branch_depth)",
            "description": "Finds the maximum branch depth among all branches linked to this wavefunction."
          },
          {
            "name": "non_adiabaticity_measure",
            "type": "rollup",
            "formula": "ComputeNonAdiabaticity(this.state_id, time_evolution, amplitude_data)",
            "description": "Estimates how quickly the wavefunction departs from an instantaneous eigenstate during time evolution. Helps check adiabatic approximations."
          },
          {
            "name": "branching_regime_classifier",
            "type": "rollup",
            "formula": "IF(AVERAGE(branches.observer_scope_overlap) > threshold, 'Partial Branching', 'Full Branching')",
            "description": "Classifies branching as partial (RQM-style) or full (Many-Worlds) based on average overlap of observer scopes across branches."
          },
          {
            "name": "re_interference_windows",
            "type": "rollup",
            "formula": "DetectReInterferencePossibility(amplitude_data, decoherence_map)",
            "description": "Identifies wavefunction sectors that have not fully decohered and can still interfere."
          },
          {
            "name": "correlation_branch_depth_classical_limit",
            "type": "rollup",
            "formula": "CorrelateBranchDepthWithClassicalLimit(branch_count, classical_limit_indicator)",
            "description": "Checks if deeper branching reliably corresponds to a near-classical wavefunction or if interference persists."
          },
          {
            "name": "pointer_basis_drift_analysis",
            "type": "rollup",
            "formula": "TrackPointerBasisShiftOverTime(this.state_id)",
            "description": "Analyzes whether the stable pointer basis changes under environment interactions or time evolution."
          },
          {
            "name": "macro_vs_micro_entanglement_boundary",
            "type": "rollup",
            "formula": "CheckEntanglementBetweenMacroscopicSubsystemsAndMicroscopicOnes(subsystem_spec, amplitude_data)",
            "description": "Determines if large 'classical-scale' subsystems remain unentangled while microscopic ones are significantly entangled."
          },
          {
            "name": "cross_interpretation_probability_flow",
            "type": "rollup",
            "formula": "CompareBornRuleFrequenciesToManyWorldsBranchWeights(this.state_id, MeasurementEvent.*)",
            "description": "Traces outcome probabilities vs. the sum of branch weights, revealing potential interpretation mismatch or confirmation."
          },
          {
            "name": "time_dependent_classical_emergence_rate",
            "type": "rollup",
            "formula": "ComputeClassicalEmergenceRateOverTime(this.state_id, decoherence_map, QuantumEvolution.*)",
            "description": "Estimates how quickly a wavefunction becomes effectively classical under time evolution or repeated measurements."
          }
        ],
        "lambdas": [
          {
            "name": "normalize_wavefunction",
            "parameters": [],
            "formula": "amplitude_data / SQRT(normalization)",
            "description": "Scales amplitude_data so that the wavefunction is normalized to 1, if not already."
          },
          {
            "name": "merge_with_another_state",
            "parameters": [
              "target_state_id",
              "entangling_params"
            ],
            "formula": "CreateNewEntangledState(this.state_id, target_state_id, entangling_params)",
            "description": "Merges or entangles the current wavefunction with another state, producing a new entangled wavefunction record."
          }
        ],
        "constraints": [
          {
            "name": "normalization_check",
            "formula": "ABS(normalization - 1) <= 0.0001",
            "error_message": "Wavefunction must be normalized (sum of squared amplitudes ~ 1).",
            "description": "Ensures that amplitude_data is properly normalized for physical consistency."
          }
        ]
      },
      {
        "name": "InterpretationPolicy",
        "description": "Defines how measurements on a wavefunction are interpreted (Copenhagen, Many-Worlds, RQM). Enforces rules about collapse behavior, observer specificity, and partial branching.",
        "fields": [
          {
            "name": "interpretation_policy_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this interpretation policy record."
          },
          {
            "name": "interpretation_name",
            "type": "scalar",
            "datatype": "enum",
            "enum_values": [
              "Copenhagen",
              "ManyWorlds",
              "RQM"
            ],
            "description": "Specifies the high-level interpretation: 'Copenhagen', 'ManyWorlds', or 'RQM'."
          },
          {
            "name": "collapse_behavior",
            "type": "scalar",
            "datatype": "enum",
            "enum_values": [
              "single_outcome",
              "branch",
              "observer_relative"
            ],
            "description": "Indicates the measurement outcome handling mode. Must match the chosen interpretation."
          },
          {
            "name": "observer_specificity",
            "type": "scalar",
            "datatype": "boolean",
            "description": "If 'true', measurement outcomes are observer-specific (RQM). For Many-Worlds or Copenhagen, typically false."
          },
          {
            "name": "metadata",
            "type": "scalar",
            "datatype": "json",
            "description": "Optional policy settings (e.g., {branch_weight:'equal', collapse_threshold:0.95})."
          },
          {
            "name": "allow_partial_branching",
            "type": "scalar",
            "datatype": "boolean",
            "description": "If 'true', partial branching is allowed (e.g. advanced RQM or specialized Many-Worlds scenarios)."
          },
          {
            "name": "observer_hierarchy_model",
            "type": "scalar",
            "datatype": "enum",
            "enum_values": [
              "flat",
              "hierarchical",
              "unrestricted"
            ],
            "description": "Specifies how nested observers are handled. 'flat' disallows nesting, 'hierarchical' imposes layered structure, 'unrestricted' allows free nesting."
          }
        ],
        "lookups": [
          {
            "name": "applied_wavefunctions",
            "type": "one_to_many",
            "target_entity": "QuantumState",
            "join_condition": "QuantumState.interpretation_policy_id = this.interpretation_policy_id",
            "description": "Reverse lookup to all QuantumStates referencing this policy."
          }
        ],
        "aggregations": [
          {
            "name": "wavefunction_count",
            "type": "rollup",
            "formula": "COUNT(applied_wavefunctions)",
            "description": "Counts how many QuantumState records currently use this interpretation policy."
          },
          {
            "name": "interpretation_consistency_check",
            "type": "rollup",
            "formula": "EnsurePolicyAlignment(interpretation_name, collapse_behavior, observer_specificity, allow_partial_branching)",
            "description": "Checks high-level alignment of fields (e.g., 'Copenhagen' must use 'single_outcome')."
          },
          {
            "name": "rqm_policy_coherence",
            "type": "rollup",
            "formula": "CheckRQMPolicyCoherence(allow_partial_branching, observer_specificity, observer_hierarchy_model)",
            "description": "Verifies that RQM-related fields do not conflict with each other. E.g., hierarchical model might forbid certain merges."
          },
          {
            "name": "policy_alignment_inference",
            "type": "rollup",
            "formula": "IF(interpretation_consistency_check == 'ok' AND rqm_policy_coherence == 'ok', 'Interpretation policy aligned', 'Mismatch or error in policy config')",
            "description": "Summarizes whether the chosen 'interpretation_name', 'collapse_behavior', and 'observer_specificity' are consistent with each other."
          }
        ],
        "lambdas": [
          {
            "name": "assign_rqm_ruleset",
            "parameters": [
              "ruleset_id"
            ],
            "formula": "ApplyRQMRuleset(this.interpretation_policy_id, ruleset_id, allow_partial_branching)",
            "description": "Dynamically attaches an RQM ruleset to this policy for advanced custom logic or nested friend scenarios."
          }
        ],
        "constraints": [
          {
            "name": "copenhagen_collapse_behavior_constraint",
            "formula": "IF(interpretation_name='Copenhagen', collapse_behavior='single_outcome', true)",
            "error_message": "If interpretation_name is 'Copenhagen', collapse_behavior must be 'single_outcome'.",
            "description": "Ensures that Copenhagen interpretation always uses single-outcome collapses."
          },
          {
            "name": "many_worlds_collapse_behavior_constraint",
            "formula": "IF(interpretation_name='ManyWorlds', collapse_behavior='branch', true)",
            "error_message": "If interpretation_name is 'ManyWorlds', collapse_behavior must be 'branch'.",
            "description": "Enforces branching for Many-Worlds interpretation."
          },
          {
            "name": "rqm_collapse_behavior_constraint",
            "formula": "IF(interpretation_name='RQM', collapse_behavior='observer_relative', true)",
            "error_message": "If interpretation_name is 'RQM', collapse_behavior must be 'observer_relative'.",
            "description": "Ensures RQM uses observer-relative updates on measurement."
          },
          {
            "name": "rqm_observer_specificity_constraint",
            "formula": "IF(interpretation_name='RQM', observer_specificity=true, true)",
            "error_message": "If interpretation_name is 'RQM', observer_specificity must be true.",
            "description": "Requires observer-specific outcomes in RQM."
          }
        ]
      },
      {
        "name": "MeasurementEvent",
        "description": "Logs a measurement or observation that might cause wavefunction collapse, branching, or observer-relative updates under different interpretations.",
        "fields": [
          {
            "name": "meas_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this measurement event."
          },
          {
            "name": "wavefunction_id",
            "type": "lookup",
            "target_entity": "QuantumState",
            "description": "References the QuantumState being measured or observed."
          },
          {
            "name": "measurement_type",
            "type": "scalar",
            "datatype": "string",
            "description": "High-level category of measurement: e.g. 'position', 'spin_z', 'partial_POVM', etc."
          },
          {
            "name": "observable_id",
            "type": "lookup",
            "target_entity": "Observable",
            "description": "Optional reference to a predefined observable operator. If set, 'observable_operator' can be omitted."
          },
          {
            "name": "observable_operator",
            "type": "scalar",
            "datatype": "json",
            "description": "Fallback if there's no 'observable_id'. Contains the operator (matrix) or param-based definition for the measurement."
          },
          {
            "name": "possible_outcomes",
            "type": "scalar",
            "datatype": "json",
            "description": "List or map of potential outcome labels and their associated projection operators or amplitude slices."
          },
          {
            "name": "time_stamp",
            "type": "scalar",
            "datatype": "datetime",
            "description": "Timestamp indicating when this measurement occurred (for ordering or no-signalling checks)."
          },
          {
            "name": "spacetime_coords",
            "type": "scalar",
            "datatype": "json",
            "description": "Optional location/time metadata (e.g., {x:..., t:...}) for no-signalling or causal analyses."
          },
          {
            "name": "observer_id",
            "type": "lookup",
            "target_entity": "ObserverFrame",
            "description": "For RQM, identifies which observer performed this measurement. If null, the observer is unmodeled or classical."
          },
          {
            "name": "selected_outcome",
            "type": "scalar",
            "datatype": "string",
            "description": "In Copenhagen, the measurement collapses to a single outcome. In Many-Worlds, this is typically empty."
          },
          {
            "name": "branch_ids_generated",
            "type": "scalar",
            "datatype": "json",
            "description": "For Many-Worlds, a list of newly created BranchRecord IDs after measurement. Typically empty in Copenhagen or RQM."
          },
          {
            "name": "observed_observer_id",
            "type": "lookup",
            "target_entity": "ObserverFrame",
            "description": "If this measurement is one observer measuring another observer (RQM scenario), references the 'target' observer."
          },
          {
            "name": "relational_records",
            "type": "scalar",
            "datatype": "json",
            "description": "RQM-specific metadata capturing how the measuring observer updates their perspective on the observed observer."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "outcome_probabilities",
            "type": "rollup",
            "formula": "ComputeOutcomeDistribution(wavefunction_id.amplitude_data, observable_operator)",
            "description": "Computes Born-rule outcome probabilities by projecting the wavefunction’s amplitude data onto the measurement operator basis."
          },
          {
            "name": "temporal_consistency_check",
            "type": "rollup",
            "formula": "CheckMeasurementConsistency(wavefunction_id, meas_id)",
            "description": "Ensures this measurement event aligns with the wavefunction’s timeline or previously logged measurement events."
          },
          {
            "name": "history_consistency",
            "type": "rollup",
            "formula": "ComputeHistoryConsistency(this.meas_id, wavefunction_id)",
            "description": "Checks if the measurement’s recorded outcome or branching is consistent with the wavefunction’s known measurement history."
          },
          {
            "name": "causality_check",
            "type": "rollup",
            "formula": "CheckTemporalOrdering(time_stamp, wavefunction_id)",
            "description": "Verifies that the measurement’s timestamp does not conflict with causality constraints (e.g., out-of-order events)."
          },
          {
            "name": "classical_fact_agreement",
            "type": "rollup",
            "formula": "ComputeClassicalFactAgreement(meas_id)",
            "description": "If multiple observers recorded the same event, checks how consistently they match on the outcome."
          },
          {
            "name": "observer_relative_outcomes",
            "type": "rollup",
            "formula": "ComputeObserverRelativeOutcomes(wavefunction_id, observer_id, possible_outcomes)",
            "description": "For RQM or partial branching, computes outcome distributions specifically from the perspective of observer_id."
          },
          {
            "name": "relational_outcome_update",
            "type": "rollup",
            "formula": "ComputeRelationalMeasurementOutcome(wavefunction_id, observer_id, observed_observer_id)",
            "description": "For an observer measuring another observer in RQM, updates the relational outcome data if partial or observer-relative."
          },
          {
            "name": "interpretation_inference",
            "type": "rollup",
            "formula": "IF(selected_outcome != '', 'Copenhagen', IF(branch_ids_generated != null AND LENGTH(branch_ids_generated) > 0, 'ManyWorlds', 'PossibleRQM'))",
            "description": "Heuristic aggregator that guesses the used interpretation based on outcome selection vs. branching."
          },
          {
            "name": "policy_vs_outcome_consistency",
            "type": "rollup",
            "formula": "CheckPolicyOutcomeConsistency(wavefunction_id.interpretation_policy_id, selected_outcome, branch_ids_generated)",
            "description": "Verifies the measurement result or branching matches the wavefunction’s assigned interpretation policy."
          },
          {
            "name": "no_signalling_constraint_check",
            "type": "rollup",
            "formula": "CheckNoSignallingConstraintsAcrossSubsystems(this.meas_id, wavefunction_id, possible_outcomes, spacetime_coords)",
            "description": "Ensures local measurement outcomes do not allow faster-than-light signalling if there are space-like separated events."
          },
          {
            "name": "observed_outcome_probability",
            "type": "rollup",
            "formula": "IF(selected_outcome != '', outcome_probabilities[selected_outcome], null)",
            "description": "Retrieves the Born-rule probability for the measurement's collapsed outcome, if single-outcome was selected."
          },
          {
            "name": "determine_macro_object_quantum_tracing",
            "type": "rollup",
            "formula": "CheckIfMacroscopicSystemUnderMeasurementRetainsQuantumSuperposition(meas_id, wavefunction_id)",
            "description": "Examines whether a large, presumably classical object is still in superposition post-measurement or has collapsed."
          },
          {
            "name": "extended_kochen_specker_survey",
            "type": "rollup",
            "formula": "AggregateContextualityViolationsAcrossMeasurementSets(this.meas_id, wavefunction_id)",
            "description": "Checks multiple measurement bases for Kochen–Specker–type contextual contradictions in the same measurement dataset."
          }
        ],
        "lambdas": [
          {
            "name": "execute_measurement",
            "parameters": [],
            "formula": "InterpretationBasedMeasurement(wavefunction_id, observer_id, this.possible_outcomes, this.outcome_probabilities)",
            "description": "Applies the wavefunction’s interpretation policy, producing a single outcome (Copenhagen), multiple branches (Many-Worlds), or observer-relative updates (RQM)."
          },
          {
            "name": "execute_relational_measurement",
            "parameters": [],
            "formula": "RelationalMeasurementProtocol(this.meas_id, this.observer_id, this.observed_observer_id, wavefunction_id)",
            "description": "Executes a measurement where one observer measures another, updating relational states under RQM-based rules."
          }
        ],
        "constraints": [
          {
            "name": "copenhagen_no_branching",
            "formula": "IF(wavefunction_id.interpretation_policy_id.interpretation_name='Copenhagen', LENGTH(branch_ids_generated)=0, true)",
            "error_message": "Copenhagen measurements must not generate new branches.",
            "description": "Ensures that under Copenhagen interpretation, no branch IDs are created."
          },
          {
            "name": "manyworlds_single_outcome_forbidden",
            "formula": "IF(wavefunction_id.interpretation_policy_id.interpretation_name='ManyWorlds', (selected_outcome IS NULL OR selected_outcome=''), true)",
            "error_message": "Many-Worlds measurements should not store a single collapsed outcome.",
            "description": "Prevents single-outcome collapse in Many-Worlds interpretation."
          }
        ]
      },
      {
        "name": "ObserverFrame",
        "description": "Represents an observer’s vantage in RQM or multi-observer scenarios. Each observer can maintain partial wavefunction data, self-history, and perspectives on other observers.",
        "fields": [
          {
            "name": "observer_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this observer."
          },
          {
            "name": "observer_name",
            "type": "scalar",
            "datatype": "string",
            "description": "Optional label for this observer (e.g. 'Alice', 'Wigner', etc.)."
          },
          {
            "name": "observed_state_records",
            "type": "scalar",
            "datatype": "json",
            "description": "JSON structure capturing partial wavefunction or measurement records as known by this observer."
          },
          {
            "name": "reference_frame_transform",
            "type": "scalar",
            "datatype": "json",
            "description": "Specifies any coordinate shift, boost, or basis transform for how this observer sees the system (e.g., Lorentz transform)."
          },
          {
            "name": "contextual_state_data",
            "type": "scalar",
            "datatype": "json",
            "description": "Observer-specific wavefunction data after applying local or RQM-like updates."
          },
          {
            "name": "view_of_other_observers",
            "type": "scalar",
            "datatype": "json",
            "description": "Mapping of observer_id -> local record of that observer’s outcomes or states, reflecting RQM’s observer-relative knowledge."
          },
          {
            "name": "self_observed_history",
            "type": "scalar",
            "datatype": "json",
            "description": "How this observer perceives their own timeline or measurement events. May differ from external logs."
          },
          {
            "name": "epistemic_context",
            "type": "scalar",
            "datatype": "json",
            "description": "Captures Bayesian priors or 'knowledge state' aspects that define the observer's vantage. Often updated after measurements."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "quantum_darwinism_index",
            "type": "rollup",
            "formula": "ComputeDarwinismIndex(this.observer_id)",
            "description": "Measures how many distinct observer frames share consistent or redundant outcome records with this observer, indicating emergent classicality."
          },
          {
            "name": "shared_state_agreement",
            "type": "rollup",
            "formula": "ComputeObserverConvergence(this.observer_id)",
            "description": "Scores how well this observer’s recorded outcomes align with other observers who measured the same events."
          },
          {
            "name": "intersubjective_consistency_check",
            "type": "rollup",
            "formula": "CompareWithOtherObservers(this.observer_id)",
            "description": "Determines whether this observer’s recorded data conflicts with external logs from other observers."
          },
          {
            "name": "observer_consensus",
            "type": "rollup",
            "formula": "ComputeObserverConsensus(this.observer_id)",
            "description": "Aggregates partial states or measurement outcomes from multiple sources to measure consensus on events or wavefunction states."
          },
          {
            "name": "observer_relative_state",
            "type": "rollup",
            "formula": "ComputeObserverRelativeState(this.observer_id, contextual_state_data)",
            "description": "Reconstructs the local quantum state from this observer’s vantage, combining contextual_state_data with relevant measurements."
          },
          {
            "name": "multi_observer_consensus",
            "type": "rollup",
            "formula": "ComputeMultiObserverConsensus(this.observer_id)",
            "description": "Generalizes observer_consensus to multiple observers, summarizing how many frames converge with this observer's outcomes/states."
          },
          {
            "name": "self_consistency",
            "type": "rollup",
            "formula": "CheckSelfConsistency(self_observed_history, contextual_state_data)",
            "description": "Verifies that the observer’s self-observed timeline does not contradict the partial wavefunction they assign to themselves."
          },
          {
            "name": "observer_consistency_inference",
            "type": "rollup",
            "formula": "IF(intersubjective_consistency_check == 'ok' AND self_consistency == 'ok', 'Fully consistent vantage', 'Mismatch or paradox in observer frame')",
            "description": "Summarizes if the observer’s vantage is consistent both internally (self-consistency) and externally (intersubjective consistency)."
          },
          {
            "name": "classicality_inference",
            "type": "rollup",
            "formula": "IF(quantum_darwinism_index > 5, 'Classical-like pointer states emergent', 'Quantum coherence remains significant')",
            "description": "Simple threshold-based measure for emergent classicality if the Darwinism index is high."
          },
          {
            "name": "darwinism_timeline",
            "type": "rollup",
            "formula": "ComputeDarwinismOverTime(this.observer_id)",
            "description": "Tracks how pointer-state redundancy evolves over time from this observer’s perspective."
          },
          {
            "name": "multi_observer_merge",
            "type": "rollup",
            "formula": "PerformRQMObserverMerge(this.observer_id)",
            "description": "Attempts partial or full 'merge' of multiple observer frames in RQM contexts, reconciling different vantage-dependent states if possible."
          },
          {
            "name": "self_vs_external_consistency",
            "type": "rollup",
            "formula": "ComputeSelfExternalConsistency(this.observer_id, self_observed_history, view_of_other_observers)",
            "description": "Checks how this observer’s self-history compares to how other observers record this observer’s events—detecting potential RQM paradoxes or mismatches."
          },
          {
            "name": "darwinist_redundancy_curve",
            "type": "rollup",
            "formula": "ComputeRedundancyFunction(this.observer_id)",
            "description": "Computes environment-fragment redundancy R(δ) for Darwinism analysis from this observer’s vantage."
          },
          {
            "name": "decoherence_history",
            "type": "rollup",
            "formula": "TrackDecoherenceEvents(this.observer_id)",
            "description": "Generates a timeline or log of decoherence events affecting measurements made by (or on) this observer."
          },
          {
            "name": "distinct_others_count",
            "type": "rollup",
            "formula": "COUNT_DISTINCT(KEYS(view_of_other_observers))",
            "description": "Counts the number of distinct observer IDs that this observer is actively tracking."
          },
          {
            "name": "superobserver_view_index",
            "type": "rollup",
            "formula": "ComputeSuperobserverIndex(this.observer_id, view_of_other_observers)",
            "description": "Scores how comprehensively this observer can reconstruct the states of other observers (Wigner-like vantage)."
          },
          {
            "name": "observer_observer_frame_overlap",
            "type": "rollup",
            "formula": "ComputeFrameOverlap(this.observer_id, view_of_other_observers)",
            "description": "Measures how much this observer's vantage or transforms coincide with other observers' known frames."
          },
          {
            "name": "superobserver_emergence_index",
            "type": "rollup",
            "formula": "AssessSuperobserverCoverage(this.observer_id, view_of_other_observers)",
            "description": "Rates how completely this observer can reconstruct other observers' wavefunction states—i.e. a 'Wigner vantage.'"
          },
          {
            "name": "rqm_relative_timeline_consistency",
            "type": "rollup",
            "formula": "CheckTimelineOrderConsistency(this.observer_id, self_observed_history, ObserverRelationship.*)",
            "description": "Verifies that the sequence of events in this observer’s local timeline does not contradict external observer logs."
          },
          {
            "name": "observer_pointer_basis_stability_timeline",
            "type": "rollup",
            "formula": "EvaluatePointerBasisStabilityOverTime(this.observer_id, contextual_state_data)",
            "description": "Tracks how stable the local pointer basis is from this observer’s vantage as new measurements or environment data arrive."
          }
        ],
        "lambdas": [
          {
            "name": "update_observed_context",
            "parameters": [
              "measurement_id"
            ],
            "formula": "BayesianObserverUpdate(this.observer_id, measurement_id, contextual_state_data)",
            "description": "Updates this observer’s contextual wavefunction or knowledge state after receiving a new measurement event."
          },
          {
            "name": "update_relational_view",
            "parameters": [
              "target_observer_id",
              "measurement_data"
            ],
            "formula": "RQMRelationalUpdate(this.observer_id, target_observer_id, measurement_data, view_of_other_observers)",
            "description": "Adjusts this observer’s internal representation of another observer (target_observer_id) using new measurement data, in line with RQM."
          },
          {
            "name": "synchronize_self_view",
            "parameters": [
              "new_self_data"
            ],
            "formula": "UpdateSelfObservedHistory(this.observer_id, new_self_data, self_observed_history)",
            "description": "Reconciles or overwrites the observer’s self-history with newly acquired introspective or external data about themselves."
          }
        ],
        "constraints": []
      },
      {
        "name": "BranchRecord",
        "description": "Many-Worlds or partial RQM branching metadata—each branch is a distinct wavefunction slice after measurement.",
        "fields": [
          {
            "name": "branch_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this particular branch."
          },
          {
            "name": "wavefunction_id",
            "type": "lookup",
            "target_entity": "QuantumState",
            "description": "Identifies which quantum state this branch belongs to."
          },
          {
            "name": "origin_meas_id",
            "type": "lookup",
            "target_entity": "MeasurementEvent",
            "description": "Which measurement event spawned this branch."
          },
          {
            "name": "branch_amplitude_data",
            "type": "scalar",
            "datatype": "json",
            "description": "The wavefunction slice or projected amplitude for this branch."
          },
          {
            "name": "prob_weight",
            "type": "calculated",
            "formula": "SUM( ABS(branch_amplitude_data)^2 )",
            "description": "Probability weight for this branch in a Many-Worlds context."
          },
          {
            "name": "parent_branch_id",
            "type": "lookup",
            "target_entity": "BranchRecord",
            "description": "Points to the parent branch from which this emerged."
          },
          {
            "name": "branch_depth",
            "type": "calculated",
            "formula": "ComputeBranchDepth(parent_branch_id)",
            "description": "Number of steps from the original wavefunction root."
          },
          {
            "name": "coherence_factor",
            "type": "calculated",
            "formula": "ComputeInterference(branch_amplitude_data, wavefunction_id)",
            "description": "Overlap measure with other branches of the same wavefunction."
          },
          {
            "name": "relative_phase",
            "type": "scalar",
            "datatype": "float",
            "description": "Phase angle relative to other sibling branches, used for potential recombination."
          },
          {
            "name": "branch_history",
            "type": "scalar",
            "datatype": "json",
            "description": "Chronological list of significant events or merges relevant to this branch."
          },
          {
            "name": "observer_scope",
            "type": "scalar",
            "datatype": "json",
            "description": "Optional list of observer_ids for which this branch is relevant in partial branching (RQM) contexts."
          },
          {
            "name": "observer_relational_cut",
            "type": "scalar",
            "datatype": "json",
            "description": "Defines which subset of observers or subsystems are part of this partial branch in an RQM scenario."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "recombination_potential",
            "type": "rollup",
            "formula": "ComputeRecombinationPotential(coherence_factor, branch_amplitude_data)",
            "description": "Numerical measure of how likely this branch can recombine with other branches, factoring in coherence overlap."
          },
          {
            "name": "recombination_feasibility",
            "type": "rollup",
            "formula": "CheckRecombinationFeasibility(coherence_factor, relative_phase, wavefunction_id)",
            "description": "Examines whether re-interference is feasible given the current coherence factor and relative phase."
          },
          {
            "name": "rqm_merge_potential",
            "type": "rollup",
            "formula": "ComputeRQMBranchMergePotential(observer_scope, parent_branch_id)",
            "description": "Evaluates if branches can be merged from an RQM standpoint, e.g., when the same observer updates knowledge in partial branching."
          },
          {
            "name": "observer_scope_overlap",
            "type": "rollup",
            "formula": "CheckBranchObserverOverlap(this.branch_id, observer_scope, observer_relational_cut)",
            "description": "Determines which observers are co-branching here vs. which remain in superposition from each other’s viewpoint."
          },
          {
            "name": "branch_interference_inference",
            "type": "rollup",
            "formula": "IF(coherence_factor > 1e-3, 'Potential for re-interference', 'Effectively orthogonal')",
            "description": "Classifies whether this branch can still interfere with others or if it is effectively decohered."
          },
          {
            "name": "branch_merge_probability",
            "type": "rollup",
            "formula": "ComputeBranchMergeProbability(this.branch_id, observer_scope, coherence_factor)",
            "description": "Numerical measure of how likely partial branches can unify from an observer’s vantage."
          },
          {
            "name": "branch_reunion_check",
            "type": "rollup",
            "formula": "EvaluateBranchReunionFeasibility(this.branch_id, sibling_branches)",
            "description": "Analyzes whether sibling branches can genuinely recombine based on coherence_factor, relative_phase, and decoherence state."
          },
          {
            "name": "child_branches_count",
            "type": "rollup",
            "formula": "COUNT(BranchRecord WHERE parent_branch_id = this.branch_id)",
            "description": "Counts how many immediate child branches were spawned by this branch."
          },
          {
            "name": "relational_merge_index",
            "type": "rollup",
            "formula": "ComputeRelationalMergeIndex(this.branch_id, observer_scope, coherence_factor)",
            "description": "Rates how likely partial RQM branches can unify from an observer’s perspective, considering overlap in observer_scope."
          },
          {
            "name": "branch_probability_flow_over_time",
            "type": "rollup",
            "formula": "ComputeProbabilityFlowFromParentBranchesToChildren(this.branch_id)",
            "description": "Shows how amplitude/weight flows from one measurement event to the next across branching records."
          },
          {
            "name": "branch_reunification_pathway",
            "type": "rollup",
            "formula": "IdentifyPotentialBranchMerges(this.branch_id, sibling_branches)",
            "description": "Analyzes whether this branch can unify with siblings, given coherence_factor, relative_phase, and observer scopes."
          },
          {
            "name": "partial_branch_probability_vs_observer_scope",
            "type": "rollup",
            "formula": "SummarizePartialBranchDistribution(this.branch_id, observer_scope)",
            "description": "Computes the fraction of events or amplitude where only some observers see a collapsed branch but others do not."
          },
          {
            "name": "branch_interpretation_switching_or_coexistence",
            "type": "rollup",
            "formula": "CheckBranchLevelInterpretationConflicts(origin_meas_id, wavefunction_id.interpretation_policy_id)",
            "description": "Flags if the branch's measurement event indicates a different interpretation mode than the wavefunction’s assigned policy."
          }
        ],
        "lambdas": [
          {
            "name": "merge_partial_branches",
            "parameters": [
              "other_branch_id"
            ],
            "formula": "RQMPartialBranchMerge(this.branch_id, other_branch_id, observer_relational_cut)",
            "description": "Attempts to merge partial RQM branches if observer scope and coherence factors allow it."
          },
          {
            "name": "merge_branches_for_observer",
            "parameters": [
              "target_branch_id",
              "observer_id"
            ],
            "formula": "RQMPartialBranchMergeLogic(this.state_id, target_branch_id, observer_id)",
            "description": "Implements logic for merging two branches specifically for a given observer’s vantage in RQM."
          }
        ],
        "constraints": []
      },
      {
        "name": "Observable",
        "description": "Holds operator definitions (matrix, eigenvalues/eigenvectors) for measurable quantities (spin, position, etc.). Must be Hermitian.",
        "fields": [
          {
            "name": "operator_id",
            "type": "string",
            "description": "Unique identifier for this observable/operator."
          },
          {
            "name": "matrix_representation",
            "type": "array",
            "description": "Matrix (or array) holding the operator’s numerical data."
          },
          {
            "name": "eigenvalues",
            "type": "array",
            "description": "List of eigenvalues for quick reference in measurement events."
          },
          {
            "name": "eigenvectors",
            "type": "array",
            "description": "Eigenvectors or basis states associated with each eigenvalue."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "checkHermiticity",
            "type": "rollup",
            "formula": "VerifyHermitian(matrix_representation)",
            "description": "Ensures the operator is Hermitian, which is required for a valid observable."
          }
        ],
        "lambdas": []
      },
      {
        "name": "DensityMatrixRecord",
        "description": "Stores a density matrix representation for quantum states, possibly for open systems or mixtures. May be partial or full state.",
        "fields": [
          {
            "name": "record_id",
            "type": "string",
            "description": "Unique identifier for the density matrix record."
          },
          {
            "name": "matrix_data",
            "type": "array",
            "description": "2D array representing the density matrix (complex values)."
          },
          {
            "name": "subsystem_ids",
            "type": "array",
            "description": "IDs of the subsystem(s) described by this density matrix."
          },
          {
            "name": "purity",
            "type": "number",
            "description": "Optional cached purity measure (Tr(ρ²)) for convenience."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "computePurity",
            "type": "formula",
            "formula": "Purity(matrix_data)",
            "description": "Calculates the purity Tr(ρ²) from the matrix_data."
          },
          {
            "name": "traceValue",
            "type": "formula",
            "formula": "ComputeMatrixTrace(matrix_data)",
            "description": "Computes the trace of the density matrix, which should be 1 for proper normalization."
          },
          {
            "name": "tomographic_reconstruction",
            "type": "rollup",
            "formula": "ReconstructDensityMatrixFromMeasurements(this.record_id, MeasurementEvent.*)",
            "description": "Performs quantum state tomography by aggregating measurement outcomes across various bases."
          },
          {
            "name": "quantum_discord",
            "type": "rollup",
            "formula": "ComputeQuantumDiscord(matrix_data)",
            "description": "Computes the quantum discord for this density matrix, highlighting nonclassical correlations beyond entanglement."
          },
          {
            "name": "multipartite_negativity",
            "type": "rollup",
            "formula": "ComputeMultipartiteNegativity(matrix_data)",
            "description": "Estimates the degree of entanglement across multiple partitions by generalizing the negativity measure."
          },
          {
            "name": "mutual_information",
            "type": "rollup",
            "formula": "ComputeTotalMutualInformation(matrix_data)",
            "description": "Calculates the total mutual information among the subsystems described in this density matrix."
          },
          {
            "name": "classical_correlation",
            "type": "rollup",
            "formula": "ComputeClassicalCorrelation(matrix_data)",
            "description": "Separates the classical portion of correlations, used with quantum discord to distinguish classical vs. quantum correlations."
          },
          {
            "name": "density_matrix_extended_kochen_specker_survey",
            "type": "rollup",
            "formula": "ComputeContextualityFromDensityMatrix(matrix_data, associated_measurements)",
            "description": "Applies Kochen–Specker checks by generating projectors from the density matrix's observable bases."
          },
          {
            "name": "partial_trace_vs_branch_consistency_check",
            "type": "rollup",
            "formula": "CompareTracedOutDensityMatrixWithBranchProbabilities(record_id, BranchRecord.*)",
            "description": "Ensures the partial-trace viewpoint matches the sum of branch probabilities for the same subsystems (Many-Worlds vs. density operator)."
          }
        ],
        "lambdas": [
          {
            "name": "applyKrausOperators",
            "description": "Applies a set of Kraus operators to the density matrix for open-system evolution.",
            "params": [
              "kraus_set"
            ]
          }
        ],
        "constraints": [
          {
            "name": "trace_must_be_one",
            "formula": "ABS(ComputeMatrixTrace(matrix_data) - 1) <= 0.0001",
            "error_message": "Density matrix must have trace ~ 1.",
            "description": "Ensures the density matrix is properly normalized."
          }
        ]
      },
      {
        "name": "Subsystem",
        "description": "Represents a subsystem in a larger Hilbert space, identified by an ID, dimension, or relevant data.",
        "fields": [
          {
            "name": "subsystem_id",
            "type": "string",
            "description": "Unique ID for the subsystem."
          },
          {
            "name": "description",
            "type": "string",
            "description": "Human-readable description of what this subsystem represents (e.g. qubit, photon mode, etc.)."
          },
          {
            "name": "dimensions",
            "type": "number",
            "description": "Hilbert space dimension for this subsystem."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": []
      },
      {
        "name": "DecoherenceChannel",
        "description": "Captures a decoherence or noise model for open quantum systems, described by Kraus operators for each subsystem.",
        "fields": [
          {
            "name": "channel_id",
            "type": "string",
            "description": "Unique identifier for this decoherence or noise channel."
          },
          {
            "name": "kraus_operators",
            "type": "array",
            "description": "Collection of Kraus operators (matrices) describing the channel."
          },
          {
            "name": "applied_subsystems",
            "type": "array",
            "description": "IDs of subsystems to which this channel is applied."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "simulateDecoherence",
            "type": "formula",
            "formula": "ApplyKrausSet(density_matrix, kraus_operators)",
            "description": "Applies the stored Kraus set to a density matrix, simulating open-system evolution."
          },
          {
            "name": "validateKrausOperators",
            "type": "formula",
            "formula": "CheckKrausCompleteness(kraus_operators)",
            "description": "Ensures the sum of K^†K = I across all Kraus operators, confirming validity of the channel."
          },
          {
            "name": "channel_capacity",
            "type": "rollup",
            "formula": "ComputeQuantumChannelCapacity(kraus_operators)",
            "description": "Computes the quantum channel capacity, i.e. the max rate (in qubits per channel use) for reliably transmitting quantum information."
          },
          {
            "name": "holevo_bound",
            "type": "rollup",
            "formula": "EstimateHolevoBound(kraus_operators, typical_input_ensemble)",
            "description": "Estimates the classical capacity (Holevo limit) given a typical ensemble of input states."
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "QuantumEvolution",
        "description": "Specifies a time-evolution process (e.g. unitary or Trotter steps) for a target wavefunction, referencing a Hamiltonian.",
        "fields": [
          {
            "name": "evolution_id",
            "type": "string",
            "description": "Unique identifier for this evolution spec."
          },
          {
            "name": "hamiltonian_ref",
            "type": "string",
            "description": "Reference to an operator_id in the Observable entity that acts as the Hamiltonian."
          },
          {
            "name": "time_step",
            "type": "number",
            "description": "Time increment for stepwise evolution in chosen units."
          },
          {
            "name": "evolution_method",
            "type": "string",
            "description": "Method used (e.g. 'Trotter', 'Exact', 'RK4', etc.)."
          },
          {
            "name": "target_state_id",
            "type": "lookup",
            "target_entity": "QuantumState",
            "description": "Specifies the wavefunction to which this evolution is applied for time-dependent analyses."
          }
        ],
        "lookups": [
          {
            "name": "hamiltonian_record_id",
            "type": "lookup",
            "target_entity": "HamiltonianRecord",
            "description": "Which Hamiltonian definition we are using for this evolution (classical or quantum)."
          }
        ],
        "aggregations": [
          {
            "name": "applyTimeEvolution",
            "type": "formula",
            "formula": "U(t) = exp(-i * H * t); wavefunction' = U(t)*wavefunction",
            "description": "Applies the time evolution operator to the target wavefunction. Implementation depends on the evolution_method."
          },
          {
            "name": "hamiltonian_validity",
            "type": "formula",
            "formula": "VerifyHermitian(hamiltonian_ref)",
            "description": "Checks that the referenced Hamiltonian is Hermitian, required for a valid unitary evolution."
          },
          {
            "name": "quantum_speed_limit",
            "type": "rollup",
            "formula": "ComputeQuantumSpeedLimit(target_state_id, hamiltonian_ref)",
            "description": "Evaluates known quantum speed limits (e.g. Mandelstam–Tamm) to see how quickly the wavefunction can evolve away from its initial state."
          },
          {
            "name": "otoc_scrambling_metric",
            "type": "rollup",
            "formula": "ComputeOTOCScrambling(hamiltonian_ref, target_state_id)",
            "description": "Computes an Out-of-Time-Ordered Correlator (OTOC) to measure information scrambling or chaotic dynamics under the specified Hamiltonian."
          },
          {
            "name": "pointer_basis_stability_timeline",
            "type": "rollup",
            "formula": "TrackPointerStabilityOverEvolution(target_state_id, hamiltonian_ref, time_step)",
            "description": "Monitors whether identified pointer states remain stable or begin interfering again as the system evolves in time."
          },
          {
            "name": "unitarity_deviation",
            "type": "rollup",
            "formula": "ComputeUnitarityDeviation(hamiltonian_ref, time_step, evolution_method)",
            "description": "Estimates how non-unitary the resulting time evolution operator might be (e.g., from Trotterization error)."
          },
          {
            "name": "quantum_speed_classical_emergence_ratio",
            "type": "rollup",
            "formula": "ComputeSpeedClassicalEmergenceRatio(quantum_speed_limit, QuantumState.classical_limit_indicator)",
            "description": "Evaluates the ratio between the quantum speed limit timescale and the classical emergence timescale from decoherence."
          },
          {
            "name": "classical_limit_check",
            "type": "rollup",
            "formula": "AssessIfKineticTerm >> PotentialTerm or decoherence times => classical limit?",
            "description": "Toy aggregator to see if quantum evolution effectively appears classical under certain dynamic conditions."
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "QuantumEvent",
        "description": "Logs a broader quantum event (not strictly a measurement), e.g. a unitary gate, entangling interaction, or a specialized operation.",
        "fields": [
          {
            "name": "event_id",
            "type": "string",
            "description": "Unique identifier for the quantum event."
          },
          {
            "name": "type",
            "type": "string",
            "description": "General type of event (e.g. 'measurement', 'unitary', 'entangling_interaction')."
          },
          {
            "name": "operator_ref",
            "type": "string",
            "description": "Optional reference to an Observable (for measurement) or other operator."
          },
          {
            "name": "applied_to",
            "type": "array",
            "description": "List of subsystem_ids or wavefunction_ids that this event acts upon."
          },
          {
            "name": "timestamp",
            "type": "string",
            "description": "Record of when the event happened, if relevant."
          },
          {
            "name": "metadata",
            "type": "object",
            "description": "Free-form map for additional information about this event."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "verifyEventApplicability",
            "type": "formula",
            "formula": "CheckEventConsistency(type, operator_ref, applied_to)",
            "description": "Ensures that measurement events reference a valid measurement operator, or that a unitary event references a valid gate, etc."
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "ObserverRelationship",
        "description": "Describes the relationship between two observers, capturing shared measurement events, cross-checking, or potential paradoxes (Wigner’s friend).",
        "fields": [
          {
            "name": "relationship_id",
            "type": "string",
            "description": "Unique ID for this relationship record."
          },
          {
            "name": "observer_A",
            "type": "string",
            "description": "Reference to one ObserverFrame in the relationship."
          },
          {
            "name": "observer_B",
            "type": "string",
            "description": "Reference to another ObserverFrame in the relationship."
          },
          {
            "name": "shared_events",
            "type": "array",
            "description": "IDs of MeasurementEvents (or QuantumEvents) both observers have potentially compared."
          },
          {
            "name": "consistency_state",
            "type": "string",
            "description": "Status: e.g. 'agreed', 'unresolved', 'contradictory', etc."
          },
          {
            "name": "relational_view_consistency",
            "type": "scalar",
            "datatype": "json",
            "description": "Snapshot of how observer_A perceives observer_B vs how B perceives themselves, for explicit RQM cross-checking."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "observer_agreement_score",
            "type": "rollup",
            "formula": "ComputeObserverAgreement(observer_A, observer_B, shared_events)",
            "description": "Calculates a numeric or qualitative measure of how consistently the two observers interpret shared measurement events."
          },
          {
            "name": "rqm_intersubjective_discrepancy",
            "type": "rollup",
            "formula": "ComputeRQMDiscrepancy(observer_A, observer_B, relational_view_consistency)",
            "description": "Quantifies mismatch between how A sees B’s wavefunction and how B sees their own wavefunction in RQM contexts."
          },
          {
            "name": "wigners_friend_paradox_indicator",
            "type": "rollup",
            "formula": "DetectWignersFriendParadox(observer_A, observer_B, shared_events)",
            "description": "Flags a mismatch if observer A sees a collapsed outcome while observer B sees a superposition for the same event."
          },
          {
            "name": "nested_wigners_friend_indicator",
            "type": "rollup",
            "formula": "CheckNestedWignerScenario(observer_A, observer_B, shared_events)",
            "description": "Detects multi-level scenarios where B sees A in superposition after A measured the system."
          },
          {
            "name": "detect_cyclic_measurement_loop",
            "type": "rollup",
            "formula": "IdentifyMeasurementCyclesBetweenObservers(observer_A, observer_B, shared_events)",
            "description": "Checks if observer A measures observer B while B also measures A, forming a cycle (relevant in RQM or Wigner’s friend)."
          },
          {
            "name": "extended_nested_wigner_analysis",
            "type": "rollup",
            "formula": "ComputeMultiLevelWignerFriendScenario(observer_A, observer_B, shared_events)",
            "description": "Performs a deeper search for multi-level nested Wigner’s friend arrangements, analyzing partial collapses or superpositions at each vantage."
          },
          {
            "name": "multi_level_paradox_analysis",
            "type": "rollup",
            "formula": "AnalyzeMultiLevelWignerScenarios(observer_A, observer_B, shared_events)",
            "description": "Examines whether observer A or B is also being observed by other frames, forming multi-tier Wigner’s friend loops."
          },
          {
            "name": "frame_discrepancy",
            "type": "rollup",
            "formula": "ComputeFrameDifference(observer_A, observer_B)",
            "description": "Compares reference_frame_transform data from the two observers to identify any relative shift/boost or basis difference."
          },
          {
            "name": "relational_wigner_analysis",
            "type": "rollup",
            "formula": "ComputeRelationalWignerFriendAnalysis(observer_A, observer_B, shared_events)",
            "description": "General check for whether observer A sees B in superposition while B sees themselves as collapsed, indicating a Wigner’s friend paradox at the relational level."
          },
          {
            "name": "reference_frame_transform_consistency",
            "type": "rollup",
            "formula": "CheckReferenceFrameAlignment(observer_A, observer_B, ObserverFrame.*)",
            "description": "Examines the coordinate transformations each observer applies to confirm they do not produce contradictory measurement accounts."
          },
          {
            "name": "shared_context_agreement",
            "type": "rollup",
            "formula": "ComputeSharedContextualOverlap(observer_A.epistemic_context, observer_B.epistemic_context)",
            "description": "Measures overlap in Bayesian priors or knowledge states between the two observers."
          },
          {
            "name": "asymmetric_view_check",
            "type": "rollup",
            "formula": "CheckAsymmetricObservation(observer_A, observer_B, relational_view_consistency)",
            "description": "Flags if A sees B in superposition while B sees themselves collapsed, or vice versa."
          },
          {
            "name": "multi_level_wigner_nesting_indicator",
            "type": "rollup",
            "formula": "AnalyzeNestedWignerFriendScenarios(shared_events, nested_wigners_friend_indicator)",
            "description": "Detects and quantifies multi-level Wigner’s friend nesting by analyzing observer relationship records for cycles and nested measurement dependencies."
          },
          {
            "name": "multi_level_observation_loop_score",
            "type": "rollup",
            "formula": "DetectNestedObservationLoops(observer_A, observer_B, shared_events)",
            "description": "Produces a numeric or qualitative score indicating the depth of nested or cyclical measurement loops between these observers."
          }
        ],
        "lambdas": [
          {
            "name": "resolve_rqm_inconsistency",
            "parameters": [],
            "formula": "AttemptRQMInconsistencyResolution(observer_A, observer_B, shared_events, relational_view_consistency)",
            "description": "Attempts to reconcile or resolve an RQM inconsistency by adjusting relational states or identifying unmeasured degrees of freedom."
          }
        ]
      },
      {
        "name": "ConsistencyCheck",
        "description": "General entity for logging or storing consistency-check results across quantum or classical data, possibly referencing warnings or errors.",
        "fields": [
          {
            "name": "check_id",
            "type": "string",
            "description": "Unique identifier for this consistency check."
          },
          {
            "name": "description",
            "type": "string",
            "description": "Describes the nature or purpose of this check."
          },
          {
            "name": "severity",
            "type": "string",
            "description": "Priority/impact level for this check (e.g. 'warning', 'error')."
          },
          {
            "name": "results",
            "type": "array",
            "description": "Potentially a list of results or validations discovered."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": []
      },
      {
        "name": "QuantumCircuit",
        "description": "Represents a sequence of quantum gates operating on a target wavefunction or subsystem(s), with optional aggregator to run gates and measure.",
        "fields": [
          {
            "name": "circuit_id",
            "type": "string",
            "description": "Unique identifier for this quantum circuit."
          },
          {
            "name": "gates",
            "type": "array",
            "description": "List of gate specifications (e.g. {gate_type, targets, control})."
          },
          {
            "name": "target_wavefunction",
            "type": "string",
            "description": "Reference to the wavefunction or subsystem(s) on which this circuit operates."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "generateCircuitMatrix",
            "type": "formula",
            "formula": "ComposeAllGatesIntoMatrix(gates)",
            "description": "Composes all gates in this circuit into a single operator matrix."
          },
          {
            "name": "validateCircuit",
            "type": "formula",
            "formula": "CheckGateSequence(gates, target_wavefunction)",
            "description": "Validates gate definitions and ensures they match the dimension of the target wavefunction or subsystem."
          },
          {
            "name": "executeCircuitAndMeasure",
            "type": "rollup",
            "formula": "ApplyCircuitThenMeasure(this.circuit_id, target_wavefunction, measurement_config)",
            "description": "Convenience aggregator that applies all gates in sequence and then performs measurement events as specified."
          },
          {
            "name": "gate_count",
            "type": "rollup",
            "formula": "LENGTH(gates)",
            "description": "Returns the total number of gates in this circuit."
          },
          {
            "name": "circuit_depth",
            "type": "rollup",
            "formula": "ComputeCircuitDepth(gates)",
            "description": "Calculates how many gate layers exist, i.e. the circuit depth."
          },
          {
            "name": "controlled_gate_count",
            "type": "rollup",
            "formula": "COUNT(gates WHERE gates.control IS NOT NULL)",
            "description": "Counts how many gates in the circuit specify a 'control' field (e.g., CNOT, Toffoli)."
          }
        ],
        "lambdas": [
          {
            "name": "executeCircuit",
            "description": "Applies each gate in sequence to the specified wavefunction or subsystem state.",
            "params": []
          }
        ]
      },
      {
        "name": "IntersubjectiveRecord",
        "description": "Stores how a group of observers come to (or fail to reach) mutual agreement in RQM contexts, referencing multi-observer final states.",
        "fields": [
          {
            "name": "record_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this intersubjective record."
          },
          {
            "name": "participants",
            "type": "scalar",
            "datatype": "json",
            "description": "List of observer_ids involved in the comparison or sharing process."
          },
          {
            "name": "comparison_strategy",
            "type": "scalar",
            "datatype": "string",
            "description": "Method used to compare states, e.g. 'direct_communication', 'classical_channel', or 'measurement_of_observer'."
          },
          {
            "name": "final_state_agreement",
            "type": "scalar",
            "datatype": "json",
            "description": "Aggregated final state or outcome that participants converge on (if any)."
          }
        ],
        "aggregations": [
          {
            "name": "participant_discrepancies",
            "type": "rollup",
            "formula": "ComputeMultiObserverDiscrepancies(participants)",
            "description": "Checks for outcome/state discrepancies among all participants."
          },
          {
            "name": "multi_observer_inference",
            "type": "rollup",
            "formula": "IF(participant_discrepancies == 0, 'All participants in agreement', 'Discrepancies found among participants')",
            "description": "Evaluates whether multiple observers end up with the same final outcome or if they disagree."
          },
          {
            "name": "multi_observer_classical_darwinism",
            "type": "rollup",
            "formula": "IF( SUM(ObserverFrame.quantum_darwinism_index FOR each participant) > some_threshold, 'Classical pointer states emergent', 'Significant quantum coherence remains' )",
            "description": "Checks if participants collectively share enough overlapping measurement info to treat the outcome as a classical pointer."
          },
          {
            "name": "multi_level_paradox_analysis",
            "type": "rollup",
            "formula": "AnalyzeNestedWignerFriendsAmongParticipants(this.record_id, participants)",
            "description": "Checks for multi-level nested or cyclical observer-measurements across all participants, detecting possible RQM paradoxes."
          },
          {
            "name": "categorize_multi_observer_agreement",
            "type": "rollup",
            "formula": "ClassifyObserverConsensus(final_state_agreement, participant_discrepancies)",
            "description": "Distinguishes complete agreement (classical consensus), partial disagreement resolvable by communication, or irreconcilable RQM paradox among participants."
          },
          {
            "name": "classical_ledger_construction",
            "type": "rollup",
            "formula": "BuildIntersubjectiveClassicalRecord(this.record_id, participants)",
            "description": "Derives an 'effective classical record' from multiple observers' final outcomes if they converge strongly."
          },
          {
            "name": "fully_classical_ledger_flag",
            "type": "rollup",
            "formula": "IF(participant_discrepancies == 0 AND multi_observer_classical_darwinism == 'Classical pointer states emergent', 'Yes', 'No')",
            "description": "Indicates if participants converge on a classical-like pointer outcome with no discrepancies."
          },
          {
            "name": "robust_classical_fact_index",
            "type": "rollup",
            "formula": "ComputeRobustClassicalFactIndex(participants, final_state_agreement, participant_discrepancies)",
            "description": "Scores how stable the final agreed-upon outcome is under small changes. Higher index => robustly shared classical fact."
          }
        ],
        "lambdas": [
          {
            "name": "execute_comparison_protocol",
            "parameters": [],
            "formula": "RunRQMIntersubjectiveComparison(this.record_id, participants)",
            "description": "Carries out a comparison protocol among participants to detect or resolve any observer-based discrepancies."
          }
        ],
        "constraints": []
      },
      {
        "name": "ScenarioWavefunctionLink",
        "description": "Bridging entity linking a GlobalScenarioRecord with QuantumStates included in that scenario.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this link record."
          },
          {
            "name": "scenario_id",
            "type": "lookup",
            "target_entity": "GlobalScenarioRecord",
            "description": "Which scenario is associated with the linked wavefunction."
          },
          {
            "name": "state_id",
            "type": "lookup",
            "target_entity": "QuantumState",
            "description": "Which quantum state is included in the scenario."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": []
      },
      {
        "name": "ParameterSweepRecord",
        "description": "Logs a parameter sweep over a QuantumEvolution for scanning different Hamiltonian or system parameters and storing results.",
        "fields": [
          {
            "name": "sweep_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the parameter sweep."
          },
          {
            "name": "parameters",
            "type": "scalar",
            "datatype": "json",
            "description": "Map of parameter names and their ranges for the sweep."
          },
          {
            "name": "target_evolution_id",
            "type": "lookup",
            "target_entity": "QuantumEvolution",
            "description": "The QuantumEvolution record we’re sweeping over."
          }
        ],
        "aggregations": [
          {
            "name": "run_sweep_and_store_results",
            "type": "rollup",
            "formula": "ExecuteParameterSweep(target_evolution_id, parameters)",
            "description": "Executes the time evolution for each parameter set, storing aggregator or wavefunction results as needed."
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "MeasurementResult",
        "description": "Stores the raw or aggregated outcomes of a particular measurement event, e.g. repeated shots yielding a bitstring distribution.",
        "fields": [
          {
            "name": "result_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this measurement result record."
          },
          {
            "name": "measurement_id",
            "type": "lookup",
            "target_entity": "MeasurementEvent",
            "description": "Links to the measurement event producing these results."
          },
          {
            "name": "raw_bitstring",
            "type": "scalar",
            "datatype": "string",
            "description": "Optionally stores the raw measurement bits or symbolic outcome label."
          },
          {
            "name": "count",
            "type": "scalar",
            "datatype": "int",
            "description": "Number of occurrences of this particular result or bitstring."
          }
        ]
      },
      {
        "name": "PhysicalConstantsRecord",
        "description": "Stores fundamental constants (Planck, speed of light, G, Boltzmann, etc.) with numeric value, units, and optional uncertainty.",
        "fields": [
          {
            "name": "record_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this constants record."
          },
          {
            "name": "symbol",
            "type": "scalar",
            "datatype": "string",
            "description": "Short symbolic name for this constant (e.g. 'c', 'h', 'k_B')."
          },
          {
            "name": "value",
            "type": "scalar",
            "datatype": "float",
            "description": "Numeric value in chosen base SI units."
          },
          {
            "name": "units",
            "type": "scalar",
            "datatype": "string",
            "description": "String describing the unit system (e.g. 'm/s', 'J·s')."
          },
          {
            "name": "uncertainty",
            "type": "scalar",
            "datatype": "float",
            "description": "Optional standard error or fractional uncertainty for this constant."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Additional remarks or references about the constant."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "ReferenceFrameRecord",
        "description": "Stores or indexes classical coordinate systems, transformations, or Minkowski references for usage by wavefunctions or particles.",
        "fields": [
          {
            "name": "reference_frame_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this reference frame."
          },
          {
            "name": "frame_name",
            "type": "scalar",
            "datatype": "string",
            "description": "Human-friendly label (e.g. 'Lab Frame', 'Minkowski_4D')."
          },
          {
            "name": "dimensions",
            "type": "scalar",
            "datatype": "int",
            "description": "Number of spatial (or spacetime) dimensions used by this frame."
          },
          {
            "name": "coordinate_model",
            "type": "scalar",
            "datatype": "string",
            "description": "Type of coordinates, e.g. 'Cartesian', 'Spherical', 'Minkowski', etc."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any extra text or references about this frame."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "PotentialRecord",
        "description": "For classical or quantum usage, storing a potential function (harmonic oscillator, inverse-square, etc.) with symbolic or param-based expression.",
        "fields": [
          {
            "name": "potential_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for this potential record."
          },
          {
            "name": "potential_name",
            "type": "scalar",
            "datatype": "string",
            "description": "Descriptive name of the potential (e.g. '1D Harmonic Oscillator', 'Coulomb', 'Morse')."
          },
          {
            "name": "functional_form",
            "type": "scalar",
            "datatype": "json",
            "description": "Symbolic or param-based expression of the potential, e.g. 'V(r) = -G*M*m/r'."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any extra text or references regarding this potential."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "value_at_position",
            "type": "rollup",
            "parameters": [
              "coords"
            ],
            "formula": "Evaluate(functional_form, coords)",
            "description": "Computes the potential's numeric value at given coordinate(s)."
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "HamiltonianRecord",
        "description": "Combines kinetic + potential terms in classical or quantum contexts. Might reference an associated PotentialRecord for the V(x) portion.",
        "fields": [
          {
            "name": "hamiltonian_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this Hamiltonian record."
          },
          {
            "name": "description",
            "type": "scalar",
            "datatype": "string",
            "description": "Short text describing which system this Hamiltonian applies to."
          },
          {
            "name": "domain_type",
            "type": "scalar",
            "datatype": "string",
            "description": "Indicates 'classical', 'quantum', or 'mixed' domain for this Hamiltonian."
          },
          {
            "name": "kinetic_term",
            "type": "scalar",
            "datatype": "json",
            "description": "Symbolic or param-based representation of T(p). E.g. 'p^2/(2*m)'."
          },
          {
            "name": "potential_id",
            "type": "lookup",
            "target_entity": "PotentialRecord",
            "description": "Reference to PotentialRecord for the V(x) portion."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "ParticleRecord",
        "description": "Represents a (possibly classical) particle: mass, charge, spin, classical position/velocity, or references to quantum states.",
        "fields": [
          {
            "name": "particle_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the particle."
          },
          {
            "name": "label",
            "type": "scalar",
            "datatype": "string",
            "description": "Optional label for the particle."
          },
          {
            "name": "mass",
            "type": "scalar",
            "datatype": "float",
            "description": "Particle’s mass in kg (if classical) or relevant units."
          },
          {
            "name": "charge",
            "type": "scalar",
            "datatype": "float",
            "description": "Electric charge in Coulombs, or 0 for neutral."
          },
          {
            "name": "spin",
            "type": "scalar",
            "datatype": "float",
            "description": "Particle spin value (e.g. 0.5 for an electron)."
          },
          {
            "name": "classical_position",
            "type": "scalar",
            "datatype": "json",
            "description": "Vector or array for (x, y, z) if describing a classical trajectory."
          },
          {
            "name": "classical_velocity",
            "type": "scalar",
            "datatype": "json",
            "description": "Vector or array for (vx, vy, vz) in classical contexts."
          },
          {
            "name": "reference_frame_id",
            "type": "lookup",
            "target_entity": "ReferenceFrameRecord",
            "description": "Which reference frame these coords are measured in."
          },
          {
            "name": "attached_quantum_state_id",
            "type": "lookup",
            "target_entity": "QuantumState",
            "description": "If also described by a quantum state (single-particle wavefunction)."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any extra text or references about this particle."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "velocity_magnitude",
            "type": "rollup",
            "formula": "SQRT( (classical_velocity.x^2) + (classical_velocity.y^2) + (classical_velocity.z^2) )",
            "description": "Computes the magnitude of the particle’s velocity vector, if it has one."
          }
        ],
        "lambdas": [
          {
            "name": "update_position",
            "parameters": [
              "delta_t"
            ],
            "formula": "classical_position + classical_velocity * delta_t",
            "description": "Naive classical step to evolve position over a short time interval delta_t."
          }
        ],
        "constraints": []
      },
      {
        "name": "ParticleWavefunctionMapping",
        "description": "Bridging table attaching multiple Particles to a single QuantumState. Useful for multi-particle wavefunctions in a shared Hilbert space.",
        "action": "create_entity",
        "fields": [
          {
            "fieldName": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this mapping record."
          },
          {
            "fieldName": "particle_id",
            "type": "lookup",
            "target_entity": "ParticleRecord",
            "description": "Points to the Particle that is part of this wavefunction."
          },
          {
            "fieldName": "wavefunction_id",
            "type": "lookup",
            "target_entity": "QuantumState",
            "description": "Points to the QuantumState that multiple particles can share."
          },
          {
            "fieldName": "role_label",
            "type": "scalar",
            "datatype": "string",
            "description": "Optional label (e.g. 'electron #1' or 'spin-up proton') describing the role of the particle in the wavefunction."
          }
        ]
      },
      {
        "name": "ForceRecord",
        "description": "Classical force concept, e.g. gravitational or electromagnetic, typically bridging classical realms. Could be used in N-body computations.",
        "fields": [
          {
            "name": "force_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this force record."
          },
          {
            "name": "force_type",
            "type": "scalar",
            "datatype": "string",
            "description": "Type of force (e.g. 'gravitational', 'electrostatic', 'magnetic')."
          },
          {
            "name": "particle_id",
            "type": "lookup",
            "target_entity": "ParticleRecord",
            "description": "The particle on which this force is acting."
          },
          {
            "name": "force_vector",
            "type": "scalar",
            "datatype": "json",
            "description": "Components of the force vector, e.g. [Fx, Fy, Fz]."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any extra comments or references about this force."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": [
          {
            "name": "compute_newtonian_force",
            "parameters": [
              "other_particle_ids"
            ],
            "formula": "e.g. G*m1*m2 / r^2 direction, storing in force_vector",
            "description": "Toy aggregator for summing gravitational or Coulomb forces from multiple particles in a classical approximation."
          }
        ],
        "constraints": []
      },
      {
        "name": "GaugeFieldRecord",
        "description": "Stores e.g. (E,B) or (Aμ) for a classical or quantum gauge field. May be U(1) or non-Abelian, used for field dynamics or transformations.",
        "fields": [
          {
            "name": "gauge_field_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this gauge field record."
          },
          {
            "name": "gauge_type",
            "type": "scalar",
            "datatype": "string",
            "description": "Gauge group type, e.g. 'U(1)', 'SU(2)', 'SU(3)'."
          },
          {
            "name": "field_components",
            "type": "scalar",
            "datatype": "json",
            "description": "Example: E, B for an electromagnetic field, or Aμ for a non-Abelian field."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any additional info or references about this gauge field."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "field_strength_tensor",
            "type": "rollup",
            "formula": "ConstructFmuNu(field_components)",
            "description": "Builds the field strength tensor Fμν from the gauge field components."
          }
        ],
        "lambdas": [
          {
            "name": "perform_gauge_transformation",
            "parameters": [
              "gauge_function"
            ],
            "formula": "Aμ -> Aμ + ∂μ(gauge_function)",
            "description": "Applies a gauge transformation to the field, shifting Aμ by the gradient of gauge_function."
          }
        ],
        "constraints": []
      },
      {
        "name": "ClassicalSystemRecord",
        "description": "Groups multiple classical or partially classical particles for aggregated properties like total mass, momentum, etc.",
        "fields": [
          {
            "name": "system_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this classical system record."
          },
          {
            "name": "system_name",
            "type": "scalar",
            "datatype": "string",
            "description": "A label or descriptive name for the system."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any additional info or references about this classical system."
          }
        ],
        "lookups": [
          {
            "name": "members",
            "type": "one_to_many",
            "target_entity": "ParticleRecord",
            "join_condition": "ParticleRecord.classical_system_id = this.system_id",
            "description": "Particles in this system, if they store classical_system_id = system_id."
          }
        ],
        "aggregations": [
          {
            "name": "sum_of_particle_energies",
            "type": "rollup",
            "formula": "SUM( if we define kinetic + potential )",
            "description": "Placeholder aggregator for summing particle energies if they have kinetic or potential definitions."
          },
          {
            "name": "total_system_mass",
            "type": "rollup",
            "formula": "SUM(members.mass)",
            "description": "Computes the total mass of all particles in this classical system."
          },
          {
            "name": "total_system_momentum",
            "type": "rollup",
            "formula": "VECTOR_SUM(members.mass * members.velocity)",
            "description": "Computes the net momentum of the system by summing each member’s mass * velocity."
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "SpacetimeMetricRecord",
        "description": "Stores a 3+1 or 4D metric. Potentially references Einstein equation aggregator referencing stress-energy, etc.",
        "fields": [
          {
            "name": "metric_record_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this metric record."
          },
          {
            "name": "metric_tensor",
            "type": "scalar",
            "datatype": "json",
            "description": "Matrix or array representing gμν for the chosen coordinate system."
          },
          {
            "name": "reference_frame_id",
            "type": "lookup",
            "target_entity": "ReferenceFrameRecord",
            "description": "Links to the reference frame in which this metric is defined."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any additional comments or references about this metric."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "ricci_scalar",
            "type": "rollup",
            "formula": "ComputeRicciScalar(metric_tensor)",
            "description": "Computes the Ricci scalar (R) for the metric."
          },
          {
            "name": "ricci_tensor",
            "type": "rollup",
            "formula": "ComputeRicciTensor(metric_tensor)",
            "description": "Computes the Ricci tensor (Rμν) from the metric."
          },
          {
            "name": "einstein_tensor",
            "type": "rollup",
            "formula": "ComputeEinsteinTensor(ricci_tensor, ricci_scalar)",
            "description": "Builds the Einstein tensor Gμν = Rμν - 0.5*gμν*R."
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "BlackHoleSystemRecord",
        "description": "Entity for horizon radius, Hawking temperature, referencing mass, etc. Particularly for analyzing black-hole thermodynamics in a scenario.",
        "fields": [
          {
            "name": "bh_system_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this black hole system."
          },
          {
            "name": "bh_label",
            "type": "scalar",
            "datatype": "string",
            "description": "Optional label or name for the black hole (e.g., 'Stellar-mass BH')."
          },
          {
            "name": "approx_mass",
            "type": "scalar",
            "datatype": "float",
            "description": "Approximate mass of this black hole in kg (or solar masses)."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any extra details or references about this black hole."
          }
        ],
        "lookups": [
          {
            "name": "scenario_id",
            "type": "lookup",
            "target_entity": "GlobalScenarioRecord",
            "description": "Which global scenario this black hole system is part of, enabling cross-referencing scenario-level aggregators."
          }
        ],
        "aggregations": [
          {
            "name": "schwarzschild_radius",
            "type": "rollup",
            "formula": "(2 * G * approx_mass)/(c^2)",
            "description": "Computes the Schwarzschild radius for a non-rotating black hole, referencing G and c from PhysicalConstants if desired."
          },
          {
            "name": "branch_depth_blackhole_thermo_inference",
            "type": "rollup",
            "formula": "AnalyzeBranchDepthAndBHProperties(scenario_id.max_branch_depth_across_scenario, this.schwarzschild_radius, hawking_temperature)",
            "description": "Correlates the scenario's maximum wavefunction branch depth with black-hole horizon properties."
          },
          {
            "name": "branch_cut_analysis",
            "type": "rollup",
            "formula": "AnalyzeBHAsHeisenbergCut(this.bh_system_id, scenario_id)",
            "description": "Checks if the black-hole horizon functions as a decoherence boundary, correlating wavefunction branching data with BH mass/horizon size."
          }
        ],
        "lambdas": [
          {
            "name": "hawking_temperature",
            "parameters": [],
            "formula": "UseApproximationsForHawkingTemp(approx_mass)",
            "description": "Estimates Hawking temperature: T ~ ħ * c^3 / (8π G M k_B)."
          }
        ],
        "constraints": []
      },
      {
        "name": "DarkMatterInferenceRecord",
        "description": "2.0 style entity summarizing missing mass, potential DM cross-sections, confidence, etc., referencing a scenario and region.",
        "fields": [
          {
            "name": "record_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the dark matter inference record."
          },
          {
            "name": "scenario_id",
            "type": "lookup",
            "target_entity": "GlobalScenarioRecord",
            "description": "Link to the global scenario under analysis."
          },
          {
            "name": "region_reference",
            "type": "lookup",
            "target_entity": "ClassicalSystemRecord",
            "description": "Which classical system or region is being analyzed for dark matter."
          },
          {
            "name": "observed_mass",
            "type": "scalar",
            "datatype": "float",
            "description": "Mass derived from luminous matter and known baryons."
          },
          {
            "name": "total_system_mass",
            "type": "scalar",
            "datatype": "float",
            "description": "Inferred total mass from rotation curves, lensing, or other data."
          },
          {
            "name": "missing_mass",
            "type": "lambda",
            "parameters": [],
            "formula": "total_system_mass - observed_mass",
            "description": "Difference between total and observed mass, representing missing (dark) mass."
          },
          {
            "name": "residual_mass_fraction",
            "type": "lambda",
            "parameters": [],
            "formula": "(total_system_mass - observed_mass) / total_system_mass",
            "description": "Fraction of total mass attributed to dark matter."
          },
          {
            "name": "confidence_level",
            "type": "scalar",
            "datatype": "float",
            "description": "Aggregated confidence (domain-specific measure) in the missing mass inference."
          },
          {
            "name": "timestamp",
            "type": "scalar",
            "datatype": "datetime",
            "description": "Timestamp when this inference was recorded or updated."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "dm_entanglement_correlation",
            "type": "rollup",
            "formula": "CorrelateEntanglementWithMissingMass(this.record_id, scenario_id)",
            "description": "Analyzes wavefunction entanglement across the scenario and compares it with the fraction of missing dark mass."
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "HaloSubstructureRecord",
        "description": "Captures local density fluctuations and subhalo mass distributions within DM halos, referencing a scenario if needed.",
        "fields": [
          {
            "name": "subhalo_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the subhalo."
          },
          {
            "name": "subhalo_mass_distribution",
            "type": "scalar",
            "datatype": "json",
            "description": "Distribution of mass within the subhalo."
          },
          {
            "name": "concentration_parameter",
            "type": "scalar",
            "datatype": "float",
            "description": "Parameter indicating halo concentration."
          },
          {
            "name": "local_density_variation",
            "type": "scalar",
            "datatype": "float",
            "description": "Variation in local dark matter density."
          },
          {
            "name": "scenario_id",
            "type": "lookup",
            "target_entity": "GlobalScenarioRecord",
            "description": "Which scenario this subhalo belongs to, if relevant."
          },
          {
            "name": "linked_region",
            "type": "lookup",
            "target_entity": "DarkMatterInferenceRecord",
            "description": "Optionally links this substructure to a DM inference record for deeper analysis."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "BaryonicFeedbackRecord",
        "description": "Captures effects of baryonic processes (star formation, AGN feedback) on mass distribution, referencing a region or system.",
        "fields": [
          {
            "name": "feedback_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the feedback event."
          },
          {
            "name": "feedback_intensity",
            "type": "scalar",
            "datatype": "float",
            "description": "Measure of feedback strength, e.g. star formation rate or AGN outflow rate."
          },
          {
            "name": "energy_injection_rate",
            "type": "scalar",
            "datatype": "float",
            "description": "Rate at which energy is injected into the medium."
          },
          {
            "name": "mass_loss_fraction",
            "type": "scalar",
            "datatype": "float",
            "description": "Fraction of mass lost due to these feedback processes."
          },
          {
            "name": "linked_region",
            "type": "lookup",
            "target_entity": "ClassicalSystemRecord",
            "description": "Reference to the system or region affected by the feedback."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any additional remarks or references about this feedback record."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "CosmicEvolutionRecord",
        "description": "Tracks evolution of cosmic parameters over redshift/time, allowing correlation with scenario data such as wavefunctions or observers.",
        "fields": [
          {
            "name": "evolution_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the cosmic evolution record."
          },
          {
            "name": "redshift",
            "type": "scalar",
            "datatype": "float",
            "description": "Redshift value indicating the cosmic epoch."
          },
          {
            "name": "cosmic_time",
            "type": "scalar",
            "datatype": "float",
            "description": "Cosmic time in Gyr or another appropriate unit."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any additional remarks or references about this cosmic evolution snapshot."
          },
          {
            "name": "scenario_id",
            "type": "lookup",
            "target_entity": "GlobalScenarioRecord",
            "description": "Link to the scenario under which this cosmic evolution snapshot is considered."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "EnvironmentalInfluenceRecord",
        "description": "Captures local environmental effects such as tidal interactions or merger history in cosmic contexts, referencing a classical region or system.",
        "fields": [
          {
            "name": "environment_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the environmental influence record."
          },
          {
            "name": "local_density",
            "type": "scalar",
            "datatype": "float",
            "description": "Local density measure in the region."
          },
          {
            "name": "tidal_effects",
            "type": "scalar",
            "datatype": "float",
            "description": "Numeric index representing tidal forces."
          },
          {
            "name": "merger_history",
            "type": "scalar",
            "datatype": "json",
            "description": "Historical record of recent mergers or interactions."
          },
          {
            "name": "linked_region",
            "type": "lookup",
            "target_entity": "ClassicalSystemRecord",
            "description": "Reference to the system or halo impacted by environmental factors."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Any additional remarks or references about these environmental effects."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "influence_modifier",
            "type": "rollup",
            "formula": "ComputeInfluenceModifier(local_density, tidal_effects, merger_history)",
            "description": "Produces a numeric or qualitative factor adjusting dark matter or baryonic inferences based on environmental conditions."
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "DarkMatterInference",
        "description": "Entity capturing second-order inferences regarding dark matter from aggregated system data, possibly referencing subhalo structures, cosmic evolution, etc.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the dark matter inference record."
          },
          {
            "name": "region_reference",
            "type": "lookup",
            "target_entity": "ClassicalSystemRecord",
            "description": "Reference to the system or region where the inference is made."
          },
          {
            "name": "total_system_mass",
            "type": "aggregation",
            "formula": "SUM(members.mass)",
            "description": "Total gravitational mass inferred for the region."
          },
          {
            "name": "observed_mass",
            "type": "aggregation",
            "formula": "SUM(Particle.mass WHERE Particle.is_observed = true) + ICL_contribution",
            "description": "Mass derived from luminous matter including possible intra-cluster light."
          },
          {
            "name": "missing_mass",
            "type": "lambda",
            "parameters": [],
            "formula": "total_system_mass - observed_mass",
            "description": "Difference between total and observed mass, representing missing mass."
          },
          {
            "name": "residual_mass_fraction",
            "type": "lambda",
            "parameters": [],
            "formula": "(total_system_mass - observed_mass) / total_system_mass",
            "description": "Fraction of total mass attributed to dark matter."
          },
          {
            "name": "DM_particle_mass_estimate",
            "type": "lambda",
            "parameters": [],
            "formula": "BaseEstimate(rotation_curve_correction, local_interaction_modifier) * luminosity_profile_factor",
            "description": "Estimated mass for individual dark matter particles, adjusted by local rotational and luminosity factors."
          },
          {
            "name": "interaction_cross_section",
            "type": "lambda",
            "parameters": [],
            "formula": "InferInteractionCrossSection(potential_deviations, known_baryonic_interactions)",
            "description": "Estimated non-gravitational interaction strength of dark matter."
          },
          {
            "name": "confidence_level",
            "type": "aggregation",
            "formula": "AggregateConfidence(associated_references)",
            "description": "Aggregated confidence score based on supporting observational references."
          },
          {
            "name": "associated_references",
            "type": "lookup",
            "target_entity": "Papers",
            "description": "Links to relevant papers or datasets supporting this inference."
          },
          {
            "name": "timestamp",
            "type": "scalar",
            "datatype": "datetime",
            "description": "Timestamp of when this inference was made or updated."
          }
        ]
      },
      {
        "name": "ObservationalDataset",
        "description": "Entity representing raw observational data from surveys, capturing parameters such as photometry, spectroscopy, and derived uncertainties.",
        "fields": [
          {
            "name": "dataset_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the observational dataset."
          },
          {
            "name": "source_name",
            "type": "scalar",
            "datatype": "string",
            "description": "Name of the survey or telescope (e.g. SDSS, DES, Planck, Euclid)."
          },
          {
            "name": "data_parameters",
            "type": "scalar",
            "datatype": "json",
            "description": "Key observational parameters (e.g. surface brightness profiles, rotation curves)."
          },
          {
            "name": "measurement_uncertainty",
            "type": "scalar",
            "datatype": "float",
            "description": "Uncertainty estimates for the measurements."
          },
          {
            "name": "data_quality_flag",
            "type": "scalar",
            "datatype": "string",
            "description": "Quality indicator for the dataset (e.g. 'good', 'noisy')."
          },
          {
            "name": "collection_date",
            "type": "scalar",
            "datatype": "datetime",
            "description": "Date when the data was collected."
          },
          {
            "name": "associated_references",
            "type": "lookup",
            "target_entity": "Papers",
            "description": "References supporting the dataset if relevant."
          }
        ]
      },
      {
        "name": "TheoreticalExperiment",
        "description": "Entity for logging simulation runs and theoretical experiments, capturing input parameters and resulting inferences.",
        "fields": [
          {
            "name": "experiment_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the simulation experiment."
          },
          {
            "name": "description",
            "type": "scalar",
            "datatype": "string",
            "description": "Brief description of the experiment."
          },
          {
            "name": "parameter_set",
            "type": "scalar",
            "datatype": "json",
            "description": "The input parameters used in the simulation (e.g., luminosity_profile_factor, rotation_curve_correction)."
          },
          {
            "name": "simulation_results",
            "type": "scalar",
            "datatype": "json",
            "description": "Results from the simulation run (e.g., updated DM_particle_mass_estimate, residual_mass_fraction)."
          },
          {
            "name": "timestamp",
            "type": "scalar",
            "datatype": "datetime",
            "description": "Timestamp of the experiment run."
          },
          {
            "name": "associated_references",
            "type": "lookup",
            "target_entity": "Papers",
            "description": "Links to supporting theoretical or observational references."
          }
        ]
      },
      {
        "name": "HaloSubstructure",
        "description": "Entity capturing local density fluctuations and subhalo mass distributions within dark matter halos (alternative name to HaloSubstructureRecord).",
        "fields": [
          {
            "name": "subhalo_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the subhalo."
          },
          {
            "name": "subhalo_mass_distribution",
            "type": "scalar",
            "datatype": "json",
            "description": "Distribution of mass within the subhalo."
          },
          {
            "name": "concentration_parameter",
            "type": "scalar",
            "datatype": "float",
            "description": "Parameter indicating halo concentration."
          },
          {
            "name": "local_density_variation",
            "type": "scalar",
            "datatype": "float",
            "description": "Variation in local dark matter density."
          },
          {
            "name": "subhalo_mass_function",
            "type": "lambda",
            "parameters": [],
            "formula": "ComputePowerLawDistribution(parameters)",
            "description": "Lambda function to compute the mass function following a power-law with cutoff."
          },
          {
            "name": "linked_to",
            "type": "lookup",
            "target_entity": "DarkMatterInference",
            "description": "Links this substructure to the relevant dark matter inference record, if desired."
          }
        ]
      },
      {
        "name": "BaryonicFeedback",
        "description": "Entity capturing the effects of baryonic processes (e.g. star formation, AGN feedback) on mass distribution (alternative name to BaryonicFeedbackRecord).",
        "fields": [
          {
            "name": "feedback_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the feedback event."
          },
          {
            "name": "feedback_intensity",
            "type": "scalar",
            "datatype": "float",
            "description": "Measure of feedback strength."
          },
          {
            "name": "energy_injection_rate",
            "type": "scalar",
            "datatype": "float",
            "description": "Rate at which energy is injected into the surrounding medium."
          },
          {
            "name": "mass_loss_fraction",
            "type": "scalar",
            "datatype": "float",
            "description": "Fraction of mass lost due to feedback processes."
          },
          {
            "name": "feedback_adjustment_factor",
            "type": "lambda",
            "parameters": [],
            "formula": "ComputeFeedbackAdjustment(feedback_intensity, mass_loss_fraction)",
            "description": "Factor used to adjust observed mass estimates based on feedback."
          },
          {
            "name": "linked_region",
            "type": "lookup",
            "target_entity": "ClassicalSystemRecord",
            "description": "Reference to the system or region affected by baryonic feedback."
          }
        ]
      },
      {
        "name": "CosmicEvolution",
        "description": "Entity representing the evolution of dark matter properties over cosmic time (alternative name to CosmicEvolutionRecord).",
        "fields": [
          {
            "name": "evolution_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the cosmic evolution record."
          },
          {
            "name": "redshift",
            "type": "scalar",
            "datatype": "float",
            "description": "Redshift value indicating cosmic epoch."
          },
          {
            "name": "cosmic_time",
            "type": "scalar",
            "datatype": "float",
            "description": "Cosmic time in Gyr or another appropriate unit."
          },
          {
            "name": "evolution_modifier",
            "type": "lambda",
            "parameters": [],
            "formula": "ComputeEvolutionModifier(redshift, cosmic_time)",
            "description": "Modifier that adjusts dark matter inferences based on cosmic evolution parameters."
          },
          {
            "name": "associated_datasets",
            "type": "lookup",
            "target_entity": "ObservationalDataset",
            "description": "Links to datasets that provide evolutionary observational data for this cosmic epoch."
          }
        ]
      },
      {
        "name": "EnvironmentalInfluence",
        "description": "Entity capturing local environmental effects such as density, tidal interactions, or merger history, referencing a region or system (alternative name).",
        "fields": [
          {
            "name": "environment_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for the environmental influence record."
          },
          {
            "name": "local_density",
            "type": "scalar",
            "datatype": "float",
            "description": "Local density measure in the region."
          },
          {
            "name": "tidal_effects",
            "type": "scalar",
            "datatype": "float",
            "description": "Numeric index representing tidal forces."
          },
          {
            "name": "merger_history",
            "type": "scalar",
            "datatype": "json",
            "description": "Historical record of recent mergers or interactions."
          },
          {
            "name": "influence_modifier",
            "type": "lambda",
            "parameters": [],
            "formula": "ComputeInfluenceModifier(local_density, tidal_effects, merger_history)",
            "description": "Modifier that adjusts dark matter or baryonic inferences based on environmental factors."
          },
          {
            "name": "linked_region",
            "type": "lookup",
            "target_entity": "ClassicalSystemRecord",
            "description": "Reference to the system or halo impacted by these environmental factors."
          }
        ],
        "lookups": [],
        "aggregations": [],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "CosmologyCurvatureRecord",
        "description": "Captures curvature parameters (Ω values) and derived geometry classification for the universe. These do not overlap with existing v2 fields.",
        "fields": [
          {
            "name": "curvature_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique identifier for this curvature record."
          },
          {
            "name": "omega_mass",
            "type": "scalar",
            "datatype": "float",
            "description": "Ω_mass (matter density fraction) from observational data."
          },
          {
            "name": "omega_relativistic",
            "type": "scalar",
            "datatype": "float",
            "description": "Ω_relativistic for photons/neutrinos if measured."
          },
          {
            "name": "omega_lambda",
            "type": "scalar",
            "datatype": "float",
            "description": "Dark energy or cosmological-constant fraction, Ω_Λ."
          },
          {
            "name": "omega_total",
            "type": "scalar",
            "datatype": "float",
            "description": "Sum of mass, relativistic, and dark-energy densities. Observationally near 1.0."
          },
          {
            "name": "omega_k",
            "type": "scalar",
            "datatype": "float",
            "description": "Curvature density parameter, 1 - Ω_total. Positive => negative curvature, negative => positive curvature."
          },
          {
            "name": "curvature_classification",
            "type": "scalar",
            "datatype": "enum",
            "enum_values": [
              "positive",
              "flat",
              "negative",
              "unknown"
            ],
            "description": "Derived label: 'flat' if |omega_total-1| < epsilon, else 'positive' or 'negative'."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "check_flatness",
            "type": "rollup",
            "formula": "IF(ABS(omega_total - 1) <= 0.01, 'NearlyFlat', 'Curved')",
            "description": "Simple aggregator that flags if universe is nearly flat or curved based on threshold."
          }
        ],
        "lambdas": [
          {
            "name": "update_curvature_classification",
            "parameters": [],
            "formula": "IF(ABS(omega_total - 1) < 1e-3, 'flat', IF(omega_total > 1, 'positive','negative'))",
            "description": "Dynamically set curvature_classification according to sum of densities."
          }
        ]
      },
      {
        "name": "GlobalTopologyRecord",
        "description": "Represents global shape/topology hypotheses: finite vs infinite, multiply/simply connected, etc.",
        "fields": [
          {
            "name": "topology_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique record ID for global universe topology hypothesis."
          },
          {
            "name": "finite_or_infinite",
            "type": "scalar",
            "datatype": "enum",
            "enum_values": [
              "finite",
              "infinite",
              "unknown"
            ],
            "description": "Is space bounded or unbounded? Possibly 'unknown' if not concluded by data."
          },
          {
            "name": "edge_or_boundary_flag",
            "type": "scalar",
            "datatype": "boolean",
            "description": "If 'true', the model posits an 'edge' or boundary; if false or null, it's edge-free."
          },
          {
            "name": "manifold_family",
            "type": "scalar",
            "datatype": "enum",
            "enum_values": [
              "simply_connected",
              "multiply_connected",
              "3_sphere",
              "3_torus",
              "poincare_dodecahedral",
              "hyperbolic_variant",
              "unspecified"
            ],
            "description": "Labels the commonly cited manifold type. 'unspecified' if not pinned down."
          },
          {
            "name": "notes",
            "type": "scalar",
            "datatype": "string",
            "description": "Optional extra text or references (like WMAP constraints, etc.)."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "implied_volume",
            "type": "rollup",
            "formula": "IF(finite_or_infinite='finite', 'computable or closed', 'no well-defined finite volume')",
            "description": "Simple aggregator that flags if volume is definable or not, based on finite/infinite enum."
          }
        ],
        "lambdas": [
          {
            "name": "describe_edge_scenario",
            "parameters": [],
            "formula": "IF(edge_or_boundary_flag=true, 'Universe has boundary—difficult to interpret physically', 'No boundary (closed manifold or infinite)')"
          }
        ]
      },
      {
        "name": "CosmologyMeasurementRecord",
        "description": "Logs observational data sets (e.g. WMAP, Planck, BOOMERanG) referencing their curvature or topology findings, or constraints on them.",
        "fields": [
          {
            "name": "measurement_id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for this measurement or dataset reference."
          },
          {
            "name": "mission_name",
            "type": "scalar",
            "datatype": "string",
            "description": "e.g. 'WMAP', 'Planck', 'BOOMERanG', etc."
          },
          {
            "name": "omega_values_reported",
            "type": "scalar",
            "datatype": "json",
            "description": "A JSON map {Omega_m:..., Omega_Lambda:..., Omega_total:...} from that mission's data release."
          },
          {
            "name": "angular_scale_or_method",
            "type": "scalar",
            "datatype": "string",
            "description": "Which method was used to measure curvature (e.g. CMB anisotropy, Baryon Acoustic Oscillations...)."
          },
          {
            "name": "quoted_error_margin",
            "type": "scalar",
            "datatype": "float",
            "description": "Reported margin of error for curvature or Omega. e.g. ±0.02"
          },
          {
            "name": "date_of_release",
            "type": "scalar",
            "datatype": "datetime",
            "description": "Timestamp or year of publication (like 2018 Planck release)."
          }
        ],
        "lookups": [
          {
            "name": "inferred_curvature_link",
            "type": "lookup",
            "target_entity": "CosmologyCurvatureRecord",
            "description": "Optionally links this measurement’s derived curvature to a stored CosmologyCurvatureRecord row."
          },
          {
            "name": "inferred_topology_link",
            "type": "lookup",
            "target_entity": "GlobalTopologyRecord",
            "description": "If the measurement concluded or placed constraints on a certain topology, link it here."
          }
        ],
        "aggregations": [
          {
            "name": "coarse_curvature_label",
            "type": "rollup",
            "formula": "IF(ABS(omega_values_reported.Omega_total - 1) < quoted_error_margin, 'FlatWithinError', 'PossiblyCurved')"
          }
        ],
        "lambdas": []
      }
    ]
  },
  "data": {
    "PhysicalConstants": [
      {
        "id": "planck_h",
        "symbol": "h",
        "value": 6.62607015e-34,
        "units": "J*s",
        "uncertainty": 0,
        "notes": "Planck's constant"
      },
      {
        "id": "reduced_planck_hbar",
        "symbol": "ħ",
        "value": 1.054571817e-34,
        "units": "J*s",
        "uncertainty": 0,
        "notes": "Reduced Planck's constant"
      },
      {
        "id": "speed_of_light",
        "symbol": "c",
        "value": 199792458,
        "units": "m/s",
        "uncertainty": 0,
        "notes": "Exact by definition"
      },
      {
        "id": "grav_const_g",
        "symbol": "G",
        "value": 6.6743e-11,
        "units": "m^3/(kg*s^2)",
        "uncertainty": 1.5e-15,
        "notes": "Newton's constant"
      },
      {
        "id": "boltzmann_kb",
        "symbol": "k_B",
        "value": 1.380649e-23,
        "units": "J/K",
        "uncertainty": 0,
        "notes": "Boltzmann's constant"
      }
    ],
    "ReferenceFrame": [
      {
        "id": "lab_frame",
        "name": "Lab Frame",
        "dimensions": 3,
        "spatial_coordinates_model": "Cartesian",
        "time_coordinate_label": "t",
        "notes": "Non-relativistic approx"
      },
      {
        "id": "minkowski_frame",
        "name": "Minkowski Frame",
        "dimensions": 4,
        "spatial_coordinates_model": "Cartesian",
        "time_coordinate_label": "t",
        "notes": "SR usage"
      },
      {
        "id": "cylindrical_frame",
        "name": "Cylindrical Frame",
        "dimensions": 3,
        "spatial_coordinates_model": "Cylindrical",
        "time_coordinate_label": "t",
        "notes": "Cylindrical coordinates (r, phi, z)"
      }
    ],
    "Potential": [
      {
        "id": "harmonic_potential_1d",
        "potential_name": "1D Harmonic Oscillator",
        "functional_form": {
          "expression": "V(x)=0.5*k*x^2",
          "k": 5
        },
        "equation_id": null,
        "reference_frame_id": "lab_frame",
        "notes": "Simple 1D HO"
      },
      {
        "id": "gravitational_well",
        "potential_name": "Inverse Square Gravity",
        "functional_form": {
          "expression": "V(r)=-G*M*m/r",
          "M": 5.97e+24
        },
        "equation_id": null,
        "reference_frame_id": "lab_frame",
        "notes": "Earth-like gravity"
      },
      {
        "id": "morse_potential",
        "potential_name": "Morse Potential",
        "functional_form": {
          "expression": "D_e [1 - exp(-a(r - r_e))]^2",
          "D_e": 0.1,
          "a": 1.5,
          "r_e": 0.9
        },
        "equation_id": null,
        "reference_frame_id": "lab_frame",
        "notes": "Used for diatomic molecular vibrations"
      }
    ],
    "Hamiltonian": [
      {
        "id": "harmonic_oscillator_H",
        "description": "Quantum 1D HO Hamiltonian",
        "kinetic_term": {
          "expression": "p^2/(2*m)"
        },
        "kinetic_equation_id": null,
        "potential_id": "harmonic_potential_1d",
        "domain_type": "quantum_operator"
      },
      {
        "id": "classical_gravity_H",
        "description": "Classical gravity Hamiltonian",
        "kinetic_term": {
          "expression": "p^2/(2*m)"
        },
        "kinetic_equation_id": null,
        "potential_id": "gravitational_well",
        "domain_type": "classical_H"
      },
      {
        "id": "morse_hamiltonian",
        "description": "Quantum Morse oscillator",
        "kinetic_term": {
          "expression": "p^2/(2*m)"
        },
        "kinetic_equation_id": null,
        "potential_id": "morse_potential",
        "domain_type": "quantum"
      }
    ],
    "Wavefunction": [
      {
        "id": "psi_electron_1d",
        "wavefunction_label": "Electron in 1D HO",
        "system_description": "Single electron, 1D harmonic oscillator",
        "dimensionality": 1,
        "num_particles": 1,
        "spin_states": {
          "spin_total": 0.5
        },
        "wavefunction_symmetry": null,
        "wavefunction_data": {
          "grid_points": [
            {
              "x": -1,
              "psi_re": 0.1,
              "psi_im": 0
            },
            {
              "x": -0.5,
              "psi_re": 0.4,
              "psi_im": 0
            },
            {
              "x": 0,
              "psi_re": 0.7,
              "psi_im": 0
            },
            {
              "x": 0.5,
              "psi_re": 0.4,
              "psi_im": 0
            },
            {
              "x": 1,
              "psi_re": 0.1,
              "psi_im": 0
            }
          ]
        },
        "amplitude_algebraic_structure_id": null,
        "reference_frame_id": "lab_frame",
        "notes": "Previously had probability_sum ~0.81. Now computed by aggregator 'probability_sum'."
      },
      {
        "id": "psi_two_electrons",
        "wavefunction_label": "2-electron entangled",
        "system_description": "Two electrons in 1D, spin singlet",
        "dimensionality": 2,
        "num_particles": 2,
        "spin_states": {
          "particle1_spin": 0.5,
          "particle2_spin": 0.5,
          "configuration": "singlet"
        },
        "wavefunction_symmetry": null,
        "wavefunction_data": {
          "grid_points": [
            {
              "x1": -1,
              "x2": -1,
              "psi_re": 0,
              "psi_im": 0
            },
            {
              "x1": -1,
              "x2": -0.5,
              "psi_re": 0.02,
              "psi_im": 0.01
            },
            {
              "x1": -0.5,
              "x2": -0.5,
              "psi_re": 0.05,
              "psi_im": -0.02
            },
            {
              "x1": 0,
              "x2": 0,
              "psi_re": 0.1,
              "psi_im": 0
            },
            {
              "x1": 0.5,
              "x2": 0.5,
              "psi_re": 0.02,
              "psi_im": 0.01
            }
          ]
        },
        "amplitude_algebraic_structure_id": null,
        "reference_frame_id": "lab_frame",
        "notes": "Spin singlet. Probability sum aggregator should be ~1.0"
      },
      {
        "id": "psi_spin1_boson",
        "wavefunction_label": "Spin-1 Boson in 1D",
        "system_description": "Single massive boson, spin=1, 1D domain",
        "dimensionality": 1,
        "num_particles": 1,
        "spin_states": {
          "spin_total": 1
        },
        "wavefunction_symmetry": "symmetric",
        "wavefunction_data": {
          "grid_points": [
            {
              "x": -2,
              "psi_re": 0,
              "psi_im": 0
            },
            {
              "x": -1,
              "psi_re": 0.25,
              "psi_im": 0
            },
            {
              "x": 0,
              "psi_re": 0.5,
              "psi_im": 0
            },
            {
              "x": 1,
              "psi_re": 0.25,
              "psi_im": 0
            },
            {
              "x": 2,
              "psi_re": 0,
              "psi_im": 0
            }
          ]
        },
        "amplitude_algebraic_structure_id": null,
        "reference_frame_id": "lab_frame",
        "notes": "Example for integer spin wavefunction => symmetric by spin-statistics constraint"
      }
    ],
    "Particle": [
      {
        "id": "electron_1",
        "label": "Electron (HO)",
        "mass": 9.109e-31,
        "charge": -1.602e-19,
        "spin": 0.5,
        "single_particle_wf_id": "psi_electron_1d",
        "classical_position": null,
        "classical_velocity": null,
        "reference_frame_id": "lab_frame",
        "characteristic_size": 1e-10,
        "notes": "Single-particle wavefunction in HO"
      },
      {
        "id": "cannonball_1",
        "label": "Cannonball",
        "mass": 5,
        "charge": 0,
        "spin": 0,
        "single_particle_wf_id": null,
        "classical_position": [
          0,
          1,
          0
        ],
        "classical_velocity": [
          10,
          0,
          0
        ],
        "reference_frame_id": "lab_frame",
        "characteristic_size": 0.2,
        "notes": "Macroscopic object (classical only)"
      },
      {
        "id": "electron_a",
        "label": "Electron A",
        "mass": 9.109e-31,
        "charge": -1.602e-19,
        "spin": 0.5,
        "single_particle_wf_id": null,
        "classical_position": null,
        "classical_velocity": null,
        "reference_frame_id": "lab_frame",
        "characteristic_size": 1e-10,
        "notes": "Part of 2-electron wavefunction"
      },
      {
        "id": "electron_b",
        "label": "Electron B",
        "mass": 9.109e-31,
        "charge": -1.602e-19,
        "spin": 0.5,
        "single_particle_wf_id": null,
        "classical_position": null,
        "classical_velocity": null,
        "reference_frame_id": "lab_frame",
        "characteristic_size": 1e-10,
        "notes": "Part of 2-electron wavefunction"
      },
      {
        "id": "photon_1",
        "label": "Single Photon",
        "mass": 0,
        "charge": 0,
        "spin": 1,
        "single_particle_wf_id": null,
        "classical_position": null,
        "classical_velocity": null,
        "reference_frame_id": "minkowski_frame",
        "characteristic_size": 1e-12,
        "notes": "Massless spin-1 particle"
      },
      {
        "id": "massive_body_A",
        "label": "Central Star",
        "mass": 1.989e+30,
        "charge": 0,
        "spin": 0,
        "single_particle_wf_id": null,
        "classical_position": [
          0,
          0,
          0
        ],
        "classical_velocity": [
          0,
          0,
          0
        ],
        "classical_system_id": "two_body_system",
        "reference_frame_id": "lab_frame",
        "characteristic_size": 696000000,
        "notes": "Large mass star"
      },
      {
        "id": "orbiting_body_B",
        "label": "Planet",
        "mass": 5.972e+24,
        "charge": 0,
        "spin": 0,
        "single_particle_wf_id": null,
        "classical_position": [
          149600000000,
          0,
          0
        ],
        "classical_velocity": [
          0,
          30000,
          0
        ],
        "classical_system_id": "two_body_system",
        "reference_frame_id": "lab_frame",
        "characteristic_size": 6370000,
        "notes": "Smaller orbiting body"
      }
    ],
    "ParticleWavefunctionMapping": [
      {
        "id": "map_eA_psiTwo",
        "particle_id": "electron_a",
        "wavefunction_id": "psi_two_electrons",
        "role_label": "Electron A"
      },
      {
        "id": "map_eB_psiTwo",
        "particle_id": "electron_b",
        "wavefunction_id": "psi_two_electrons",
        "role_label": "Electron B"
      }
    ],
    "DensityMatrix": [
      {
        "id": "rho_2e_full",
        "system_description": "Full 2e entangled state",
        "matrix_data": {
          "10": {
            "re": 0,
            "im": -0.1
          },
          "11": {
            "re": 0.3,
            "im": 0
          },
          "00": {
            "re": 0.7,
            "im": 0
          },
          "01": {
            "re": 0,
            "im": 0.1
          }
        },
        "reference_wavefunction_id": "psi_two_electrons",
        "notes": "trace_rho and von_neumann_entropy now come from aggregations, not stored here."
      },
      {
        "id": "rho_eA_partial",
        "system_description": "Partial trace over electron B",
        "matrix_data": {
          "0": {
            "0": {
              "re": 0.8,
              "im": 0
            }
          },
          "1": {
            "1": {
              "re": 0.2,
              "im": 0
            }
          }
        },
        "reference_wavefunction_id": "psi_two_electrons",
        "notes": "Same idea; aggregator fields give trace=1 etc."
      },
      {
        "id": "rho_mixed_2level",
        "system_description": "Mixed 2-level system with classical probability",
        "matrix_data": {
          "10": {
            "re": 0,
            "im": 0
          },
          "11": {
            "re": 0.4,
            "im": 0
          },
          "00": {
            "re": 0.6,
            "im": 0
          },
          "01": {
            "re": 0,
            "im": 0
          }
        },
        "reference_wavefunction_id": null,
        "notes": "Purely classical mixture of two states"
      }
    ],
    "Force": [
      {
        "id": "grav_force_cannon",
        "force_type": "gravitational",
        "particle_id": "cannonball_1",
        "force_vector": [
          0,
          -49,
          0
        ],
        "notes": "Approx mg downward"
      }
    ],
    "GaugeField": [
      {
        "id": "em_field_lab",
        "gauge_type": "U(1)",
        "gauge_group_id": null,
        "field_components": {
          "E": [
            100,
            0,
            0
          ],
          "B": [
            0,
            0,
            0
          ]
        },
        "reference_frame_id": "lab_frame",
        "notes": "Uniform E in +x direction"
      },
      {
        "id": "nonabelian_field_su2",
        "gauge_type": "SU(2)",
        "gauge_group_id": null,
        "field_components": {
          "A_mu": [
            {
              "component": 0,
              "matrix": [
                [
                  0,
                  0.1
                ],
                [
                  0.1,
                  0
                ]
              ]
            },
            {
              "component": 1,
              "matrix": [
                [
                  0,
                  0
                ],
                [
                  0,
                  0
                ]
              ]
            },
            {
              "component": 2,
              "matrix": [
                [
                  0.2,
                  0
                ],
                [
                  0,
                  -0.2
                ]
              ]
            },
            {
              "component": 3,
              "matrix": [
                [
                  0,
                  0
                ],
                [
                  0,
                  0
                ]
              ]
            }
          ]
        },
        "reference_frame_id": "minkowski_frame",
        "notes": "A toy non-Abelian gauge field example"
      }
    ],
    "MeasurementEvent": [
      {
        "id": "meas_1",
        "time_of_measurement": "2025-02-09T12:00:00Z",
        "wavefunction_id": "psi_electron_1d",
        "particle_id": "electron_1",
        "operator_description": "Position near x=0.0",
        "possible_outcomes": null,
        "outcome": "Detected at x=0.1",
        "new_wavefunction_id": null,
        "notes": "Collapsed wavefunction near x=0.1"
      },
      {
        "id": "meas_2_slits",
        "time_of_measurement": "2025-02-09T12:10:00Z",
        "wavefunction_id": "psi_two_electrons",
        "particle_id": null,
        "operator_description": "Which slit? SlitA or SlitB",
        "possible_outcomes": [
          "SlitA",
          "SlitB"
        ],
        "outcome": null,
        "new_wavefunction_id": null,
        "notes": "Multiway scenario"
      },
      {
        "id": "meas_boson_spin",
        "time_of_measurement": "2025-02-09T12:30:00Z",
        "wavefunction_id": "psi_spin1_boson",
        "particle_id": null,
        "measurement_operator": {
          "type": "Spin_z",
          "matrix_size": 3
        },
        "possible_outcomes": [
          "m_s = -1",
          "m_s = 0",
          "m_s = +1"
        ],
        "outcome_distribution": {
          "0": 0.6,
          "-1": 0.2,
          "+1": 0.2
        },
        "outcome": null,
        "new_wavefunction_id": null,
        "notes": "Demonstrates multi-level spin measurement"
      }
    ],
    "ClassicalSystem": [
      {
        "id": "cannon_system",
        "system_name": "Just the Cannonball",
        "notes": "Single-particle system"
      },
      {
        "id": "two_body_system",
        "system_name": "Two-Body Orbital System",
        "notes": "Earth-sun type minimal example"
      }
    ],
    "SpacetimeMetric": [
      {
        "id": "flat_minkowski_lab",
        "metric_tensor": [
          [
            1,
            0,
            0,
            0
          ],
          [
            0,
            -1,
            0,
            0
          ],
          [
            0,
            0,
            -1,
            0
          ],
          [
            0,
            0,
            0,
            -1
          ]
        ],
        "reference_frame_id": "minkowski_frame",
        "notes": "Standard flat metric"
      }
    ],
    "BlackHoleSystem": [
      {
        "id": "bh_example_1",
        "bh_label": "10-solar-mass BH (toy)",
        "approx_mass": 2e+31,
        "notes": "schwarzschild_radius, hawking_temperature now aggregator/lambda-based"
      },
      {
        "id": "bh_mid_mass",
        "bh_label": "Intermediate BH ~1000 solar masses",
        "approx_mass": 2e+33,
        "notes": "Check aggregator outputs for radius, temperature, etc."
      }
    ]
  }
},
        "root-meta-model": {
  "title": "The Conceptual Model Completeness Conjecture (CMCC)",
  "subtitle": "A Universal Declarative Computational Framework",
  "authors": [
    {
      "name": "EJ Alexandra",
      "contact": "start@anabstractlevel.com",
      "affiliations": [
        "SSoT.me",
        "EffortlessAPI.com"
      ]
    }
  ],
  "date": "January 2025",
  "abstract": "The Conceptual Model Completeness Conjecture (CMCC) posits that the declarative semantics of any conceptual model can be captured using five fundamental primitives—Schema (S), Data (D), Lookups (L), Aggregations (A), and Lambda Calculated Fields (F)—within an Snapshot-Consistent environment. Demonstrating Turing-completeness and aligning with Wolfram’s multiway systems, CMCC provides a universal substrate for modeling domains ranging from physics and biology to business rules and beyond. This paper formalizes CMCC’s theoretical foundations, presents diverse cross-domain examples, and outlines future directions for building a unified computational framework.",
  "executive_summary": {
    "key_points": [
      "CMCC proposes that five primitives (S, D, L, A, F) suffice to model all computable domain rules.",
      "It achieves Turing-completeness by mapping to Lambda Calculus and Rule 110.",
      "Aligns structurally with Wolfram’s multiway systems (the Ruliad).",
      "Demonstrates broad applicability in Physics, Chemistry, Biology, Math, etc.",
      "A purely declarative approach: 'what' is separate from 'how' (the runtime)."
    ],
    "implications": [
      "Potential unification of domain modeling under a single declarative rulebook.",
      "Scalable approach to cross-domain data management and knowledge representation.",
      "Opens possibilities for AI, simulation, and multiway branching analyses."
    ],
    "narrative": {
      "sections": [
        {
          "title": "Executive Summary",
          "content": [
            "In many domains, describing “what” we want—a mathematical theorem, a business rule, a policy—involves flattening concepts into the syntax of English or code. While convenient for initial discussion, this syntax-locked approach forces us to repeatedly translate ideas between human language and machine processes. As complexity grows, these translations invite drift, ambiguity, and inefficiency."
          ]
        },
        {
          "title": "Starting with an English Theorem",
          "content": [
            "Consider a simple example: the rules that define a “triangle.” In English, we might say:",
            "A triangle is a closed shape with exactly three edges; its internal angles sum to 180°.",
            "This is serviceable for teaching geometry, but it’s not inherently machine-actionable. If someone doesn’t speak English—or if we want to automate checks for “triangleness”—we must rewrite these rules in each environment (programming languages, software specifications, test scripts, etc.). The overhead compounds quickly."
          ]
        },
        {
          "title": "Describing Triangleness in Airtable",
          "content": [
            "In contrast, we can directly capture the rules of geometry in a structural model within a tool like Airtable (or any Snapshot-Consistent environment with fields, lookups, rollups, and formulas). Instead of restating the concept in English each time, we:",
            "• Create tables for Edges and Shapes.",
            "• Use Lookups to link three edges to a shape.",
            "• Add Aggregations to sum angles or count edges.",
            "• Define Formulas to verify that exactly three edges exist, and that the total internal angle equals 180°.",
            "In this configuration, the entire notion of “triangleness” exists as data and relationships, not locked into a single linguistic syntax. Anyone—regardless of spoken language—can inspect or extend the model to handle right triangles, acute triangles, or more advanced geometric constructions. The system remains accessible, self-describing, and effortlessly scalable."
          ]
        },
        {
          "title": "From Triangleness to CMCC",
          "content": [
            "This leads to the Complete Model of Conceptual Completeness (CMCC) theorem: it posits that any conceptual rule (including the rules for “triangleness”) can be encoded using five core primitives—(S, D, L, A, F)—in an Snapshot-Consistent datastore. In essence:",
            "• Schema for defining categories of things,",
            "• Data rows populating those categories,",
            "• Lookups that link records into relationships,",
            "• Aggregations that summarize or roll up data, and",
            "• Formulas for declarative calculations or constraints.",
            "The rulebook (the “what” of a concept) is stored unambiguously in these five primitives, separate from the “how” of any given runtime engine. Because it is a universal structural approach—not tied to a single programming language or specialized DSL—CMCC becomes a syntax-free mirror of the underlying concept. It applies equally to geometry, biology, legal rules, quantum theories, or inventory systems. In short, if a rule can be stated in any imperative language (or in English), it can be modeled structurally under CMCC without loss of fidelity."
          ]
        },
        {
          "title": "Why This Matters",
          "content": [
            "By decoupling the “what” from specific syntax, teams eliminate the repeated translation tasks that plague large projects. Modeling “triangleness” is trivial in Airtable; modeling advanced governance or physics follows the same structural pattern. CMCC solidifies the principle that once we master a small example (like a triangle), we unlock the ability to describe any computable concept. This puts an end to the question, “But will it work for my domain?”: the moment we acknowledge that geometry itself can be captured in a purely structural format, all similarly computable rules become fair game.",
            "In sum, we move from a short English description of a concept, to a self-describing Airtable model, culminating in the CMCC theorem that guarantees we can handle any conceptual domain the same way. This progression ensures that readers—technical or otherwise—understand why syntax-free, declarative modeling is both feasible and transformative. Once you see it work with triangles, you can’t unsee its potential everywhere else."
          ]
        }
      ]
    },
    "addressing_concerns_preemptively": {
      "what_not_how": "It's just a list of statements about WHAT is true at any given moment in time.  If there are a list of 100 true statements, and you add another statement - you will either now have 101 true statements, or the inferences of 1 or more of the previous statements will conflict, pointing to a problem with the conceptual model, rather than the description.  By just listing true things about WHAT is needed, it leaves the question of HOW to make that true up to the runtime engine.",
      "time": "Time is just another dimension.",
      "rulebook_not_the_runtime": "Like a blueprint, or sheet music, the CMCC model is just the rulebook, not the runtime engine.  The runtime engine could be an existing digital twin of some reality that is simply Fed by the CMCC.  In other words, the CMCC model can represent WHAT needs to happen at virtually any level of desired functionality - as a result it can export DSLs, RDF, OWL, Sparql, GraphQL, etc. making the CMCC model a superset of legacy, language based, syntax-locked formats.",
      "scaleability_performance": "As just the rulebook, the implementation can be assembler code written by magical mice in the night if that's the best solution.  But whatever they produce had better pass **all** of the tests derived directly from the CMCC model itself.  As long as it does WHAT it is meant to, how it does it is up to the runtime engine.  If that digital twin involves petabytes of raw data, coming in a gb per second - that's going to be a monumental engineering task.  But whatever the solution at runtime, it just needs to do WHAT is required.",
      "reality_is_the_best_runtime_engine": "Ultimately, for physics for example, reality is the runtime engine.  This just provides the model to understand WHAT is happening at runtime.  Using Airtable to define business rules works for all but the most extreme concepts, but all it defines is exactly WHAT needs to be done.  HOW Airtable works might as well be magic.  I have absolutely no idea HOW it works, but that doesn't really matter since that's not its role in this process.  Its role is to define a high-fidelity, hyper-dimensional model that DEFINES Truth.  On the other end of the spectrum we have Reality Itself, which might as well also be magical, at least at the quantum fringes.  Here again—our models don't describe HOW the wave collapses, but WHAT a wave collapse is.  Or WHAT a Customer is, and WHAT makes them a VIP customer—not how we compute if they are a VIP in some AWS server.  VIP customers are still going to be anyone with over $1000 of sales—that is the part that's invariant.",
      "bright_red_lines": "Separating out WHAT is true from HOW to make it true at runtime draws a BRIGHT RED LINE about what KIND of change is being made.  Additionally, the types of changes that can be made to the model are also separated into two radically different types by another BRIGHT RED LINE.  The first type of change is one where the domain is simply being extended.  In these cases, the CI/CD pipeline will pick up those changes and they will simply be deployed to the dev/test environment.  By contrast, if the domain itself is changed, because changing the schema or rules for a domain is a fundamentally different CATEGORY of change than simply adding another widget to the tens of thousands of widgets that are already in the datastore."
    }
  },
  "CMCC_ToEMM_Domain_List": [
    {
      "id": "CMCC_ToEMM_Math",
      "fullname": "Mathematics ToE Meta-Model",
      "name": "Mathematics CMCC Meta-Model",
      "description": "A structured model covering foundational mathematics, including sets, functions, proofs, structures, and category theory.",
      "nickname": "math"
    },
    {
      "id": "CMCC_ToEMM_Physics",
      "fullname": "Physics ToE Meta-Model",
      "name": "Physics ToE Meta-Model",
      "description": "A unified model for physics, including classical mechanics, quantum mechanics, gauge fields, wavefunctions, relativity, and black hole dynamics.",
      "nickname": "physics"
    },
    {
      "id": "CMCC_ToEMM_Chemistry",
      "fullname": "Chemistry ToE Meta-Model",
      "name": "Chemistry ToE Meta-Model",
      "description": "Extends the Physics TOE with atomic structures, molecular interactions, bonds, and chemical reactions.",
      "nickname": "chemistry"
    },
    {
      "id": "CMCC_ToEMM_Biology",
      "fullname": "Biology ToE Meta-Model",
      "name": "Biology ToE Meta-Model",
      "description": "Bridges Chemistry and Physics TOEs to model biological systems, including genes, proteins, metabolism, and cellular structures.",
      "nickname": "biology"
    },
    {
      "id": "CMCC_ToEMM_AI",
      "fullname": "Artificial Intelligence ToE Meta-Model",
      "name": "Artificial Intelligence ToE Meta-Model",
      "description": "Encapsulates machine learning, neural networks, training datasets, reinforcement learning, and inference mechanisms.",
      "nickname": "ai"
    },
    {
      "id": "CMCC_ToEMM_Economics",
      "fullname": "Economics ToE Meta-Model",
      "name": "Economics ToE Meta-Model",
      "description": "A computational model for economic agents, markets, transactions, and supply-demand constraints.",
      "nickname": "economics"
    },
    {
      "id": "CMCC_ToEMM_Astronomy",
      "fullname": "Astronomy ToE Meta-Model",
      "name": "Astronomy ToE Meta-Model",
      "description": "An extension of the Physics TOE to model celestial bodies, star systems, orbital dynamics, and large-scale cosmic structures.",
      "nickname": "astronomy"
    },
    {
      "id": "CMCC_ToEMM_Geology",
      "fullname": "Geology oE Meta-Model",
      "name": "Geology",
      "description": "A model integrating physics and chemistry to represent minerals, rock formations, and tectonic processes.",
      "nickname": "geology"
    },
    {
      "id": "CMCC_ToEMM_Medicine",
      "fullname": "Medicine and Healthcare ToE Meta-Model",
      "name": "Medicine & Healthcare ToE Meta-Model",
      "description": "A unified model capturing foundational aspects of medicine and healthcare, including patient records, clinical trial data, treatment plans, and healthcare analytics.",
      "nickname": "medicine"
    },
    {
      "id": "CMCC_ToEMM_Legal",
      "fullname": "Legal Systems & Compliance ToE Meta-Model",
      "name": "Legal Systems & Compliance ToE Meta-Model",
      "description": "A unified model for legal systems, contracts, statutory frameworks, and regulatory compliance.",
      "nickname": "legal"
    },
    {
      "id": "CMCC_ToEMM_Climate",
      "fullname": "Climate Science and Environmental Modeling ToE Meta-Model",
      "name": "Climate Science ToE Meta-Model",
      "description": "A unified model for climate science and environmental modeling, capturing climate variables, ecosystems, pollution sources, and environmental data with built-in predictive and forecast capabilities.",
      "nickname": "climate"
    },
    {
      "id": "CMCC_ToEMM_Cybersecurity",
      "fullname": "Cybersecurity ToE Meta-Model",
      "name": "Cybersecurity ToE Meta-Model",
      "description": "A unified model for cybersecurity covering threat models, vulnerabilities, IT asset mappings, incident logs, and security audits.",
      "nickname": "cybersecurity"
    },
    {
      "id": "CMCC_ToEMM_Sociology",
      "fullname": "Sociology and Anthropology ToE Meta-Model",
      "name": "Sociology & Anthropology ToE Meta-Model",
      "description": "A structured model capturing social structures, cultural norms, and interaction networks using survey data, demographic records, and social network relationships.",
      "nickname": "sociology"
    }
  ]
}

}