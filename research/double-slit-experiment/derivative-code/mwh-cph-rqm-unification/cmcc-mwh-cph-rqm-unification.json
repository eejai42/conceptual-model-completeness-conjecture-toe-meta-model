{
  "entities": [
    {
      "name": "QuantumState",
      "description": "Stores wavefunction or amplitude distribution for a quantum system. Common to all interpretations. Additionally for RQM, this may represent a global or partial wavefunction as used by different observers.",
      "fields": [
        {
          "name": "state_id",
          "type": "scalar",
          "datatype": "string",
          "primary_key": true
        },
        {
          "name": "description",
          "type": "scalar",
          "datatype": "string"
        },
        {
          "name": "amplitude_data",
          "type": "scalar",
          "datatype": "json",
          "description": "Complex amplitude array or param-based wavefunction representation."
        },
        {
          "name": "normalization",
          "type": "calculated",
          "formula": "SUM( ABS(amplitude_data)^2 )"
        },
        {
          "name": "interpretation_id",
          "type": "lookup",
          "target_entity": "InterpretationPolicy",
          "description": "Indicates how measurement events on this state are handled (Copenhagen, Many-Worlds, RQM)."
        },
        {
          "name": "coherence_time",
          "type": "scalar",
          "datatype": "float",
          "description": "Approx time (in some units) until decoherence occurs."
        },
        {
          "name": "dynamic_phase",
          "type": "scalar",
          "datatype": "float",
          "description": "Optional global phase in radians used for time-evolution or interference checks."
        },
        {
          "name": "entanglement_measure",
          "type": "rollup",
          "formula": "ComputeEntanglementEntropy(amplitude_data, subsystem_spec)",
          "description": "Calculates an entanglement entropy or related measure by partial tracing out a specified subsystem."
        },
        {
          "name": "decoherence_map",
          "type": "rollup",
          "formula": "AssessDecoherenceAcrossBranches(this.state_id)",
          "description": "Evaluates how orthogonal or non-interfering different branches of this wavefunction have become."
        },
        {
          "name": "subsystem_spec",
          "type": "scalar",
          "datatype": "json",
          "description": "Defines the subsystem partition (e.g., qubit indices) for entanglement calculations."
        }
      ],
      "lookups": [
        {
          "name": "branches",
          "description": "If Many-Worlds or partial branching is used, references multiple branch records for this wavefunction.",
          "target_entity": "BranchRecord",
          "type": "one_to_many",
          "join_condition": "BranchRecord.wavefunction_id = this.state_id"
        }
      ],
      "aggregations": [
        {
          "name": "branch_count",
          "type": "rollup",
          "formula": "COUNT(branches)"
        },
        {
          "name": "global_collapse_metric",
          "type": "rollup",
          "formula": "ComputeGlobalCollapseMetric(branch_count, branches)"
        },
        {
          "name": "time_evolution",
          "type": "rollup",
          "formula": "ApplyTimeEvolution(amplitude_data, dynamic_phase)"
        },
        {
          "name": "causal_branch_graph",
          "type": "rollup",
          "formula": "ConstructBranchCausalityGraph(branches)"
        },
        {
          "name": "macro_distinct_branches",
          "type": "rollup",
          "formula": "IdentifyMacroscopicBranches(decoherence_map, branches, some_threshold)"
        },
        {
          "name": "observer_relative_wavefunction",
          "type": "rollup",
          "formula": "ComputeObserverRelativeWavefunction(amplitude_data, parameters.observer_id)",
          "description": "Generates a partial or observer-specific wavefunction in RQM contexts, referencing the main amplitude data."
        },
        {
          "name": "entanglement_classification",
          "type": "rollup",
          "formula": "IF(entanglement_measure < 1e-6, 'Product state', 'Entangled')",
          "description": "A basic classification based on the entanglement measure. Adjust threshold or formula as needed."
        },
        {
          "name": "branch_probability_sum",
          "type": "rollup",
          "formula": "SUM(BranchRecord.prob_weight WHERE wavefunction_id = this.state_id)",
          "description": "Sums the probability weights across all branches for this wavefunction."
        },
        {
          "name": "global_probability_mismatch_flag",
          "type": "rollup",
          "formula": "IF( ABS(branch_probability_sum - 1) > 0.001, 'WARNING: total branch probability != 1', 'OK' )",
          "description": "Checks if the sum of branch probabilities deviates significantly from unity."
        },
        {
          "name": "bell_inequality_check",
          "type": "rollup",
          "formula": "ComputeCHSHCorrelators(this.state_id, MeasurementEvent.*)",
          "description": "Calculates CHSH correlations for measurements referencing this wavefunction."
        },
        {
          "name": "pointer_basis_candidates",
          "type": "rollup",
          "formula": "IdentifyPointerStates(decoherence_map, amplitude_data)",
          "description": "Identifies stable basis states that remain robust against decoherence."
        },
        {
          "name": "wigner_distribution",
          "type": "rollup",
          "formula": "ComputeWignerFunction(amplitude_data)",
          "description": "Generates a (quasi-)probability distribution in phase space."
        },
        {
          "name": "leggett_garg_inequality",
          "type": "rollup",
          "formula": "ComputeLeggettGargCorrelations(this.state_id, MeasurementEvent.*)",
          "description": "Checks if time-ordered measurements on this wavefunction violate the Leggett-Garg bound."
        },
        {
          "name": "chsh_local_check",
          "type": "rollup",
          "formula": "ComputeCHSHCorrelators(this.meas_id, wavefunction_id)"
        },
        {
          "name": "quantum_fisher_info",
          "type": "rollup",
          "formula": "ComputeQuantumFisherInformation(amplitude_data, hamiltonian_ref)"
        },
        {
          "name": "kochen_specker_contextuality_check",
          "type": "rollup",
          "formula": "ComputeContextualityViolations(this.state_id, MeasurementEvent.*)"
        },
        {
          "name": "ghz_mermin_violation_indicator",
          "type": "rollup",
          "formula": "ComputeGHZOrMerminInequalityViolations(this.state_id, MeasurementEvent.*)",
          "description": "Checks for multi-qubit GHZ or Mermin inequality violations using relevant measurement events referencing this wavefunction. Returns a numeric measure of violation or a boolean indicating whether a violation threshold is crossed."
        },
        {
          "name": "hardys_paradox_indicator",
          "type": "rollup",
          "formula": "ComputeHardyParadoxProbability(this.state_id, MeasurementEvent.*)",
          "description": "Evaluates Hardy's paradox conditions in measurement outcomes for this wavefunction. If certain probabilities appear contradictory under local realism, the aggregator flags or quantifies the paradox."
        },
        {
          "name": "interpretation_usage_summary",
          "type": "rollup",
          "formula": "CollectInterpretationEvidence(this.state_id, MeasurementEvent.*)",
          "description": "Scans all MeasurementEvents referencing this wavefunction. Summarizes how many used single-outcome (Copenhagen), branching (Many-Worlds), or observer-relative updates (RQM), highlighting if an inconsistent or hybrid interpretation is in play."
        },
        {
          "name": "multi_partition_entanglement_map",
          "type": "rollup",
          "formula": "EvaluateAllBipartitionsForEntanglement(this.state_id)",
          "description": "For a multi-qubit or multi-part system, systematically checks all bipartitions (and optionally tripartitions) to compute entanglement entropies. Useful for classifying the wavefunction as GHZ-like, W-state–like, or product-like across different partitions."
        },
        {
          "name": "global_pointer_basis_inference",
          "type": "rollup",
          "formula": "InferPointerBasisStability(this.state_id, pointer_basis_candidates, ObserverFrame.*)",
          "description": "Combines the wavefunction's pointer_basis_candidates with any available observer data (e.g. Darwinism indices) to decide if a stable, classical-like pointer basis has globally emerged (i.e., robust against decoherence and visible to multiple observers)."
        }
      ],
      "lambdas": [
        {
          "name": "normalize_wavefunction",
          "parameters": [],
          "formula": "amplitude_data / SQRT(normalization)"
        },
        {
          "name": "merge_with_another_state",
          "parameters": ["target_state_id", "entangling_params"],
          "formula": "CreateNewEntangledState(this.state_id, target_state_id, entangling_params)"
        }
      ],
      "constraints": [
        {
          "name": "normalization_check",
          "formula": "ABS( normalization - 1 ) <= epsilon",
          "error_message": "Wavefunction must be normalized (or near 1)."
        }
      ]
    },
    {
      "name": "InterpretationPolicy",
      "description": "Configures which quantum interpretation applies to a given wavefunction or system.",
      "fields": [
        {
          "name": "interpretation_id",
          "type": "scalar",
          "datatype": "string",
          "primary_key": true
        },
        {
          "name": "interpretation_name",
          "type": "scalar",
          "datatype": "enum",
          "description": "One of: ['Copenhagen','ManyWorlds','RQM']"
        },
        {
          "name": "collapse_behavior",
          "type": "scalar",
          "datatype": "string",
          "description": "e.g. 'single_outcome' (Copenhagen), 'branch' (ManyWorlds), 'observer_relative' (RQM)."
        },
        {
          "name": "observer_specificity",
          "type": "scalar",
          "datatype": "boolean",
          "description": "true if RQM requires observer frames to define partial states"
        },
        {
          "name": "metadata",
          "type": "scalar",
          "datatype": "json",
          "description": "Arbitrary extra settings, e.g. {branch_weight: 'equal', collapse_threshold: 0.95}"
        },
        {
          "name": "allow_partial_branching",
          "type": "scalar",
          "datatype": "boolean",
          "description": "Set to true if partial branching is utilized for RQM or specialized scenarios."
        },
        {
          "name": "observer_hierarchy_model",
          "type": "scalar",
          "datatype": "string",
          "description": "For advanced RQM usage, describes how to handle nested observers (e.g., Wigner's friend). Could be 'flat', 'hierarchical', or 'unrestricted'."
        }
      ],
      "lookups": [
        {
          "name": "applied_wavefunctions",
          "description": "Reverse lookup to QuantumState with interpretation_id = this ID.",
          "target_entity": "QuantumState",
          "type": "one_to_many",
          "join_condition": "QuantumState.interpretation_id = this.interpretation_id"
        }
      ],
      "aggregations": [
        {
          "name": "wavefunction_count",
          "type": "rollup",
          "formula": "COUNT(applied_wavefunctions)"
        },
        {
          "name": "interpretation_consistency_check",
          "type": "rollup",
          "formula": "EnsurePolicyAlignment(interpretation_name, collapse_behavior, observer_specificity, allow_partial_branching)",
          "description": "Checks that the chosen interpretation_name aligns with the specified collapse_behavior and observer settings (e.g. RQM requires observer_specificity=true)."
        },
        {
          "name": "rqm_policy_coherence",
          "type": "rollup",
          "formula": "CheckRQMPolicyCoherence(allow_partial_branching, observer_specificity, observer_hierarchy_model)",
          "description": "Verifies that partial branching plus the chosen hierarchy model do not conflict. For instance, hierarchical RQM might forbid certain merges."
        },
        {
          "name": "policy_alignment_inference",
          "type": "rollup",
          "formula": "IF(interpretation_consistency_check == 'ok' AND rqm_policy_coherence == 'ok', 'Interpretation policy aligned', 'Mismatch or error in policy config')",
          "description": "Summarizes whether the chosen interpretation_name, collapse_behavior, and observer settings are consistent with each other."
        }
      ],
      "lambdas": [
        {
          "name": "assign_rqm_ruleset",
          "parameters": ["ruleset_id"],
          "formula": "ApplyRQMRuleset(this.interpretation_id, ruleset_id, allow_partial_branching)"
        }
        
      ],
      "constraints": []
    },
    {
      "name": "MeasurementEvent",
      "description": "Records an observation that might cause wavefunction collapse, branching, or observer-relative updates.",
      "fields": [
        {
          "name": "meas_id",
          "type": "scalar",
          "datatype": "string",
          "primary_key": true
        },
        {
          "name": "wavefunction_id",
          "type": "lookup",
          "target_entity": "QuantumState",
          "description": "Which wavefunction is being 'measured' or observed?"
        },
        {
          "name": "measurement_type",
          "type": "scalar",
          "datatype": "string",
          "description": "Indicates the kind of measurement: e.g. 'position', 'spin', 'partial_POVM', etc."
        },
        {
          "name": "observable_operator",
          "type": "scalar",
          "datatype": "json"
        },
        {
          "name": "possible_outcomes",
          "type": "scalar",
          "datatype": "json",
          "description": "List or map of outcome labels and their amplitude slices."
        },
        {
          "name": "time_stamp",
          "type": "scalar",
          "datatype": "datetime"
        },
        {
          "name": "observer_id",
          "type": "lookup",
          "target_entity": "ObserverFrame",
          "description": "For RQM, which observer sees this event?"
        },
        {
          "name": "selected_outcome",
          "type": "scalar",
          "datatype": "string",
          "description": "Copenhagen-like single outcome OR blank if Many-Worlds branches all outcomes."
        },
        {
          "name": "branch_ids_generated",
          "type": "scalar",
          "datatype": "json",
          "description": "For Many-Worlds, a list of new branch IDs post-measurement"
        },
        {
          "name": "observed_observer_id",
          "type": "lookup",
          "target_entity": "ObserverFrame",
          "description": "If this measurement is specifically an observer measuring another observer (RQM style), this links to the measured observer."
        },
        {
          "name": "relational_records",
          "type": "scalar",
          "datatype": "json",
          "description": "Any additional RQM-specific metadata capturing how the measuring observer updates their view of the measured observer."
        } 
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "outcome_probabilities",
          "type": "rollup",
          "formula": "ComputeOutcomeDistribution(wavefunction_id.amplitude_data, observable_operator)"
        },
        {
          "name": "temporal_consistency_check",
          "type": "rollup",
          "formula": "CheckMeasurementConsistency(wavefunction_id, meas_id)"
        },
        {
          "name": "history_consistency",
          "type": "rollup",
          "formula": "ComputeHistoryConsistency(this.meas_id, wavefunction_id)"
        },
        {
          "name": "causality_check",
          "type": "rollup",
          "formula": "CheckTemporalOrdering(time_stamp, wavefunction_id)"
        },
        {
          "name": "classical_fact_agreement",
          "type": "rollup",
          "formula": "ComputeClassicalFactAgreement(meas_id)"
        },
        {
          "name": "observer_relative_outcomes",
          "type": "rollup",
          "formula": "ComputeObserverRelativeOutcomes(wavefunction_id, observer_id, possible_outcomes)",
          "description": "For RQM or partial branching scenarios, derives outcome distribution from the perspective of a given observer."
        },
        {
          "name": "relational_outcome_update",
          "type": "rollup",
          "formula": "ComputeRelationalMeasurementOutcome(wavefunction_id, observer_id, observed_observer_id)",
          "description": "Similar to observer_relative_outcomes, but specifically for 'observer measuring observer' scenarios."
        },
        {
          "name": "interpretation_inference",
          "type": "rollup",
          "formula": "IF(selected_outcome != '', 'Copenhagen', IF(branch_ids_generated != null AND LENGTH(branch_ids_generated) > 0, 'ManyWorlds', 'PossibleRQM'))",
          "description": "Infers which interpretation was effectively used for this measurement: single-outcome indicates Copenhagen, multiple branches indicates Many-Worlds, empty suggests RQM or not yet resolved."
        },
        {
          "name": "policy_vs_outcome_consistency",
          "type": "rollup",
          "formula": "CheckPolicyOutcomeConsistency(wavefunction_id.interpretation_id, selected_outcome, branch_ids_generated)",
          "description": "Verifies that the actual measurement result or branching is consistent with the wavefunction’s assigned interpretation policy."
        }
      ],
      "lambdas": [
        {
          "name": "execute_measurement",
          "parameters": [],
          "formula": "InterpretationBasedMeasurement(wavefunction_id, observer_id, this.possible_outcomes, this.outcome_probabilities)"
        },
        {
          "name": "execute_relational_measurement",
          "parameters": [],
          "formula": "RelationalMeasurementProtocol(this.meas_id, this.observer_id, this.observed_observer_id, wavefunction_id)"
        }
      ],
      "constraints": []
    },
    {
      "name": "ObserverFrame",
      "description": "RQM vantage point. Each observer can have partial knowledge or partial wavefunction states.",
      "fields": [
        {
          "name": "observer_id",
          "type": "scalar",
          "datatype": "string",
          "primary_key": true
        },
        {
          "name": "observer_name",
          "type": "scalar",
          "datatype": "string"
        },
        {
          "name": "observed_state_records",
          "type": "scalar",
          "datatype": "json",
          "description": "Potential partial wavefunction or outcome records known to this observer."
        },
        {
          "name": "reference_frame_transform",
          "type": "scalar",
          "datatype": "json",
          "description": "Any shift/boost or coordinate transform used by this observer."
        },
        {
          "name": "quantum_darwinism_index",
          "type": "rollup",
          "formula": "ComputeDarwinismIndex(this.observer_id)",
          "description": "Measures how many ObserverFrames share consistent outcome records, indicating emergent classicality."
        },
        {
          "name": "contextual_state_data",
          "type": "scalar",
          "datatype": "json",
          "description": "The wavefunction (or partial wavefunction) as assigned by this observer after applying its own Bayesian or RQM-like update rules."
        },
        {
          "name": "view_of_other_observers",
          "type": "scalar",
          "datatype": "json",
          "description": "Mapping from other_observer_id => local record of that observer's wavefunction/outcomes. In RQM, each observer can maintain a perspective on others."
        },
        {
          "name": "self_observed_history",
          "type": "scalar",
          "datatype": "json",
          "description": "Records how this observer perceives themselves across time, which may differ from external observer logs. RQM emphasizes each observer's self-consistent timeline."
        },
        {
          "name": "epistemic_context",
          "type": "scalar",
          "datatype": "json",
          "description": "Captures any extra Bayesian or 'knowledge state' aspects that define the observer's vantage (e.g., prior beliefs). Could inform partial wavefunction updates."
        },
        {
          "name": "self_vs_external_consistency",
          "type": "rollup",
          "formula": "ComputeSelfExternalConsistency(this.observer_id, self_observed_history, view_of_other_observers)",
          "description": "Compares the observer’s self-history with external logs (how others observe them), highlighting potential RQM mismatches."
        }
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "shared_state_agreement",
          "type": "rollup",
          "formula": "ComputeObserverConvergence(this.observer_id)"
        },
        {
          "name": "intersubjective_consistency_check",
          "type": "rollup",
          "formula": "CompareWithOtherObservers(this.observer_id)"
        },
        {
          "name": "observer_consensus",
          "type": "rollup",
          "formula": "ComputeObserverConsensus(this.observer_id)"
        },
        {
          "name": "observer_relative_state",
          "type": "rollup",
          "formula": "ComputeObserverRelativeState(this.observer_id, contextual_state_data)",
          "description": "Generates the local quantum state from this observer's vantage, consistent with RQM approaches."
        },
        {
          "name": "multi_observer_consensus",
          "type": "rollup",
          "formula": "ComputeMultiObserverConsensus(this.observer_id)",
          "description": "Generalizes observer_consensus to >2 observers. Aggregates the partial states or measurement outcomes from multiple observers that this observer can 'see'."
        },
        {
          "name": "self_consistency",
          "type": "rollup",
          "formula": "CheckSelfConsistency(self_observed_history, contextual_state_data)",
          "description": "Verifies that the observer’s own timeline of events aligns with the partial wavefunction assigned to themselves (detecting RQM 'self-measurement' paradoxes)."
        },
        {
          "name": "observer_consistency_inference",
          "type": "rollup",
          "formula": "IF(intersubjective_consistency_check == 'ok' AND self_consistency == 'ok', 'Fully consistent vantage', 'Mismatch or paradox in observer frame')",
          "description": "Summarizes whether this observer’s vantage is consistent with itself and with other observers’ records."
        },
        {
          "name": "classicality_inference",
          "type": "rollup",
          "formula": "IF(quantum_darwinism_index > 5, 'Classical-like pointer states emergent', 'Quantum coherence remains significant')",
          "description": "A simple threshold-based inference to see if many observers converge on the same outcome, indicating emergent classical pointer states."
        },
        {
          "name": "darwinism_timeline",
          "type": "rollup",
          "formula": "ComputeDarwinismOverTime(participants)",
          "description": "Examines how stable the classical-like pointer emerges across multiple observation times."
        },
        {
          "name": "multi_observer_merge",
          "type": "rollup",
          "formula": "PerformRQMObserverMerge(this.record_id, participants)"
        }
      ],
      "lambdas": [
        {
          "name": "update_observed_context",
          "parameters": ["measurement_id"],
          "formula": "BayesianObserverUpdate(this.observer_id, measurement_id, contextual_state_data)"
        },
        {
          "name": "update_relational_view",
          "parameters": ["target_observer_id", "measurement_data"],
          "formula": "RQMRelationalUpdate(this.observer_id, target_observer_id, measurement_data, view_of_other_observers)"
        },
        {
          "name": "synchronize_self_view",
          "parameters": ["new_self_data"],
          "formula": "UpdateSelfObservedHistory(this.observer_id, new_self_data, self_observed_history)"
        }
      ],
      "constraints": []
    },
    {
      "name": "BranchRecord",
      "description": "Many-Worlds or partial RQM branching metadata—each branch is a distinct wavefunction 'slice' after measurement.",
      "fields": [
        {
          "name": "branch_id",
          "type": "scalar",
          "datatype": "string",
          "primary_key": true
        },
        {
          "name": "wavefunction_id",
          "type": "lookup",
          "target_entity": "QuantumState"
        },
        {
          "name": "origin_meas_id",
          "type": "lookup",
          "target_entity": "MeasurementEvent",
          "description": "Which measurement event spawned this branch?"
        },
        {
          "name": "branch_amplitude_data",
          "type": "scalar",
          "datatype": "json",
          "description": "The wavefunction slice or projected amplitude for this branch."
        },
        {
          "name": "prob_weight",
          "type": "calculated",
          "formula": "SUM( ABS(branch_amplitude_data)^2 )",
          "description": "Probability weight for this branch in a many-worlds context."
        },
        {
          "name": "parent_branch_id",
          "type": "lookup",
          "target_entity": "BranchRecord",
          "description": "Points to the branch from which this emerged"
        },
        {
          "name": "branch_depth",
          "type": "calculated",
          "formula": "ComputeBranchDepth(parent_branch_id)",
          "description": "Number of steps from the original wavefunction root"
        },
        {
          "name": "coherence_factor",
          "type": "calculated",
          "formula": "ComputeInterference(branch_amplitude_data, wavefunction_id)",
          "description": "Overlap measure with other branches of the same wavefunction"
        },
        {
          "name": "relative_phase",
          "type": "scalar",
          "datatype": "float",
          "description": "Phase angle relative to other sibling branches, used for potential recombination"
        },
        {
          "name": "branch_history",
          "type": "scalar",
          "datatype": "json",
          "description": "Stores a chronological list of significant events or merges for this branch."
        },
        {
          "name": "observer_scope",
          "type": "scalar",
          "datatype": "json",
          "description": "Optional list of observer_ids for which this branch is relevant in partial branching (RQM) contexts."
        },
        {
          "name": "observer_relational_cut",
          "type": "scalar",
          "datatype": "json",
          "description": "Defines which subset of observers or subsystems are part of this partial branch in an RQM scenario, i.e., local branching but not global."
        }
        
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "recombination_potential",
          "type": "rollup",
          "formula": "ComputeRecombinationPotential(coherence_factor, branch_amplitude_data)"
        },
        {
          "name": "recombination_feasibility",
          "type": "rollup",
          "formula": "CheckRecombinationFeasibility(coherence_factor, relative_phase, wavefunction_id)"
        },
        {
          "name": "rqm_merge_potential",
          "type": "rollup",
          "formula": "ComputeRQMBranchMergePotential(observer_scope, parent_branch_id)",
          "description": "Evaluates if branches can be effectively merged when the same observer updates their knowledge in RQM contexts."
        },
        {
          "name": "observer_scope_overlap",
          "type": "rollup",
          "formula": "CheckBranchObserverOverlap(this.branch_id, observer_scope, observer_relational_cut)",
          "description": "Determines which observers are 'co-branching' here and which remain in superposition from each other’s viewpoint."
        },
        {
          "name": "branch_interference_inference",
          "type": "rollup",
          "formula": "IF(coherence_factor > 1e-3, 'Potential for re-interference', 'Effectively orthogonal')",
          "description": "Classifies whether this branch can still interfere with other branches (coherence_factor above threshold) or if it is effectively decohered."
        },
        {
          "name": "branch_merge_probability",
          "type": "rollup",
          "formula": "ComputeBranchMergeProbability(this.branch_id, observer_scope, coherence_factor)",
          "description": "Numerical measure of how likely these partial branches can unify from an observer’s vantage."
        },
        {
          "name": "branch_reunion_check",
          "type": "rollup",
          "formula": "EvaluateBranchReunionFeasibility(this.branch_id, sibling_branches)",
          "description": "Analyzes whether sibling branches (e.g. from the same measurement event) can genuinely recombine based on their coherence_factor, relative_phase, and decoherence state. Flags merges that are effectively forbidden once branches are orthogonal."
        }
      ],
      "lambdas": [
        {
          "name": "merge_partial_branches",
          "parameters": ["other_branch_id"],
          "formula": "RQMPartialBranchMerge(this.branch_id, other_branch_id, observer_relational_cut)"
        },
        {
          "name": "merge_branches_for_observer",
          "parameters": ["target_branch_id", "observer_id"],
          "formula": "RQMPartialBranchMergeLogic(this.state_id, target_branch_id, observer_id)"
        }
      ],
      "constraints": []
    },
    {
      "name": "Observable",
      "fields": [
        {
          "name": "operator_id",
          "type": "string",
          "description": "Unique identifier for this observable/operator."
        },
        {
          "name": "matrix_representation",
          "type": "array",
          "description": "Matrix (or array) holding the operator’s numerical data."
        },
        {
          "name": "eigenvalues",
          "type": "array",
          "description": "List of eigenvalues for quick reference in measurement events."
        },
        {
          "name": "eigenvectors",
          "type": "array",
          "description": "Eigenvectors or basis states associated with each eigenvalue."
        }
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "checkHermiticity",
          "type": "rollup",
          "formula": "VerifyHermitian(matrix_representation)",
          "description": "Ensures the operator is Hermitian, which is required for a valid observable."
        }
      ],
      "lambdas": []
    },
    {
      "name": "DensityMatrixRecord",
      "fields": [
        {
          "name": "record_id",
          "type": "string",
          "description": "Unique identifier for the density matrix record."
        },
        {
          "name": "matrix_data",
          "type": "array",
          "description": "2D array representing the density matrix (complex values)."
        },
        {
          "name": "subsystem_ids",
          "type": "array",
          "description": "IDs of the subsystem(s) described by this density matrix."
        },
        {
          "name": "purity",
          "type": "number",
          "description": "Optional cached purity measure (Tr(ρ²))."
        }
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "computePurity",
          "type": "formula",
          "formula": "Purity(matrix_data)"
        },
        {
          "name": "traceValue",
          "type": "formula",
          "formula": "ComputeMatrixTrace(matrix_data)",
          "description": "Computes the trace of the density matrix, which should be 1 for proper normalization."
        },
        {
          "name": "tomographic_reconstruction",
          "type": "rollup",
          "formula": "ReconstructDensityMatrixFromMeasurements(this.record_id, MeasurementEvent.*)",
          "description": "Performs quantum state tomography by aggregating measurement outcomes across various bases. Produces an estimated density matrix to compare with this record's matrix_data for consistency checks or validation of experimental data."
        }
      ],
      "lambdas": [
        {
          "name": "applyKrausOperators",
          "description": "Applies a set of Kraus operators to the density matrix for an open-system evolution.",
          "params": [
            "kraus_set"
          ]
        }
      ],
      "constraints": [
        {
          "name": "trace_must_be_one",
          "formula": "ABS(ComputeMatrixTrace(matrix_data) - 1) <= epsilon",
          "error_message": "Density matrix must have trace ~ 1."
        }
      ]
    },
    {
      "name": "Subsystem",
      "fields": [
        {
          "name": "subsystem_id",
          "type": "string",
          "description": "Unique ID for the subsystem."
        },
        {
          "name": "description",
          "type": "string",
          "description": "Human-readable description of what this subsystem represents (e.g. qubit, photon mode, etc.)."
        },
        {
          "name": "dimensions",
          "type": "number",
          "description": "Hilbert space dimension for this subsystem."
        }
      ],
      "lookups": [],
      "aggregations": [],
      "lambdas": []
    },
    {
      "name": "DecoherenceChannel",
      "fields": [
        {
          "name": "channel_id",
          "type": "string",
          "description": "Unique identifier for this decoherence or noise model."
        },
        {
          "name": "kraus_operators",
          "type": "array",
          "description": "Collection of Kraus operators (matrices) describing the channel."
        },
        {
          "name": "applied_subsystems",
          "type": "array",
          "description": "IDs of subsystems to which this channel is applied."
        }
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "simulateDecoherence",
          "type": "formula",
          "formula": "ApplyKrausSet(density_matrix, kraus_operators)"
        },
        {
          "name": "validateKrausOperators",
          "type": "formula",
          "formula": "CheckKrausCompleteness(kraus_operators)",
          "description": "Ensures the sum of K^†K = I across all Kraus operators, for a valid channel."
        }
      ],
      "lambdas": []
    },
    {
      "name": "QuantumEvolution",
      "fields": [
        {
          "name": "evolution_id",
          "type": "string",
          "description": "Unique identifier for this evolution spec."
        },
        {
          "name": "hamiltonian_ref",
          "type": "string",
          "description": "Reference to an operator_id in the Observable entity that acts as the Hamiltonian."
        },
        {
          "name": "time_step",
          "type": "number",
          "description": "Time increment for stepwise evolution."
        },
        {
          "name": "evolution_method",
          "type": "string",
          "description": "Method used (e.g. 'Trotter', 'Exact', 'RK4', etc.)."
        }
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "applyTimeEvolution",
          "type": "formula",
          "formula": "U(t) = exp(-i * H * t); wavefunction' = U(t)*wavefunction"
        },
        {
          "name": "hamiltonian_validity",
          "type": "formula",
          "formula": "VerifyHermitian(hamiltonian_ref)",
          "description": "Checks that the referenced Hamiltonian is Hermitian, which is required for unitary time evolution."
        }
      ],
      "lambdas": []
    },
    {
      "name": "QuantumEvent",
      "fields": [
        {
          "name": "event_id",
          "type": "string",
          "description": "Unique identifier for the quantum event."
        },
        {
          "name": "type",
          "type": "string",
          "description": "General type of event (e.g. 'measurement', 'unitary', 'entangling_interaction')."
        },
        {
          "name": "operator_ref",
          "type": "string",
          "description": "Optional reference to an Observable (for measurement) or other operator."
        },
        {
          "name": "applied_to",
          "type": "array",
          "description": "List of subsystem_ids or wavefunction_ids that this event acts upon."
        },
        {
          "name": "timestamp",
          "type": "string",
          "description": "Record of when the event happened, if relevant."
        },
        {
          "name": "metadata",
          "type": "object",
          "description": "Free-form map for additional information about this event."
        }
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "verifyEventApplicability",
          "type": "formula",
          "formula": "CheckEventConsistency(type, operator_ref, applied_to)",
          "description": "Ensures a measurement event references a valid measurement operator, or a unitary event references a valid gate, etc."
        }
      ],
      "lambdas": []
    },
    {
      "name": "ObserverRelationship",
      "fields": [
        {
          "name": "relationship_id",
          "type": "string",
          "description": "Unique ID for this relationship record."
        },
        {
          "name": "observer_A",
          "type": "string",
          "description": "Reference to ObserverFrame or an observer entity."
        },
        {
          "name": "observer_B",
          "type": "string",
          "description": "Reference to another ObserverFrame or observer entity."
        },
        {
          "name": "shared_events",
          "type": "array",
          "description": "IDs of MeasurementEvents (or QuantumEvents) both observers have potentially compared."
        },
        {
          "name": "consistency_state",
          "type": "string",
          "description": "Status: e.g. 'agreed', 'unresolved', 'contradictory', etc."
        },
        {
          "name": "relational_view_consistency",
          "type": "scalar",
          "datatype": "json",
          "description": "Stores a snapshot of how observer_A perceives observer_B versus how observer_B perceives themselves, for explicit RQM cross-checking."
        }
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "observer_agreement_score",
          "type": "rollup",
          "formula": "ComputeObserverAgreement(observer_A, observer_B, shared_events)",
          "description": "Calculates a numeric or qualitative measure of how consistently the two observers interpret shared measurement events."
        },
        {
          "name": "rqm_intersubjective_discrepancy",
          "type": "rollup",
          "formula": "ComputeRQMDiscrepancy(observer_A, observer_B, relational_view_consistency)",
          "description": "Quantifies mismatch between how A sees B’s wavefunction and how B sees their own wavefunction."
        },
        {
          "name": "wigners_friend_paradox_indicator",
          "type": "rollup",
          "formula": "DetectWignersFriendParadox(observer_A, observer_B, shared_events)",
          "description": "Flags a mismatch if Observer A sees a collapsed outcome while Observer B sees a superposition for the same measurement event."
        },
        {
          "name": "nested_wigners_friend_indicator",
          "type": "rollup",
          "formula": "CheckNestedWignerScenario(observer_A, observer_B, shared_events)",
          "description": "Detects a multi-level scenario where B sees A in superposition after A measured the system."
        },
        {
          "name": "detect_cyclic_measurement_loop",
          "type": "rollup",
          "formula": "IdentifyMeasurementCyclesBetweenObservers(observer_A, observer_B, shared_events)",
          "description": "Checks if observer A measures observer B, while observer B also measures observer A (possibly at a different time), forming a cycle. Useful in RQM or extended Wigner's friend scenarios where cyclical measurement references can produce paradoxes."
        },
        {
          "name": "extended_nested_wigner_analysis",
          "type": "rollup",
          "formula": "ComputeMultiLevelWignerFriendScenario(observer_A, observer_B, shared_events)",
          "description": "Performs a deeper search for multi-level nested Wigner’s friend arrangements, analyzing partial collapses or superpositions from each vantage. Flags complex scenarios where an 'outer' observer sees a superposition even though an 'inner' observer recorded a collapse."
        }
      ],
      "lambdas": [
        {
          "name": "resolve_rqm_inconsistency",
          "parameters": [],
          "formula": "AttemptRQMInconsistencyResolution(observer_A, observer_B, shared_events, relational_view_consistency)"
        }
        
      ]
    },
    {
      "name": "ConsistencyCheck",
      "fields": [
        {
          "name": "check_id",
          "type": "string",
          "description": "Unique identifier for this consistency check."
        },
        {
          "name": "description",
          "type": "string",
          "description": "Describes the nature or purpose of this check."
        },
        {
          "name": "severity",
          "type": "string",
          "description": "Priority/impact level: e.g. 'warning', 'error'."
        },
        {
          "name": "results",
          "type": "array",
          "description": "Potentially a list of results or validations discovered."
        }
      ],
      "lookups": [],
      "aggregations": [],
      "lambdas": []
    },
    {
      "name": "QuantumCircuit",
      "fields": [
        {
          "name": "circuit_id",
          "type": "string",
          "description": "Unique identifier for this quantum circuit."
        },
        {
          "name": "gates",
          "type": "array",
          "description": "List of gate specifications (e.g. {gate_type, targets, control})."
        },
        {
          "name": "target_wavefunction",
          "type": "string",
          "description": "Reference to the wavefunction or subsystem(s) on which this circuit operates."
        }
      ],
      "lookups": [],
      "aggregations": [
        {
          "name": "generateCircuitMatrix",
          "type": "formula",
          "formula": "ComposeAllGatesIntoMatrix(gates)"
        },
        {
          "name": "validateCircuit",
          "type": "formula",
          "formula": "CheckGateSequence(gates, target_wavefunction)",
          "description": "Validates gate definitions and ensures they are consistent with the dimension of the target wavefunction or subsystem."
        },
        {
          "name": "executeCircuitAndMeasure",
          "type": "rollup",
          "formula": "ApplyCircuitThenMeasure(this.circuit_id, target_wavefunction, measurement_config)",
          "description": "Convenience aggregator to (1) apply all gates in this circuit to the target wavefunction and (2) automatically execute measurement events as specified by measurement_config. Can generate new MeasurementEvents or outcome logs in one step."
        }
      ],
      "lambdas": [
        {
          "name": "executeCircuit",
          "description": "Applies each gate in sequence to the specified wavefunction or subsystem state.",
          "params": []
        }
      ]
    },
    {
      "name": "IntersubjectiveRecord",
      "description": "Stores how a group of observers come to (or fail to reach) mutual agreement in RQM contexts.",
      "fields": [
        {
          "name": "record_id",
          "type": "scalar",
          "datatype": "string",
          "primary_key": true
        },
        {
          "name": "participants",
          "type": "scalar",
          "datatype": "json",
          "description": "List of observer_ids involved in the comparison or sharing process."
        },
        {
          "name": "comparison_strategy",
          "type": "scalar",
          "datatype": "string",
          "description": "E.g. 'direct_communication', 'classical_channel', or 'measurement_of_observer'."
        },
        {
          "name": "final_state_agreement",
          "type": "scalar",
          "datatype": "json",
          "description": "Aggregated final state or outcome that participants converge on (if any)."
        }
      ],
      "aggregations": [
        {
          "name": "participant_discrepancies",
          "type": "rollup",
          "formula": "ComputeMultiObserverDiscrepancies(participants)"
        },
        {
          "name": "multi_observer_inference",
          "type": "rollup",
          "formula": "IF(participant_discrepancies == 0, 'All participants in agreement', 'Discrepancies found among participants')",
          "description": "Evaluates whether multiple observers (participants) end up with the same final outcome, or if they disagree."
        },
        {
          "name": "multi_observer_classical_darwinism",
          "type": "rollup",
          "formula": "IF( SUM(ObserverFrame.quantum_darwinism_index FOR each participant) > some_threshold, 'Classical pointer states emergent', 'Significant quantum coherence remains' )",
          "description": "Checks if all participants collectively share enough overlapping measurement info to treat the outcome as a classical pointer."
        }
      ],
      "lambdas": [
        {
          "name": "execute_comparison_protocol",
          "parameters": [],
          "formula": "RunRQMIntersubjectiveComparison(this.record_id, participants)"
        }
      ],
      "constraints": []
    }    
  ]
}
