{
  "id": "CMCC_ToEMM_Conferencing",
  "meta-model": {
    "name": "Conference ToE Meta Model (Extended)",
    "description": "A unified meta-model capturing the domain of conferences—days, rooms, sessions, speakers, schedules, real-time event logic—now extended with 25 new inferences expressed as purely declarative fields, lookups, and aggregator definitions.",
    "version": "v1.0-extended",
    "nickname": "conferencing",
    "meta": {
      "title": "Conference ToE Meta-Model (Extended)",
      "subtitle": "A 100% Declarative Framework for Multi-day Events",
      "date": "March 2025",
      "abstract": "This model extends the original conference schema to illustrate 25 new inferences, each implemented via aggregator fields, constraints, or new event entities. We adhere strictly to the CMCC principle of data-driven domain logic, adding features like day-level check-ins, sponsor policy checks, advanced concurrency detection, and more—still purely declarative.",
      "executive_summary": {
        "key_points": [
          "Maintains a purely declarative logic style for session concurrency, capacity, sponsor, and time-based calculations.",
          "Introduces new aggregator fields for real-time analysis (peak usage, average durations, overlapping speaker checks).",
          "Adds a new event entity (AttendeeDayCheckInEvent) for daily presence tracking.",
          "Demonstrates how to expand the domain model by simply defining new aggregator or constraint logic—no imperative code."
        ],
        "implications": [
          "Enhances real-time data insights without rewriting any procedural code.",
          "Shows the ease of domain model growth: new rules, new event types, new aggregator fields, all purely data-based."
        ],
        "narrative": [
          {
            "title": "Extended Declarative Features",
            "content": [
              "This extended version of the Conference ToE Meta Model introduces a wide variety of aggregator fields—some measure daily usage (peak capacity, most-attended session), some track advanced speaker or attendee behaviors (overlapping sessions, day-level check-ins). The entire domain remains purely declarative: everything from forced early session endings to sponsor policies is expressed as constraints, aggregator formulas, or event records."
            ]
          }
        ],
        "addressing_concerns_preemptively": {
          "what_not_how": "We continue to specify WHAT must be true in the domain. Implementation details about how to evaluate these aggregator fields remain outside this schema.",
          "time": "Time logic (e.g., active sessions, day check-in durations) is captured as aggregator formulas referencing CURRENT_TIME. No step-by-step time iteration needed.",
          "rulebook_not_the_runtime": "The schema remains the rulebook. The runtime or engine enforces or checks these purely declarative rules in real-time.",
          "scaleability_performance": "Even with additional aggregator fields, the conceptual approach remains: data + aggregator logic. Performance optimization is an implementation detail.",
          "reality_is_the_best_runtime_engine": "Real attendees and sessions happen in the physical venue; we only capture them as facts. We trust the engine to keep aggregator fields updated in real-time.",
          "bright_red_lines": "These new aggregator fields and the new event entity do not break the separation of domain definitions from the runtime. No new imperative instructions—just new data facts."
        }
      }
    },
    "schema": {
      "entities": [
        {
          "name": "Conference",
          "description": "Represents a multi-day event. Tracks overall name, location, included days, sponsor assignments, and aggregator fields (e.g., total sessions).",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique identifier for the conference."
            },
            {
              "name": "conferenceName",
              "type": "scalar",
              "datatype": "string",
              "description": "Official or common name of the conference."
            },
            {
              "name": "location",
              "type": "scalar",
              "datatype": "string",
              "description": "Venue or city where the conference is held."
            }
          ],
          "lookups": [
            {
              "name": "days",
              "target_entity": "ConferenceDay",
              "type": "one_to_many",
              "join_condition": "ConferenceDay.conferenceId = this.id",
              "description": "All days that belong to this conference."
            },
            {
              "name": "sponsors",
              "target_entity": "Sponsor",
              "type": "one_to_many",
              "join_condition": "Sponsor.conferenceId = this.id",
              "description": "All sponsors officially participating in this conference."
            },
            {
              "name": "speakers",
              "target_entity": "Speaker",
              "type": "one_to_many",
              "join_condition": "Speaker.conferenceId = this.id",
              "description": "All speakers registered for this conference."
            },
            {
              "name": "rooms",
              "target_entity": "Room",
              "type": "one_to_many",
              "join_condition": "Room.conferenceId = this.id",
              "description": "All rooms used by this conference."
            }
          ],
          "aggregations": [
            {
              "name": "totalSessions",
              "type": "rollup",
              "description": "Counts the total number of scheduled sessions across all days in the conference.",
              "formula": "SUM(days.sessionCount)"
            },
            {
              "name": "totalAttendeeCapacity",
              "type": "rollup",
              "description": "Sum of all room capacities, an approximate upper bound if every room was used at once.",
              "formula": "SUM(rooms.capacity)"
            },
            {
              "name": "runningNowSessions",
              "type": "rollup",
              "description": "How many sessions are currently in progress across the entire conference.",
              "formula": "COUNT(Session WHERE isInProgress=true AND dayId in days)"
            },
            {
              "name": "maxConcurrentSessions",
              "type": "rollup",
              "description": "The maximum number of sessions that are simultaneously running at any point in time. Implementation conceptual.",
              "formula": "CALCULATE_MAX_OVERLAPPING_SESSIONS(all sessions in this conference)"
            },
            {
              "name": "activeDayCount",
              "type": "rollup",
              "description": "Number of days that are still active or upcoming (based on the schedule).",
              "formula": "COUNT(days WHERE dayIsComplete=false)"
            },
            {
              "name": "isConferenceComplete",
              "type": "rollup",
              "description": "True if all days in the conference are complete.",
              "formula": "NOT EXISTS(ConferenceDay WHERE conferenceId=this.id AND isDayComplete=false)"
            },
            {
              "name": "peakDailyCapacityUsed",
              "type": "rollup",
              "description": "// NEW INFERENCE: The maximum of capacityUsed among all days in this conference.",
              "formula": "MAX(days.capacityUsed)"
            },
            {
              "name": "averageSessionDurationMinutes",
              "type": "rollup",
              "description": "// NEW INFERENCE: The average scheduled duration (in minutes) of all sessions in this conference.",
              "formula": "AVERAGE(Session.sessionDurationMinutes WHERE dayId in days)"
            },
            {
              "name": "conferenceHasKeynotes",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if at least one session is a KEYNOTE.",
              "formula": "EXISTS(Session WHERE sessionType='KEYNOTE' AND dayId in days)"
            },
            {
              "name": "totalUniqueAttendees",
              "type": "rollup",
              "description": "// NEW INFERENCE: Distinct count of attendee IDs across all SessionAttendanceEvents within this conference.",
              "formula": "COUNT(DISTINCT(SessionAttendanceEvent.attendeeId) WHERE sessionId.dayId.conferenceId = this.id)"
            },
            {
              "name": "isConferenceActiveNow",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if any session isInProgress=true or any day isDayActive=true for this conference.",
              "formula": "EXISTS(ConferenceDay WHERE conferenceId=this.id AND isDayActive=true)"
            }
          ],
          "lambdas": [
            {
              "name": "closeConference",
              "parameters": [],
              "description": "// DECLARATIVE: If all days are done, the conference is effectively 'closed'—covered by aggregator isConferenceComplete.",
              "formula": "IF (isConferenceComplete=true) THEN (Conference.status='CLOSED')"
            }
          ],
          "constraints": []
        },
        {
          "name": "ConferenceDay",
          "description": "Represents a single day in the conference schedule. Tied to date(s), references sessions, breaks, or special events.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique identifier for the conference day."
            },
            {
              "name": "conferenceId",
              "type": "lookup",
              "target_entity": "Conference",
              "foreign_key": true,
              "description": "Which conference this day belongs to."
            },
            {
              "name": "dayDate",
              "type": "scalar",
              "datatype": "date",
              "description": "Calendar date for this conference day."
            },
            {
              "name": "startTime",
              "type": "scalar",
              "datatype": "datetime",
              "description": "Scheduled start time for the day (e.g., 8:00 AM)."
            },
            {
              "name": "endTime",
              "type": "scalar",
              "datatype": "datetime",
              "description": "Scheduled end time (e.g., 6:00 PM)."
            }
          ],
          "lookups": [
            {
              "name": "sessions",
              "target_entity": "Session",
              "type": "one_to_many",
              "join_condition": "Session.dayId = this.id",
              "description": "All sessions taking place on this day."
            }
          ],
          "aggregations": [
            {
              "name": "sessionCount",
              "type": "rollup",
              "description": "Number of sessions scheduled for this day.",
              "formula": "COUNT(sessions)"
            },
            {
              "name": "runningSessionsNow",
              "type": "rollup",
              "description": "How many sessions are currently in progress on this day.",
              "formula": "COUNT(sessions WHERE isInProgress=true)"
            },
            {
              "name": "isDayActive",
              "type": "rollup",
              "description": "True if current time is between day start/end or if any session is still running.",
              "formula": "(CURRENT_TIME >= startTime AND CURRENT_TIME <= endTime) OR runningSessionsNow>0"
            },
            {
              "name": "isDayComplete",
              "type": "rollup",
              "description": "True if all sessions are finished and the endTime has passed.",
              "formula": "(NOT EXISTS(sessions WHERE isCompleted=false)) AND (CURRENT_TIME > endTime)"
            },
            {
              "name": "capacityUsed",
              "type": "rollup",
              "description": "Approx. aggregator for how many total seats are in use across currently running sessions.",
              "formula": "SUM(sessions.sessionAttendeeCount WHERE isInProgress=true)"
            },
            {
              "name": "hasScheduledBreaks",
              "type": "rollup",
              "description": "Indicates if any session is flagged as a break/meal on this day.",
              "formula": "EXISTS(sessions WHERE sessionType='BREAK' OR sessionType='MEAL')"
            },
            {
              "name": "occupiedRoomCount",
              "type": "rollup",
              "description": "// NEW INFERENCE: How many rooms are currently occupied (i.e., have an in-progress session) on this day.",
              "formula": "COUNT(DISTINCT sessions.roomId WHERE sessions.isInProgress=true)"
            },
            {
              "name": "mostAttendedSession",
              "type": "rollup",
              "description": "// NEW INFERENCE: The ID of the session with the highest sessionAttendeeCount on this day. Implementation conceptual if ties exist.",
              "formula": "FIND_MAX(sessions, sessionAttendeeCount)"
            },
            {
              "name": "dayLongestSession",
              "type": "rollup",
              "description": "// NEW INFERENCE: The session with the largest scheduled duration on this day.",
              "formula": "FIND_MAX(sessions, sessionDurationMinutes)"
            },
            {
              "name": "dayHasSponsorSessions",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if any session on this day has hasSponsorHighlight=true.",
              "formula": "EXISTS(sessions WHERE hasSponsorHighlight=true)"
            }
          ],
          "lambdas": [
            {
              "name": "startDay",
              "parameters": [],
              "description": "// DECLARATIVE: Day is considered started if CURRENT_TIME >= startTime.",
              "formula": "IF (CURRENT_TIME >= this.startTime) THEN (this.isDayActive=true)"
            },
            {
              "name": "endDay",
              "parameters": [],
              "description": "// DECLARATIVE: Day ends when all sessions are done and current time > endTime.",
              "formula": "IF (this.isDayComplete=true) THEN (DayStatus='ENDED')"
            }
          ],
          "constraints": []
        },
        {
          "name": "Room",
          "description": "A physical location or room for sessions. Tracks capacity, A/V, etc.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique identifier for the room."
            },
            {
              "name": "conferenceId",
              "type": "lookup",
              "target_entity": "Conference",
              "foreign_key": true,
              "description": "Which conference this room belongs to."
            },
            {
              "name": "roomName",
              "type": "scalar",
              "datatype": "string",
              "description": "Name or label for this room (e.g., 'Room 101')."
            },
            {
              "name": "capacity",
              "type": "scalar",
              "datatype": "integer",
              "description": "Maximum capacity for attendees."
            }
          ],
          "lookups": [
            {
              "name": "sessions",
              "target_entity": "Session",
              "type": "one_to_many",
              "join_condition": "Session.roomId = this.id",
              "description": "All sessions scheduled in this room."
            }
          ],
          "aggregations": [
            {
              "name": "currentSession",
              "type": "rollup",
              "description": "Which session is in progress right now in this room, if any.",
              "formula": "FIND(Session WHERE roomId=this.id AND isInProgress=true)"
            },
            {
              "name": "totalSessionsInRoom",
              "type": "rollup",
              "description": "Number of sessions scheduled in this room across all days.",
              "formula": "COUNT(sessions)"
            },
            {
              "name": "roomUtilizationRate",
              "type": "rollup",
              "description": "Calculated ratio of how many hours this room is in use vs. total conference hours. Conceptual.",
              "formula": "CALCULATE_ROOM_UTILIZATION(this.id)"
            },
            {
              "name": "roomIsCurrentlyOccupied",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if currentSession is in progress (i.e. isInProgress=true).",
              "formula": "EXISTS(currentSession WHERE isInProgress=true)"
            }
          ],
          "lambdas": [
            {
              "name": "assignSession",
              "parameters": ["sessionId"],
              "description": "// DECLARATIVE: If a Session references this roomId, it’s assigned.",
              "formula": "Session(sessionId).roomId = this.id"
            }
          ],
          "constraints": [
            {
              "name": "roomCapacityNonNegative",
              "formula": "capacity >= 0",
              "error_message": "Room capacity cannot be negative."
            }
          ]
        },
        {
          "name": "Session",
          "description": "A single talk, workshop, panel, or break event within the conference day/room assignment.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique identifier for this session."
            },
            {
              "name": "dayId",
              "type": "lookup",
              "target_entity": "ConferenceDay",
              "foreign_key": true,
              "description": "Which conference day this session belongs to."
            },
            {
              "name": "roomId",
              "type": "lookup",
              "target_entity": "Room",
              "foreign_key": true,
              "description": "Which room this session is scheduled in."
            },
            {
              "name": "sessionTitle",
              "type": "scalar",
              "datatype": "string",
              "description": "Title or name of the session."
            },
            {
              "name": "startTime",
              "type": "scalar",
              "datatype": "datetime",
              "description": "When the session is scheduled to start."
            },
            {
              "name": "endTime",
              "type": "scalar",
              "datatype": "datetime",
              "description": "When the session is scheduled to end."
            },
            {
              "name": "sessionType",
              "type": "scalar",
              "datatype": "string",
              "description": "E.g., 'TALK','WORKSHOP','KEYNOTE','BREAK','MEAL', etc."
            },
            {
              "name": "isCanceled",
              "type": "scalar",
              "datatype": "boolean",
              "description": "Flag indicating if this session has been canceled. Default false."
            }
          ],
          "lookups": [
            {
              "name": "speakers",
              "target_entity": "Speaker",
              "type": "many_to_many",
              "description": "Which speaker(s) are leading this session."
            },
            {
              "name": "attendeeEvents",
              "target_entity": "SessionAttendanceEvent",
              "type": "one_to_many",
              "join_condition": "SessionAttendanceEvent.sessionId = this.id",
              "description": "All check-in or check-out events referencing this session."
            }
          ],
          "aggregations": [
            {
              "name": "isInProgress",
              "type": "rollup",
              "description": "Session is in progress if current time is between start/end and not canceled.",
              "formula": "(CURRENT_TIME >= startTime AND CURRENT_TIME < endTime) AND (isCanceled=false)"
            },
            {
              "name": "isCompleted",
              "type": "rollup",
              "description": "True if current time >= endTime or a SessionEndEvent ended it, and not canceled.",
              "formula": "((CURRENT_TIME >= endTime) OR (EXISTS(SessionEndEvent WHERE sessionId=this.id))) AND (isCanceled=false)"
            },
            {
              "name": "sessionDurationMinutes",
              "type": "rollup",
              "description": "Number of minutes from scheduled start to scheduled end.",
              "formula": "TIMEDIFF(endTime, startTime)"
            },
            {
              "name": "sessionAttendeeCount",
              "type": "rollup",
              "description": "Number of unique attendees currently checked in (arrived but not departed).",
              "formula": "COUNT(DISTINCT attendeeEvents.attendeeId WHERE checkInTime != null AND checkOutTime=null)"
            },
            {
              "name": "speakersCount",
              "type": "rollup",
              "description": "Number of assigned speakers for this session.",
              "formula": "COUNT(speakers)"
            },
            {
              "name": "hasSponsorHighlight",
              "type": "rollup",
              "description": "If a sponsor is officially associated with the session. Implementation conceptual.",
              "formula": "EXISTS(SponsorSessionAssignment WHERE sessionId=this.id)"
            },
            {
              "name": "minutesOverrun",
              "type": "rollup",
              "description": "How many minutes the session has run past its scheduled endTime, if still in progress.",
              "formula": "IF (CURRENT_TIME > endTime AND isInProgress=true) THEN (TIMEDIFF(CURRENT_TIME, endTime)) ELSE 0"
            },
            {
              "name": "isFull",
              "type": "rollup",
              "description": "True if sessionAttendeeCount >= assigned Room.capacity.",
              "formula": "sessionAttendeeCount >= (SELECT capacity FROM Room WHERE id=roomId)"
            },
            {
              "name": "sessionHasEndedEarly",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if a SessionEndEvent with forcedEndTime < scheduled endTime exists.",
              "formula": "EXISTS(SessionEndEvent WHERE sessionId=this.id AND forcedEndTime < endTime)"
            },
            {
              "name": "actualEndTime",
              "type": "rollup",
              "description": "// NEW INFERENCE: The earliest of endTime or forcedEndTime from SessionEndEvent (if any). Implementation conceptual.",
              "formula": "IF (EXISTS(SessionEndEvent WHERE sessionId=this.id)) THEN MIN(endTime, SessionEndEvent.forcedEndTime) ELSE endTime"
            },
            {
              "name": "speakersPresentNow",
              "type": "rollup",
              "description": "// NEW INFERENCE: Lists speakers if session isInProgress=true. Implementation conceptual.",
              "formula": "IF (isInProgress=true) THEN (speakers) ELSE []"
            }
          ],
          "lambdas": [
            {
              "name": "cancelSession",
              "parameters": [],
              "description": "// DECLARATIVE: Setting isCanceled=true.",
              "formula": "this.isCanceled = true"
            },
            {
              "name": "extendSession",
              "parameters": ["newEndTime"],
              "description": "// DECLARATIVE: If we want to go longer, we set a new endTime fact.",
              "formula": "this.endTime = newEndTime"
            }
          ],
          "constraints": [
            {
              "name": "endAfterStart",
              "formula": "endTime > startTime",
              "error_message": "Session endTime must be later than startTime."
            },
            {
              "name": "roomCapacityNotExceeded",
              "formula": "sessionAttendeeCount <= (SELECT capacity FROM Room WHERE id=roomId)",
              "error_message": "Cannot exceed room capacity for this session."
            },
            {
              "name": "noSpeakerDoubleBooking",
              "formula": "NOT EXISTS( (Session s2 JOIN Speaker sp2) WHERE s2.id != this.id AND sp2 IN this.speakers AND sp2 IN s2.speakers AND s2.isInProgress=true AND this.isInProgress=true )",
              "error_message": "Speaker cannot be in two sessions at once."
            }
          ]
        },
        {
          "name": "Speaker",
          "description": "An individual presenting at one or more sessions in the conference.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for the speaker."
            },
            {
              "name": "conferenceId",
              "type": "lookup",
              "target_entity": "Conference",
              "foreign_key": true,
              "description": "Which conference this speaker belongs to."
            },
            {
              "name": "fullName",
              "type": "scalar",
              "datatype": "string",
              "description": "Speaker’s full name."
            },
            {
              "name": "bio",
              "type": "scalar",
              "datatype": "text",
              "description": "Short biography or background information."
            }
          ],
          "lookups": [
            {
              "name": "sessions",
              "target_entity": "Session",
              "type": "many_to_many",
              "description": "All sessions that this speaker is assigned to."
            }
          ],
          "aggregations": [
            {
              "name": "sessionCount",
              "type": "rollup",
              "description": "Number of sessions in which this speaker is scheduled.",
              "formula": "COUNT(sessions)"
            },
            {
              "name": "sessionsToday",
              "type": "rollup",
              "description": "Number of sessions the speaker has on the current calendar day.",
              "formula": "COUNT(sessions WHERE dayId.dayDate = CURRENT_DATE)"
            },
            {
              "name": "isSpeakingNow",
              "type": "rollup",
              "description": "True if the speaker has at least one session currently in progress.",
              "formula": "EXISTS(sessions WHERE isInProgress=true)"
            },
            {
              "name": "speakerHasOverlappingSessions",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if speaker has any pair of sessions that overlap.",
              "formula": "CHECK_IF_SPEAKER_HAS_OVERLAPS(this.id)"
            },
            {
              "name": "speakerHasConsecutiveSessions",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if the speaker has sessions back-to-back with insufficient buffer time.",
              "formula": "CHECK_CONSECUTIVE_SESSIONS_WITH_BUFFER(this.id)"
            },
            {
              "name": "totalSpeakingMinutes",
              "type": "rollup",
              "description": "// NEW INFERENCE: Sum of sessionDurationMinutes for all sessions assigned to this speaker.",
              "formula": "SUM(sessions.sessionDurationMinutes)"
            }
          ],
          "lambdas": [
            {
              "name": "assignToSession",
              "parameters": ["sessionId"],
              "description": "// DECLARATIVE: Add this speaker to the session’s many-to-many speakers link.",
              "formula": "this.sessions += sessionId"
            }
          ],
          "constraints": []
        },
        {
          "name": "Attendee",
          "description": "Individual attending the conference. Minimal registration details, focusing on presence at sessions and days.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for the attendee."
            },
            {
              "name": "fullName",
              "type": "scalar",
              "datatype": "string",
              "description": "Attendee’s full name."
            }
          ],
          "lookups": [
            {
              "name": "attendeeDayCheckInRecords",
              "target_entity": "AttendeeDayCheckInEvent",
              "type": "one_to_many",
              "join_condition": "AttendeeDayCheckInEvent.attendeeId = this.id",
              "description": "// NEW INFERENCE: All day-level check-ins the attendee has performed."
            }
          ],
          "aggregations": [
            {
              "name": "currentSessionsJoined",
              "type": "rollup",
              "description": "All sessions the attendee is currently checked into (not checked out). Implementation conceptual.",
              "formula": "SessionAttendanceEvent WHERE attendeeId=this.id AND checkOutTime=null => sessionId"
            },
            {
              "name": "isInsideConference",
              "type": "rollup",
              "description": "Indicates if the attendee is physically on-site (per day-level or session-level check-in). Implementation depends on presence of check-in events.",
              "formula": "EXISTS(AttendeeCheckInEvent WHERE attendeeId=this.id AND checkOutTime=null)"
            },
            {
              "name": "attendeeHasFutureSessions",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if attendee has at least one session with startTime > CURRENT_TIME. Implementation conceptual.",
              "formula": "EXISTS(SessionAttendanceEvent WHERE attendeeId=this.id AND Session.startTime > CURRENT_TIME)"
            },
            {
              "name": "attendeeTotalAttendanceTime",
              "type": "rollup",
              "description": "// NEW INFERENCE: Sum of all attendanceDurationMinutes across this attendee’s SessionAttendanceEvents.",
              "formula": "SUM(SessionAttendanceEvent.attendanceDurationMinutes WHERE attendeeId=this.id)"
            },
            {
              "name": "attendeeLastSessionAttended",
              "type": "rollup",
              "description": "// NEW INFERENCE: The most recent session (by checkIn or checkOut) the attendee has attended.",
              "formula": "FIND_MOST_RECENT(SessionAttendanceEvent WHERE attendeeId=this.id => sessionId)"
            }
          ],
          "lambdas": [
            {
              "name": "checkIntoSession",
              "parameters": ["sessionId"],
              "description": "// DECLARATIVE: Checking in means a new SessionAttendanceEvent with checkInTime=NOW.",
              "formula": "SessionAttendanceEvent(attendeeId=this.id, sessionId=sessionId, checkInTime=NOW, checkOutTime=null)"
            }
          ],
          "constraints": []
        },
        {
          "name": "SessionAttendanceEvent",
          "description": "Fact-based record that a specific attendee joined or left a given session.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for this attendance event."
            },
            {
              "name": "sessionId",
              "type": "lookup",
              "target_entity": "Session",
              "foreign_key": true,
              "description": "Which session the attendee is entering or exiting."
            },
            {
              "name": "attendeeId",
              "type": "lookup",
              "target_entity": "Attendee",
              "foreign_key": true,
              "description": "Which attendee is involved in this event."
            },
            {
              "name": "checkInTime",
              "type": "scalar",
              "datatype": "datetime",
              "description": "Timestamp when the attendee arrived. Null if not checked in yet."
            },
            {
              "name": "checkOutTime",
              "type": "scalar",
              "datatype": "datetime",
              "description": "Timestamp when the attendee left. Null if still in session."
            }
          ],
          "lookups": [],
          "aggregations": [
            {
              "name": "attendanceDurationMinutes",
              "type": "rollup",
              "description": "How long the attendee was (or has been) in the session. If checkOutTime is null, partial duration up to now.",
              "formula": "IF (checkOutTime!=null) THEN TIMEDIFF(checkOutTime, checkInTime) ELSE TIMEDIFF(CURRENT_TIME, checkInTime)"
            },
            {
              "name": "isCurrentlyCheckedIn",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if checkOutTime is null and checkInTime != null.",
              "formula": "(checkInTime != null) AND (checkOutTime = null)"
            }
          ],
          "lambdas": [
            {
              "name": "checkOut",
              "parameters": [],
              "description": "// DECLARATIVE: Checking out sets checkOutTime=NOW.",
              "formula": "this.checkOutTime = NOW"
            }
          ],
          "constraints": [
            {
              "name": "mustHaveCheckInBeforeCheckOut",
              "formula": "(checkOutTime IS NULL) OR (checkOutTime >= checkInTime)",
              "error_message": "Cannot check out before you have checked in."
            }
          ]
        },
        {
          "name": "Sponsor",
          "description": "Represents a sponsor for the conference (e.g., a company or organization).",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique identifier for the sponsor."
            },
            {
              "name": "conferenceId",
              "type": "lookup",
              "target_entity": "Conference",
              "foreign_key": true,
              "description": "Which conference this sponsor is associated with."
            },
            {
              "name": "sponsorName",
              "type": "scalar",
              "datatype": "string",
              "description": "Official or brand name of the sponsor."
            },
            {
              "name": "sponsorTier",
              "type": "scalar",
              "datatype": "string",
              "description": "Sponsorship level: e.g., Platinum, Gold, etc."
            }
          ],
          "lookups": [],
          "aggregations": [
            {
              "name": "hasSponsoredSession",
              "type": "rollup",
              "description": "Indicates if the sponsor is attached to any sessions.",
              "formula": "EXISTS(SponsorSessionAssignment WHERE sponsorId=this.id)"
            },
            {
              "name": "assignedBooth",
              "type": "rollup",
              "description": "If the sponsor has an allocated booth space. Implementation conceptual.",
              "formula": "LOOKUP(BoothAssignment WHERE sponsorId=this.id => boothName)"
            },
            {
              "name": "sponsorHasBoothAssignment",
              "type": "rollup",
              "description": "// NEW INFERENCE: True if there's a BoothAssignment record for this sponsor.",
              "formula": "EXISTS(BoothAssignment WHERE sponsorId=this.id)"
            }
          ],
          "lambdas": [],
          "constraints": []
        },
        {
          "name": "SessionEndEvent",
          "description": "Event-based record that forcibly ends a session early (or triggers session completion).",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique event record ID."
            },
            {
              "name": "sessionId",
              "type": "lookup",
              "target_entity": "Session",
              "foreign_key": true,
              "description": "Which session is forcibly ended."
            },
            {
              "name": "endReason",
              "type": "scalar",
              "datatype": "string",
              "description": "Reason for ending: e.g. 'TechnicalIssue','Evacuation','TimeOverrun','SpeakerCancel'."
            },
            {
              "name": "forcedEndTime",
              "type": "scalar",
              "datatype": "datetime",
              "description": "// NEW INFERENCE: Actual time this forced-end event took effect. If earlier than session.endTime, sessionHasEndedEarly is true."
            }
          ],
          "lookups": [],
          "aggregations": [],
          "lambdas": [],
          "constraints": []
        },
        {
          "name": "ConferencePolicy",
          "description": "Represents adjustable rules or global constraints for a conference.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for this policy or rule set."
            },
            {
              "name": "conferenceId",
              "type": "lookup",
              "target_entity": "Conference",
              "foreign_key": true,
              "description": "Which conference these policies apply to."
            },
            {
              "name": "maxSessionLengthMinutes",
              "type": "scalar",
              "datatype": "integer",
              "description": "Upper limit for how long any session can be scheduled (e.g., 180 = 3 hours)."
            },
            {
              "name": "minBreakBetweenSessionsMinutes",
              "type": "scalar",
              "datatype": "integer",
              "description": "Buffer time needed between consecutive sessions in the same room."
            },
            {
              "name": "roomChangeBufferMinutes",
              "type": "scalar",
              "datatype": "integer",
              "description": "Time needed for a speaker to change rooms if they have sessions back-to-back."
            }
          ],
          "lookups": [],
          "aggregations": [
            {
              "name": "requiresSponsorApprovalForKeynotes",
              "type": "rollup",
              "description": "// NEW INFERENCE: If true, any KEYNOTE session must have sponsor sign-off. Implementation conceptual.",
              "formula": "GET_POLICY_VALUE('requiresSponsorApprovalForKeynotes')"
            }
          ],
          "lambdas": [],
          "constraints": [
            {
              "name": "enforceSessionLength",
              "formula": "NOT EXISTS(Session WHERE TIMEDIFF(endTime, startTime) > maxSessionLengthMinutes)",
              "error_message": "No session can exceed the max allowed session length."
            },
            {
              "name": "enforceRoomTurnover",
              "formula": "CHECK_NO_OVERLAP_IN_ROOM_WITHOUT_BUFFER(roomChangeBufferMinutes, minBreakBetweenSessionsMinutes)",
              "error_message": "Sessions in the same room must have at least minBreakBetweenSessionsMinutes gap."
            }
          ]
        },
        {
          "name": "AttendeeDayCheckInEvent",
          "description": "// NEW ENTITY: Tracks an attendee’s day-level presence. Separate from session-level attendance.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for this day-level check-in record."
            },
            {
              "name": "attendeeId",
              "type": "lookup",
              "target_entity": "Attendee",
              "foreign_key": true,
              "description": "Which attendee is checking in or out for a day."
            },
            {
              "name": "dayId",
              "type": "lookup",
              "target_entity": "ConferenceDay",
              "foreign_key": true,
              "description": "Which day this check-in event applies to."
            },
            {
              "name": "checkInTime",
              "type": "scalar",
              "datatype": "datetime",
              "description": "When the attendee arrived for the day. Null if not yet arrived."
            },
            {
              "name": "checkOutTime",
              "type": "scalar",
              "datatype": "datetime",
              "description": "When the attendee left for the day. Null if still on-site."
            }
          ],
          "lookups": [],
          "aggregations": [
            {
              "name": "dayCheckInDurationMinutes",
              "type": "rollup",
              "description": "// NEW INFERENCE: How long the attendee stayed for that day. Implementation conceptual.",
              "formula": "IF (checkOutTime!=null) THEN TIMEDIFF(checkOutTime, checkInTime) ELSE TIMEDIFF(CURRENT_TIME, checkInTime)"
            }
          ],
          "lambdas": [],
          "constraints": [
            {
              "name": "mustCheckInBeforeCheckOut",
              "formula": "(checkOutTime IS NULL) OR (checkOutTime >= checkInTime)",
              "error_message": "Day checkOutTime cannot precede checkInTime."
            }
          ]
        }
      ],
      "data": {
        "Conference": [
          {
            "id": "CONF_THAT_2025",
            "conferenceName": "ThatConference 2025",
            "location": "Wisconsin Dells"
          }
        ],
        "ConferenceDay": [
          {
            "id": "DAY1_CONF_THAT_2025",
            "conferenceId": "CONF_THAT_2025",
            "dayDate": "2025-07-24",
            "startTime": "2025-07-24T08:00:00",
            "endTime": "2025-07-24T18:00:00"
          },
          {
            "id": "DAY2_CONF_THAT_2025",
            "conferenceId": "CONF_THAT_2025",
            "dayDate": "2025-07-25",
            "startTime": "2025-07-25T08:00:00",
            "endTime": "2025-07-25T18:00:00"
          }
        ],
        "Room": [
          {
            "id": "ROOM_MAIN",
            "conferenceId": "CONF_THAT_2025",
            "roomName": "Main Hall",
            "capacity": 300
          },
          {
            "id": "ROOM_BREAKOUT1",
            "conferenceId": "CONF_THAT_2025",
            "roomName": "Breakout Room 1",
            "capacity": 75
          }
        ],
        "Session": [
          {
            "id": "SESSION_KEYNOTE_DAY1",
            "dayId": "DAY1_CONF_THAT_2025",
            "roomId": "ROOM_MAIN",
            "sessionTitle": "Opening Keynote: The Future of Dev",
            "startTime": "2025-07-24T09:00:00",
            "endTime": "2025-07-24T10:00:00",
            "sessionType": "KEYNOTE",
            "isCanceled": false
          },
          {
            "id": "SESSION_WORKSHOP_AI",
            "dayId": "DAY1_CONF_THAT_2025",
            "roomId": "ROOM_BREAKOUT1",
            "sessionTitle": "Hands-On ML Workshop",
            "startTime": "2025-07-24T10:15:00",
            "endTime": "2025-07-24T12:00:00",
            "sessionType": "WORKSHOP",
            "isCanceled": false
          },
          {
            "id": "SESSION_PANEL_DAY2",
            "dayId": "DAY2_CONF_THAT_2025",
            "roomId": "ROOM_MAIN",
            "sessionTitle": "Panel: Open Source in 2025",
            "startTime": "2025-07-25T09:30:00",
            "endTime": "2025-07-25T10:30:00",
            "sessionType": "PANEL",
            "isCanceled": false
          }
        ],
        "Speaker": [
          {
            "id": "SPEAKER_EJ",
            "conferenceId": "CONF_THAT_2025",
            "fullName": "EJ Developer",
            "bio": "Software engineer focusing on open-source communities."
          },
          {
            "id": "SPEAKER_JANE",
            "conferenceId": "CONF_THAT_2025",
            "fullName": "Jane Expert",
            "bio": "ML researcher and workshop instructor."
          }
        ],
        "Attendee": [
          {
            "id": "ATT_1001",
            "fullName": "Chris Conferencegoer"
          },
          {
            "id": "ATT_1002",
            "fullName": "Pat Professional"
          }
        ],
        "SessionAttendanceEvent": [
          {
            "id": "ATT_EVENT_001",
            "sessionId": "SESSION_KEYNOTE_DAY1",
            "attendeeId": "ATT_1001",
            "checkInTime": "2025-07-24T08:58:00",
            "checkOutTime": null
          }
        ],
        "Sponsor": [
          {
            "id": "SPONSOR_PLATINUM_001",
            "conferenceId": "CONF_THAT_2025",
            "sponsorName": "TechGiant",
            "sponsorTier": "Platinum"
          }
        ],
        "SessionEndEvent": [],
        "ConferencePolicy": [
          {
            "id": "POLICY_BASE_2025",
            "conferenceId": "CONF_THAT_2025",
            "maxSessionLengthMinutes": 180,
            "minBreakBetweenSessionsMinutes": 10,
            "roomChangeBufferMinutes": 5
          }
        ],
        "AttendeeDayCheckInEvent": []
      }
    },
    "data": {
      "sampleExtraSessions": [
        {
          "id": "SESSION_LUNCH_DAY1",
          "dayId": "DAY1_CONF_THAT_2025",
          "roomId": "ROOM_MAIN",
          "sessionTitle": "Lunch Break",
          "startTime": "2025-07-24T12:00:00",
          "endTime": "2025-07-24T13:00:00",
          "sessionType": "MEAL",
          "isCanceled": false
        },
        {
          "id": "SESSION_CLOSING_DAY2",
          "dayId": "DAY2_CONF_THAT_2025",
          "roomId": "ROOM_MAIN",
          "sessionTitle": "Closing Remarks",
          "startTime": "2025-07-25T17:00:00",
          "endTime": "2025-07-25T18:00:00",
          "sessionType": "KEYNOTE",
          "isCanceled": false
        }
      ],
      "sampleSpeakerAssignments": [
        {
          "speakerId": "SPEAKER_EJ",
          "sessionId": "SESSION_PANEL_DAY2"
        },
        {
          "speakerId": "SPEAKER_JANE",
          "sessionId": "SESSION_WORKSHOP_AI"
        }
      ],
      "sampleAttendanceActions": [
        {
          "id": "ATT_EVENT_002",
          "sessionId": "SESSION_WORKSHOP_AI",
          "attendeeId": "ATT_1002",
          "checkInTime": "2025-07-24T10:10:00"
        },
        {
          "id": "ATT_EVENT_003",
          "sessionId": "SESSION_WORKSHOP_AI",
          "attendeeId": "ATT_1001",
          "checkInTime": "2025-07-24T10:20:00"
        }
      ]
    },
    "root-meta-model": {
      "title": "The Conceptual Model Completeness Conjecture (CMCC)",
      "subtitle": "A Universal Declarative Computational Framework",
      "authors": [
        {
          "name": "EJ Alexandra",
          "contact": "start@anabstractlevel.com",
          "affiliations": ["SSoT.me", "EffortlessAPI.com"]
        }
      ],
      "date": "March 2025",
      "abstract": "Applying CMCC to conferences and then extending it with new inferences reveals the ease of purely declarative expansions. All new logic—peak capacity usage, advanced checks on speakers/attendees, or day-level check-ins—is done by aggregator fields, constraints, or new events, never by imperative commands.",
      "executive_summary": {
        "key_points": [
          "Follows a purely declarative expansions principle—no code rewriting needed for new domain logic.",
          "25 new inferences illustrate typical, real-world expansions (sponsor rules, day check-ins, advanced concurrency checks)."
        ],
        "implications": [
          "Event management is even more robust, covering daily check-in or forced session ends in real-time through data facts alone.",
          "Any domain rule or aggregator can be added without changing the fundamental structure."
        ],
        "narrative": {
          "sections": [
            {
              "title": "Extended Model Overview",
              "content": [
                "These 25 new inferences demonstrate how a purely declarative system is easily scaled. By adding new aggregator fields, constraints, and even a new entity (AttendeeDayCheckInEvent), we capture more nuance without resorting to any procedural logic. The domain remains consistent with the CMCC's notion that the data plus aggregator logic define the 'truth' at all times."
              ]
            }
          ]
        }
      },
      "CMCC_ToEMM_Domain_List": [
        {
          "id": "CMCC_ToEMM_Baseball",
          "fullname": "Baseball ToE Meta-Model",
          "name": "Baseball ToE Meta-Model",
          "description": "A structured model capturing the domain of baseball, purely declarative—teams, players, games, innings, at-bats, and stats.",
          "nickname": "baseball"
        },
        {
          "id": "CMCC_ToEMM_Conferencing",
          "fullname": "Conference ToE Meta-Model",
          "name": "Conference ToE Meta-Model",
          "description": "Structured model capturing day-to-day session management in a purely declarative style.",
          "nickname": "conferencing"
        },
        {
          "id": "CMCC_ToEMM_Math",
          "fullname": "Mathematics ToE Meta-Model",
          "name": "Mathematics ToE Meta-Model",
          "description": "A structured model covering foundational mathematics, including sets, functions, and category theory.",
          "nickname": "math"
        },
        {
          "id": "CMCC_ToEMM_Physics",
          "fullname": "Physics ToE Meta-Model",
          "name": "Physics ToE Meta-Model",
          "description": "A unified model for physics, including quantum mechanics, gauge fields, wavefunctions, relativity, and black hole dynamics.",
          "nickname": "physics"
        },
        {
          "id": "CMCC_ToEMM_Biology",
          "fullname": "Biology ToE Meta-Model",
          "name": "Biology ToE Meta-Model",
          "description": "Extends the Chemistry & Physics TOEs for biological systems, from genes to proteins and higher-level organisms.",
          "nickname": "biology"
        }
      ]
    }
  }
}
