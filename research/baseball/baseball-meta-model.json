{
  "id": "CMCC_ToEMM_Baseball",
  "meta-model": {
    "name": "Baseball ToE Meta Model",
    "description": "A unified meta-model capturing the entire domain of baseball—teams, players, games, innings, stats, and rules—within a purely declarative structure. All domain logic—like scoring, outs, pitch outcomes, lineups, or statistics—are expressed using lookups, aggregations, constraints, and event-based facts—no imperative instructions.",
    "version": "v1.2",
    "nickname": "baseball",
    "meta": {
      "title": "Baseball ToE Meta-Model",
      "subtitle": "A 100% Declarative Framework for the Sport's Structures and Rules",
      "authors": [
        {
          "name": "EJ Alexandra",
          "contact": "start@anabstractlevel.com",
          "affiliations": ["SSoT.me", "EffortlessAPI.com"]
        }
      ],
      "date": "March 2025",
      "abstract": "The Baseball extension of the CMCC (Conceptual Model Completeness Conjecture) systematically represents baseball’s core objects—Teams, Players, Games, Innings, At-Bats—under a single Snapshot-Consistent schema. We’ve rewritten the entire specification to be 100% declarative, replacing stepwise imperative logic with event-based or aggregator-based facts. Everything from run scoring, outs, pitch results, and roster assignments is specified as constraints, lookups, aggregator fields, or derived booleans—ensuring that the model is purely descriptive. No domain logic is expressed as do-this-then-do-that instructions.",
      "executive_summary": {
        "key_points": [
          "Models baseball’s entire rule structure—teams, rosters, innings, batting orders, stats—declaratively with aggregator formulas, event-based facts, and constraints.",
          "Eliminates the need for any imperative code blocks or specialized DSL instructions.",
          "Demonstrates flexibility for advanced sabermetrics, tying directly into this purely factual data structure.",
          "Seamlessly integrates with other CMCC domains (e.g., economics or sociology) for cross-domain synergy."
        ],
        "implications": [
          "Provides a universal environment for capturing baseball rules in a purely fact-based manner.",
          "Greatly simplifies or eliminates stateful code, since all logic is derived from the presence/absence of events or stated data.",
          "Supports advanced analytics—once in the data, aggregator fields can unify everything from pitch-level detail to multi-season advanced metrics."
        ],
        "narrative": [
          {
            "title": "Purely Declarative Baseball Extension",
            "content": [
              "In this version, we removed all imperative instructions (e.g., 'increment outs', 'set status') and replaced them with aggregator fields or constraints referencing new event entities or pre-existing relationships. For instance, an InningHalf’s outs are now simply the count of 'OutEvent' records referencing that half-inning. A game is 'in progress' if certain conditions in the data hold (status='IN_PROGRESS' AND we haven't reached final conditions). No procedure calls are needed to change states; the data itself drives the logic. This architecture helps ensure the system remains consistent and transparent: any change to the data is automatically reflected in the aggregator fields, with no hidden or procedural steps to update them."
            ]
          }
        ]
      }
    },
    "schema": {
      "entities": [
        {
          "name": "League",
          "description": "Represents an organized group of baseball teams playing under the same rule set. Could be MLB, minor leagues, or an amateur league.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique identifier for the league."
            },
            {
              "name": "leagueName",
              "type": "scalar",
              "datatype": "string",
              "description": "The official or common name of the league."
            }
          ],
          "lookups": [
            {
              "name": "teams",
              "target_entity": "Team",
              "type": "one_to_many",
              "join_condition": "Team.league_id = this.id",
              "description": "Collection of Teams belonging to this league."
            }
          ],
          "aggregations": [
            {
              "name": "teamCount",
              "type": "rollup",
              "formula": "COUNT(teams)",
              "description": "Number of teams in this league."
            },
            {
              "name": "totalGamesPlayed",
              "type": "rollup",
              "description": "Sum of all Games completed by all Teams in the league. Implementation conceptual, scanning each team's 'gamesPlayed'.",
              "formula": "SUM(teams.gamesPlayed)"
            },
            {
              "name": "bestTeam",
              "type": "rollup",
              "description": "The team with the highest win percentage in this league (declarative aggregator).",
              "formula": "MAXBY(teams, t => t.winPercentage)"
            },
            {
              "name": "worstTeam",
              "type": "rollup",
              "description": "The team with the lowest win percentage in this league (declarative aggregator).",
              "formula": "MINBY(teams, t => t.winPercentage)"
            },
            {
              "name": "averageTeamERA",
              "type": "rollup",
              "description": "The average ERA across all teams in this league. Implementation conceptual, could sum or average pitchers’ ERA or overall team ERA.",
              "formula": "AVG(teams -> eachTeamERA)"
            },
            {
              "name": "totalLeagueHomeRuns",
              "type": "rollup",
              "description": "The sum of all home runs hit by players on all teams in this league, purely data-based aggregator.",
              "formula": "SUM(teams.roster -> careerHomeRuns)"
            },
            {
              "name": "totalLeagueStolenBases",
              "type": "rollup",
              "description": "The sum of all stolen bases by players on all teams in this league.",
              "formula": "SUM(teams.roster -> careerStolenBases)"
            }
          ],
          "lambdas": [
            {
              "name": "scheduleMatchups",
              "parameters": [],
              "description": "// CHANGED (DECLARATIVE): Instead of 'create' schedules, we declare that a 'ScheduledMatchup' entity must exist for each pair of teams. Implementation conceptual.",
              "formula": "ALL_PAIRINGS(teams) => SHOULD_HAVE_ScheduledMatchup"
            }
          ],
          "constraints": []
        },
        {
          "name": "Team",
          "description": "A baseball team. Belongs to one League, has a roster of Players, and competes in Games.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique identifier for the team."
            },
            {
              "name": "teamName",
              "type": "scalar",
              "datatype": "string",
              "description": "Name or nickname of the team."
            },
            {
              "name": "league_id",
              "type": "lookup",
              "target_entity": "League",
              "foreign_key": true,
              "description": "Indicates which League this team belongs to."
            }
          ],
          "lookups": [
            {
              "name": "roster",
              "target_entity": "Player",
              "type": "one_to_many",
              "join_condition": "Player.team_id = this.id",
              "description": "All players currently on the team."
            }
          ],
          "aggregations": [
            {
              "name": "rosterSize",
              "type": "rollup",
              "formula": "COUNT(roster)",
              "description": "Number of players on the team's active roster."
            },
            {
              "name": "gamesPlayed",
              "type": "rollup",
              "description": "Number of Games in which this team has participated (data-based aggregator).",
              "formula": "COUNT(Game where (homeTeamId=this.id OR awayTeamId=this.id))"
            },
            {
              "name": "wins",
              "type": "rollup",
              "description": "Count of Games this team has won (pure aggregator, no imperative updates).",
              "formula": "COUNT(Game where (winnerId=this.id))"
            },
            {
              "name": "losses",
              "type": "rollup",
              "description": "Count of Games this team has lost.",
              "formula": "COUNT(Game where (loserId=this.id))"
            },
            {
              "name": "winPercentage",
              "type": "rollup",
              "description": "wins / (wins + losses), if any games played. Null otherwise.",
              "formula": "IF (gamesPlayed>0) THEN (wins / gamesPlayed) ELSE null"
            },
            {
              "name": "averageTeamBattingAverage",
              "type": "rollup",
              "description": "The average batting average among all players on the roster, purely aggregator.",
              "formula": "AVG(roster.careerBattingAverage)"
            },
            {
              "name": "totalTeamRuns",
              "type": "rollup",
              "description": "Total runs scored by this team (across all games). Implementation conceptual.",
              "formula": "SUM(GameInnings where offense=this.id => runsScored )"
            },
            {
              "name": "totalTeamHomeRuns",
              "type": "rollup",
              "description": "Sum of home runs hit by all players on this team.",
              "formula": "SUM(roster -> careerHomeRuns)"
            },
            {
              "name": "totalTeamStolenBases",
              "type": "rollup",
              "description": "Sum of stolen bases by all players on this team.",
              "formula": "SUM(roster -> careerStolenBases)"
            },
            {
              "name": "averageFieldingPercentage",
              "type": "rollup",
              "description": "The team’s overall fielding percentage, averaging all players’ fielding percentages who actively field.",
              "formula": "AVG(roster -> careerFieldingPercentage )"
            },
            {
              "name": "winningPercentageInStadium",
              "type": "rollup",
              "description": "Team’s historical winning percentage in a given stadium—pure aggregator referencing stadium-based game data.",
              "formula": "WIN_PCT_BY_STADIUM_FUNCTION(this.id)"
            }
          ],
          "lambdas": [
            {
              "name": "addPlayerToRoster",
              "parameters": ["player_id"],
              "description": "// CHANGED (DECLARATIVE): Instead of 'Set Player.team_id = ...', we state a constraint/fact: 'Player.team_id' should match 'this.id'.",
              "formula": "Player(team_id=player_id).team_id == this.id"
            },
            {
              "name": "removePlayerFromRoster",
              "parameters": ["player_id"],
              "description": "// CHANGED (DECLARATIVE): In a purely declarative sense, removing means 'player.team_id = null' is a valid state. No imperative steps.",
              "formula": "Player(player_id).team_id == null"
            }
          ],
          "constraints": []
        },
        {
          "name": "Player",
          "description": "An individual who participates in baseball games, either as a position player, pitcher, or both.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique identifier for the player."
            },
            {
              "name": "fullName",
              "type": "scalar",
              "datatype": "string",
              "description": "Player's full name."
            },
            {
              "name": "battingHand",
              "type": "scalar",
              "datatype": "string",
              "description": "Indicates 'L', 'R', or 'S' (switch)."
            },
            {
              "name": "throwingHand",
              "type": "scalar",
              "datatype": "string",
              "description": "Indicates 'L' or 'R'."
            },
            {
              "name": "team_id",
              "type": "lookup",
              "target_entity": "Team",
              "foreign_key": true,
              "description": "Which Team this player is currently on, if any."
            }
          ],
          "lookups": [
            {
              "name": "defensivePositions",
              "target_entity": "DefensivePosition",
              "type": "many_to_many",
              "description": "All possible defensive positions the player can handle. Implementation: PlayerPosition join table or similar."
            }
          ],
          "aggregations": [
            {
              "name": "careerAtBats",
              "type": "rollup",
              "formula": "COUNT( AtBat where (batterId=this.id) )",
              "description": "How many official at-bats the player has had across all games."
            },
            {
              "name": "careerHits",
              "type": "rollup",
              "description": "How many hits the player has recorded across all at-bats.",
              "formula": "COUNT( AtBat where (batterId=this.id AND result in ['SINGLE','DOUBLE','TRIPLE','HOMERUN']) )"
            },
            {
              "name": "careerBattingAverage",
              "type": "rollup",
              "description": "(careerHits / careerAtBats). Null if no at-bats.",
              "formula": "IF (careerAtBats>0) THEN (careerHits / careerAtBats) ELSE null"
            },
            {
              "name": "careerPitchCount",
              "type": "rollup",
              "description": "Total number of pitches thrown by this player, if a pitcher.",
              "formula": "COUNT( Pitch where (pitcherId=this.id) )"
            },
            {
              "name": "careerStrikeoutsPitched",
              "type": "rollup",
              "description": "How many strikeouts the player (as pitcher) has recorded.",
              "formula": "COUNT( AtBat where (pitcherId=this.id AND result='STRIKEOUT') )"
            },
            {
              "name": "careerInningsPitched",
              "type": "rollup",
              "description": "Summation of partial innings if the player is a pitcher. Implementation conceptual.",
              "formula": "AccumulateInningsFromOuts( sum_of_outs_where_pitcherId=this.id )"
            },
            {
              "name": "onBasePercentage",
              "type": "rollup",
              "description": "OBP = (H + BB + HBP) / (AB + BB + HBP + SF). Implementation conceptual if advanced data is tracked.",
              "formula": "IF (plateAppearances>0) THEN ((careerHits + careerWalks + careerHitByPitch) / (careerAtBats + careerWalks + careerHitByPitch + careerSacFlies)) ELSE null"
            },
            {
              "name": "sluggingPercentage",
              "type": "rollup",
              "description": "Total bases / at-bats. Implementation conceptual if we track 2B,3B,HR, etc.",
              "formula": "IF (careerAtBats>0) THEN (sumOfTotalBases / careerAtBats) ELSE null"
            },
            {
              "name": "ops",
              "type": "rollup",
              "description": "On-base plus slugging, purely aggregator of the OBP + SLG fields.",
              "formula": "onBasePercentage + sluggingPercentage"
            },
            {
              "name": "stolenBasePercentage",
              "type": "rollup",
              "description": "stolenBases / (stolenBases + caughtStealing). Implementation conceptual if we track that data.",
              "formula": "IF ((careerStolenBases + careerCaughtStealing) > 0) THEN (careerStolenBases / (careerStolenBases + careerCaughtStealing)) ELSE null"
            },
            {
              "name": "isTwoWayPlayer",
              "type": "rollup",
              "description": "Boolean indicating if the player has pitched and also batted as a regular hitter. Implementation conceptual.",
              "formula": "IF (careerInningsPitched > 0 AND careerAtBats > 0) THEN true ELSE false"
            }
          ],
          "lambdas": [
            {
              "name": "adjustBattingHand",
              "parameters": ["newHand"],
              "description": "// CHANGED (DECLARATIVE): Instead of imperative 'Set battingHand=newHand', we declare a constraint that the player's battingHand must match 'newHand'.",
              "formula": "this.battingHand == newHand"
            }
          ],
          "constraints": []
        },
        {
          "name": "DefensivePosition",
          "description": "A position on the baseball field, e.g. pitcher (1), catcher (2), shortstop (6), etc.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for the position (often '1','2','3','4','5','6','7','8','9' or 'DH')."
            },
            {
              "name": "positionName",
              "type": "scalar",
              "datatype": "string",
              "description": "Descriptive name (Pitcher, Catcher, Shortstop, etc.)."
            }
          ],
          "lookups": [],
          "aggregations": [],
          "lambdas": [],
          "constraints": []
        },
        {
          "name": "Game",
          "description": "Represents a single baseball game between two Teams, split into innings (top & bottom).",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique identifier for the game."
            },
            {
              "name": "homeTeamId",
              "type": "lookup",
              "target_entity": "Team",
              "foreign_key": false,
              "description": "Which team is playing at home."
            },
            {
              "name": "awayTeamId",
              "type": "lookup",
              "target_entity": "Team",
              "foreign_key": false,
              "description": "Which team is visiting."
            },
            {
              "name": "status",
              "type": "scalar",
              "datatype": "string",
              "description": "Game status: e.g. 'SCHEDULED','IN_PROGRESS','FINAL'."
            }
          ],
          "lookups": [
            {
              "name": "innings",
              "target_entity": "Inning",
              "type": "one_to_many",
              "join_condition": "Inning.gameId = this.id",
              "description": "All Inning records associated with this Game."
            }
          ],
          "aggregations": [
            {
              "name": "currentInningNumber",
              "type": "rollup",
              "description": "Highest inningNumber in innings that have started or are in progress.",
              "formula": "IF innings != null THEN MAX(innings.inningNumber) ELSE null"
            },
            {
              "name": "runsHome",
              "type": "rollup",
              "description": "Total runs scored by the home team, summing relevant half-innings for the home offense.",
              "formula": "SUM( InningHalf.runsScored for all bottomHalves with offensiveTeamId=homeTeamId )"
            },
            {
              "name": "runsAway",
              "type": "rollup",
              "description": "Total runs scored by the away team, summing relevant half-innings for the away offense.",
              "formula": "SUM( InningHalf.runsScored for all topHalves with offensiveTeamId=awayTeamId )"
            },
            {
              "name": "winnerId",
              "type": "rollup",
              "description": "If status='FINAL', whichever team has more runs. Null if tie or incomplete.",
              "formula": "IF (status='FINAL') THEN (IF runsHome>runsAway THEN homeTeamId ELSE IF runsAway>runsHome THEN awayTeamId ELSE null) ELSE null"
            },
            {
              "name": "loserId",
              "type": "rollup",
              "description": "Symmetric aggregator to winnerId; identifies losing team if final and not tied.",
              "formula": "IF status='FINAL' AND runsHome!=runsAway THEN (IF winnerId=homeTeamId THEN awayTeamId ELSE homeTeamId) ELSE null"
            },
            {
              "name": "totalPitchesInGame",
              "type": "rollup",
              "description": "Total number of pitches thrown in this game (pure aggregator across all at-bats).",
              "formula": "COUNT( Pitch where pitch.atBatId.inningHalfId.inningId.gameId=this.id )"
            },
            {
              "name": "hasWalkOffOpportunity",
              "type": "rollup",
              "description": "True if it's bottom of 9th+ with the home team trailing/tied so a scoring play could end the game. Implementation conceptual, purely declarative.",
              "formula": "EVALUATE_WALKOFF_CONDITION(this.id)"
            }
          ],
          "lambdas": [
            {
              "name": "startGame",
              "parameters": [],
              "description": "// CHANGED (DECLARATIVE): Instead of setting 'status=IN_PROGRESS', we define a constraint: if the game has begun, status must be 'IN_PROGRESS'.",
              "formula": "IF (EXISTS(any pitch or any top inning started)) THEN (this.status == 'IN_PROGRESS')"
            },
            {
              "name": "endGame",
              "parameters": [],
              "description": "// CHANGED (DECLARATIVE): Instead of setting 'status=FINAL', we define conditions for final. If 9+ innings done, runs differ, status must be 'FINAL'.",
              "formula": "IF (CONDITIONS_FOR_GAME_COMPLETION) THEN (this.status == 'FINAL')"
            }
          ],
          "constraints": [
            {
              "name": "teamMismatch",
              "formula": "homeTeamId != awayTeamId",
              "error_message": "Home and away team cannot be the same."
            }
          ]
        },
        {
          "name": "Inning",
          "description": "A single inning in the game, typically has a top and bottom half unless extras are needed.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for this inning record."
            },
            {
              "name": "gameId",
              "type": "lookup",
              "target_entity": "Game",
              "foreign_key": true,
              "description": "Which game this inning belongs to."
            },
            {
              "name": "inningNumber",
              "type": "scalar",
              "datatype": "integer",
              "description": "Which inning number (1..9, or extras)."
            }
          ],
          "lookups": [
            {
              "name": "top",
              "target_entity": "InningHalf",
              "type": "one_to_one",
              "description": "The top half of this inning, if defined."
            },
            {
              "name": "bottom",
              "target_entity": "InningHalf",
              "type": "one_to_one",
              "description": "The bottom half of this inning, if defined."
            }
          ],
          "aggregations": [
            {
              "name": "isComplete",
              "type": "rollup",
              "description": "True if top and bottom half are both complete, or if there's a walk-off scenario that ends the inning early.",
              "formula": "top.isComplete AND (bottom==null OR bottom.isComplete)"
            }
          ],
          "lambdas": [],
          "constraints": []
        },
        {
          "name": "InningHalf",
          "description": "Represents either top or bottom portion of an inning, with outs, runs, at-bats, etc. All purely event/aggregator based.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for this half-inning record."
            },
            {
              "name": "halfType",
              "type": "scalar",
              "datatype": "string",
              "description": "TOP or BOTTOM."
            },
            {
              "name": "offensiveTeamId",
              "type": "lookup",
              "target_entity": "Team",
              "foreign_key": false,
              "description": "Which team is batting."
            },
            {
              "name": "defensiveTeamId",
              "type": "lookup",
              "target_entity": "Team",
              "foreign_key": false,
              "description": "Which team is in the field."
            },
            {
              "name": "outs",
              "type": "scalar",
              "datatype": "integer",
              "description": "Number of outs recorded so far. // CHANGED (DECLARATIVE) We keep this as a 'field' but treat it as an aggregator from OutEvents."
            },
            {
              "name": "runsScored",
              "type": "scalar",
              "datatype": "integer",
              "description": "Tally of runs in this half-inning. // CHANGED (DECLARATIVE) Treated as aggregator from RunEvents or from sum of AtBat.rbi."
            },
            {
              "name": "isComplete",
              "type": "scalar",
              "datatype": "boolean",
              "description": "True if 3 outs are reached or walk-off ends this half. // CHANGED (DECLARATIVE) We interpret as aggregator or constraint."
            }
          ],
          "lookups": [
            {
              "name": "atBats",
              "target_entity": "AtBat",
              "type": "one_to_many",
              "join_condition": "AtBat.inningHalfId = this.id",
              "description": "All plate appearances in this half-inning."
            }
          ],
          "aggregations": [
            {
              "name": "battersFaced",
              "type": "rollup",
              "description": "Number of batters who came up to the plate (size of atBats).",
              "formula": "COUNT(atBats)"
            },
            {
              "name": "hitsInHalf",
              "type": "rollup",
              "description": "How many hits (1B,2B,3B,HR) occurred in this half.",
              "formula": "COUNT( AtBat where (inningHalfId=this.id AND result in ['SINGLE','DOUBLE','TRIPLE','HOMERUN']) )"
            },
            {
              "name": "leftOnBase",
              "type": "rollup",
              "description": "How many baserunners remained stranded when the half-inning ended. Implementation conceptual, purely aggregator over base-runner state.",
              "formula": "CALCULATE_STRANDED_RUNNERS(this.id)"
            }
          ],
          "lambdas": [
            {
              "name": "recordOut",
              "parameters": [],
              "description": "// CHANGED (DECLARATIVE): Instead of incrementing outs, we define an 'OutEvent' entity. 'outs' aggregator = COUNT(OutEvent).",
              "formula": "InningHalf.outs = COUNT(OutEvent where outEvent.inningHalfId=this.id)"
            },
            {
              "name": "scoreRun",
              "parameters": ["count"],
              "description": "// CHANGED (DECLARATIVE): Instead of incrementing runs, a 'RunEvent' entity or sum of AtBat.rbi. 'runsScored' aggregator = SUM(RunEvent.runs).",
              "formula": "InningHalf.runsScored = SUM(RunEvent where runEvent.inningHalfId=this.id => runEvent.runCount)"
            }
          ],
          "constraints": [
            {
              "name": "validOutCount",
              "formula": "outs >= 0 AND outs <= 3",
              "error_message": "Outs must be between 0 and 3 inclusive."
            },
            {
              "name": "isCompleteWhen3OutsOrWalkoff",
              "formula": "isComplete == ((outs >= 3) OR (CHECK_WALKOFF_CONDITION(this.id)))",
              "error_message": "Half-inning completes with 3 outs or a declared walk-off event."
            }
          ]
        },
        {
          "name": "AtBat",
          "description": "A single plate appearance, from the start of the batter's turn to its final result. All logic is aggregator-based, no step-by-step updates.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for this at-bat record."
            },
            {
              "name": "inningHalfId",
              "type": "lookup",
              "target_entity": "InningHalf",
              "foreign_key": true,
              "description": "Which half-inning this at-bat belongs to."
            },
            {
              "name": "batterId",
              "type": "lookup",
              "target_entity": "Player",
              "foreign_key": false,
              "description": "Player who is batting."
            },
            {
              "name": "pitcherId",
              "type": "lookup",
              "target_entity": "Player",
              "foreign_key": false,
              "description": "Player (pitcher) on defense facing the batter."
            },
            {
              "name": "result",
              "type": "scalar",
              "datatype": "string",
              "description": "Outcome: e.g. 'SINGLE','DOUBLE','TRIPLE','HOMERUN','WALK','STRIKEOUT','GROUNDOUT','FLYOUT','HIT_BY_PITCH', etc."
            },
            {
              "name": "rbi",
              "type": "scalar",
              "datatype": "integer",
              "description": "Number of runs batted in on this at-bat (0..4)."
            }
          ],
          "lookups": [
            {
              "name": "pitches",
              "target_entity": "Pitch",
              "type": "one_to_many",
              "join_condition": "Pitch.atBatId = this.id",
              "description": "All Pitch records thrown in this at-bat."
            }
          ],
          "aggregations": [
            {
              "name": "pitchCountInAtBat",
              "type": "rollup",
              "description": "Number of pitches thrown in this at-bat.",
              "formula": "COUNT(pitches)"
            },
            {
              "name": "fouls",
              "type": "rollup",
              "description": "Number of foul pitches among 'pitches'.",
              "formula": "COUNT( Pitch where (atBatId=this.id AND pitchResult='FOUL') )"
            },
            {
              "name": "expectedBattingAverage",
              "type": "rollup",
              "description": "A sabermetric measure (xBA) based on exit velocity, launch angle, etc. Implementation conceptual, purely aggregator.",
              "formula": "SABERMETRIC_xBA_FORMULA(this.id)"
            }
          ],
          "lambdas": [
            {
              "name": "addPitch",
              "parameters": ["pitchData"],
              "description": "// CHANGED (DECLARATIVE): Instead of 'INSERT' pitch, we declare that all pitch entities referencing this atBatId belong to 'pitches'.",
              "formula": "Pitch.atBatId == this.id => belongs to 'pitches' collection"
            },
            {
              "name": "finalizeAtBat",
              "parameters": [],
              "description": "// CHANGED (DECLARATIVE): No step to 'lock in' result. We have a constraint: AtBat is complete if 'result' is one of the final states. No imperative update needed.",
              "formula": "AtBatIsComplete(this.id) == (this.result != null)"
            }
          ],
          "constraints": []
        },
        {
          "name": "Pitch",
          "description": "Represents a single pitch thrown in an at-bat. Tracks velocity, location, outcome, etc., with no imperative instructions.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for this pitch record."
            },
            {
              "name": "atBatId",
              "type": "lookup",
              "target_entity": "AtBat",
              "foreign_key": true,
              "description": "Which at-bat this pitch belongs to."
            },
            {
              "name": "pitchResult",
              "type": "scalar",
              "datatype": "string",
              "description": "One of 'BALL','CALLED_STRIKE','SWINGING_STRIKE','FOUL','IN_PLAY','HIT_BY_PITCH', etc."
            },
            {
              "name": "pitchVelocity",
              "type": "scalar",
              "datatype": "number",
              "description": "Speed of the pitch, typically in mph or km/h."
            },
            {
              "name": "pitchSpinRate",
              "type": "scalar",
              "datatype": "number",
              "description": "Spin rate of the pitch in revolutions per minute (rpm)."
            }
          ],
          "lookups": [],
          "aggregations": [],
          "lambdas": [],
          "constraints": []
        },
        {
          "name": "Statistic",
          "description": "Generic or specialized statistical measures referencing a Player, Team, or entire league. Could store advanced sabermetrics or simpler metrics.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for this stat record."
            },
            {
              "name": "entityType",
              "type": "scalar",
              "datatype": "string",
              "description": "Indicates whether this stat applies to 'Player','Team','League'."
            },
            {
              "name": "entityId",
              "type": "lookup",
              "target_entity": "*",
              "foreign_key": false,
              "description": "ID of the specific entity (player/team/league) to which the stat belongs. Implementation conceptual."
            },
            {
              "name": "statName",
              "type": "scalar",
              "datatype": "string",
              "description": "E.g. 'OPS','ERA','WAR','fieldingPercentage'."
            },
            {
              "name": "statValue",
              "type": "scalar",
              "datatype": "number",
              "description": "Numeric result of the stat calculation."
            },
            {
              "name": "season",
              "type": "scalar",
              "datatype": "string",
              "description": "Optional label for which season or time period this stat references."
            },
            {
              "name": "lastUpdated",
              "type": "scalar",
              "datatype": "datetime",
              "description": "Timestamp indicating when this stat was last updated."
            }
          ],
          "lookups": [],
          "aggregations": [],
          "lambdas": [],
          "constraints": []
        },
        {
          "name": "Stadium",
          "description": "Represents a ballpark or stadium where games are played. Purely declarative references to capacity, location, etc.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique ID for this stadium."
            },
            {
              "name": "stadiumName",
              "type": "scalar",
              "datatype": "string",
              "description": "The official or common name of the stadium."
            },
            {
              "name": "capacity",
              "type": "scalar",
              "datatype": "integer",
              "description": "Maximum seating capacity of the stadium."
            }
          ],
          "lookups": [],
          "aggregations": [
            {
              "name": "gamesPlayedInStadium",
              "type": "rollup",
              "description": "Number of games that have taken place in this stadium. Implementation conceptual, would require a link from Game to Stadium.",
              "formula": "COUNT(Game where Game.stadiumId = this.id)"
            },
            {
              "name": "averageAttendance",
              "type": "rollup",
              "description": "Average attendance across all games played here. Implementation conceptual.",
              "formula": "AVG(GameAttendanceRecords where stadiumId=this.id)"
            }
          ],
          "lambdas": [],
          "constraints": []
        },
        {
          "name": "OutEvent",
          "description": "// NEW: Fact-based approach for recording outs. Each OutEvent references which half-inning or at-bat triggered the out. Eliminates imperative increments.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique out event record."
            },
            {
              "name": "inningHalfId",
              "type": "lookup",
              "target_entity": "InningHalf",
              "foreign_key": true,
              "description": "Which half-inning this out belongs to."
            },
            {
              "name": "atBatId",
              "type": "lookup",
              "target_entity": "AtBat",
              "foreign_key": true,
              "description": "Optional reference to which at-bat caused the out. Could be null if it's a pickoff or baserunning out."
            }
          ],
          "lookups": [],
          "aggregations": [],
          "lambdas": [],
          "constraints": []
        },
        {
          "name": "RunEvent",
          "description": "// NEW: Fact-based approach for runs. Each RunEvent references which half-inning or at-bat triggered a run, ensuring no imperative 'scoreRun()'.",
          "fields": [
            {
              "name": "id",
              "type": "scalar",
              "datatype": "string",
              "primary_key": true,
              "description": "Unique run event record."
            },
            {
              "name": "inningHalfId",
              "type": "lookup",
              "target_entity": "InningHalf",
              "foreign_key": true,
              "description": "Which half-inning this run belongs to."
            },
            {
              "name": "atBatId",
              "type": "lookup",
              "target_entity": "AtBat",
              "foreign_key": true,
              "description": "Optional reference to the at-bat that batted in the run. Could be null if it’s a wild pitch, error, etc."
            },
            {
              "name": "runCount",
              "type": "scalar",
              "datatype": "integer",
              "description": "How many runs scored on this event (often 1, but could be more if multiple runners score simultaneously)."
            }
          ],
          "lookups": [],
          "aggregations": [],
          "lambdas": [],
          "constraints": []
        }
      ]
    },
    "data": {
      "League": [
        {
          "id": "league_MLB",
          "leagueName": "Major League Baseball"
        }
      ],
      "Team": [
        {
          "id": "team_NYY",
          "teamName": "Yankees",
          "league_id": "league_MLB"
        },
        {
          "id": "team_BOS",
          "teamName": "Red Sox",
          "league_id": "league_MLB"
        }
      ],
      "Player": [
        {
          "id": "player_101",
          "fullName": "John Pitcher",
          "battingHand": "R",
          "throwingHand": "R",
          "team_id": "team_NYY"
        },
        {
          "id": "player_102",
          "fullName": "Mike Slugger",
          "battingHand": "L",
          "throwingHand": "R",
          "team_id": "team_BOS"
        }
      ],
      "DefensivePosition": [
        {
          "id": "1",
          "positionName": "Pitcher"
        },
        {
          "id": "2",
          "positionName": "Catcher"
        },
        {
          "id": "6",
          "positionName": "Shortstop"
        },
        {
          "id": "DH",
          "positionName": "Designated Hitter"
        }
      ],
      "Game": [
        {
          "id": "game_2025_03_13",
          "homeTeamId": "team_NYY",
          "awayTeamId": "team_BOS",
          "status": "SCHEDULED"
        }
      ],
      "Inning": [],
      "InningHalf": [],
      "AtBat": [],
      "Pitch": [],
      "Statistic": [
        {
          "id": "stat_001",
          "entityType": "Player",
          "entityId": "player_101",
          "statName": "ERA",
          "statValue": 3.45,
          "season": "2025",
          "lastUpdated": "2025-03-01T10:00:00Z"
        },
        {
          "id": "stat_002",
          "entityType": "Player",
          "entityId": "player_102",
          "statName": "BattingAverage",
          "statValue": 0.285,
          "season": "2025",
          "lastUpdated": "2025-03-02T14:30:00Z"
        }
      ],
      "Stadium": [
        {
          "id": "stadium_001",
          "stadiumName": "Yankee Stadium",
          "capacity": 50000
        }
      ],
      "OutEvent": [],
      "RunEvent": []
    },

    "root-meta-model": {
      "title": "The Conceptual Model Completeness Conjecture (CMCC)",
      "subtitle": "A Universal Declarative Computational Framework",
      "authors": [
        {
          "name": "EJ Alexandra",
          "contact": "start@anabstractlevel.com",
          "affiliations": ["SSoT.me", "EffortlessAPI.com"]
        }
      ],
      "date": "January 2025",
      "abstract": "The Conceptual Model Completeness Conjecture (CMCC) posits that the declarative semantics of any conceptual model can be captured using five fundamental primitives—Schema (S), Data (D), Lookups (L), Aggregations (A), and Lambda Calculated Fields (F)—within an Snapshot-Consistent environment. This updated baseball model exemplifies how all domain logic can be expressed purely as constraints, aggregator fields, or relationships, removing all imperative steps.",
      "executive_summary": {
        "key_points": [
          "Demonstrates how to remove imperative step-by-step logic and convert it to data-driven or aggregator-driven facts.",
          "Proves the feasibility of purely declarative baseball rules, from runs to outs to final game states.",
          "Illustrates how new entities like OutEvent and RunEvent can remove the need for explicit 'recordOut()' or 'scoreRun()' calls."
        ],
        "implications": [
          "Potential unification of domain modeling under a purely fact-based approach, cutting out mutable, stepwise logic.",
          "Data changes automatically reflect in aggregator fields, ensuring consistency at all times with no update commands.",
          "Enables advanced simulation, analytics, or knowledge-graph queries in any environment supporting declarative rule evaluation."
        ],
        "narrative": {
          "sections": [
            {
              "title": "Executive Summary",
              "content": [
                "The pivot from partial-imperative to purely declarative removes the last bits of 'if-then-do-something' logic. All game states—outs, runs, or game completion—are determined by the presence of event records and aggregator formulas. We introduced entities like OutEvent and RunEvent for outs and runs, so that at any time, the system can see 'outs=3' or 'runs>opponentRuns' and derive that an inning/game is finished. No imperative instruction is needed to 'increment' or 'set' these values; they follow naturally from the underlying event data.",
                "This approach underscores the power of the CMCC framework (S, D, L, A, F). The domain structure is expressed via the schema (S), actual values or events appear in the data (D), references or relationships are lookups (L), aggregator fields (A) compute rollups or derived states, and lambda fields (F) can define purely functional or constraint-based logic. The entire baseball domain logic emerges from these relationships—no custom code is required to orchestrate state transitions."
              ]
            }
          ]
        }
      },
      "CMCC_ToEMM_Domain_List": [
        {
          "id": "CMCC_ToEMM_Baseball",
          "fullname": "Baseball ToE Meta-Model",
          "name": "Baseball ToE Meta-Model",
          "description": "A structured model capturing the domain of baseball, including leagues, teams, players, games, innings, at-bats, and stats, in a 100% declarative style.",
          "nickname": "baseball"
        },
        {
          "id": "CMCC_ToEMM_Math",
          "fullname": "Mathematics ToE Meta-Model",
          "name": "Mathematics ToE Meta-Model",
          "description": "A structured model covering foundational mathematics, including sets, functions, proofs, structures, and category theory.",
          "nickname": "math"
        },
        {
          "id": "CMCC_ToEMM_Physics",
          "fullname": "Physics ToE Meta-Model",
          "name": "Physics ToE Meta-Model",
          "description": "A unified model for physics, including classical mechanics, quantum mechanics, gauge fields, wavefunctions, relativity, and black hole dynamics.",
          "nickname": "physics"
        },
        {
          "id": "CMCC_ToEMM_Chemistry",
          "fullname": "Chemistry ToE Meta-Model",
          "name": "Chemistry ToE Meta-Model",
          "description": "Extends the Physics TOE with atomic structures, molecular interactions, bonds, and chemical reactions.",
          "nickname": "chemistry"
        },
        {
          "id": "CMCC_ToEMM_Biology",
          "fullname": "Biology ToE Meta-Model",
          "name": "Biology ToE Meta-Model",
          "description": "Bridges Chemistry and Physics TOEs to model biological systems, including genes, proteins, metabolism, and cellular structures.",
          "nickname": "biology"
        },
        {
          "id": "CMCC_ToEMM_AI",
          "fullname": "Artificial Intelligence ToE Meta-Model",
          "name": "Artificial Intelligence ToE Meta-Model",
          "description": "Encapsulates machine learning, neural networks, training datasets, reinforcement learning, and inference mechanisms.",
          "nickname": "ai"
        },
        {
          "id": "CMCC_ToEMM_Economics",
          "fullname": "Economics ToE Meta-Model",
          "name": "Economics ToE Meta-Model",
          "description": "A computational model for economic agents, markets, transactions, and supply-demand constraints.",
          "nickname": "economics"
        },
        {
          "id": "CMCC_ToEMM_Astronomy",
          "fullname": "Astronomy ToE Meta-Model",
          "name": "Astronomy ToE Meta-Model",
          "description": "An extension of the Physics TOE to model celestial bodies, star systems, orbital dynamics, and large-scale cosmic structures.",
          "nickname": "astronomy"
        },
        {
          "id": "CMCC_ToEMM_Geology",
          "fullname": "Geology oE Meta-Model",
          "name": "Geology",
          "description": "A model integrating physics and chemistry to represent minerals, rock formations, and tectonic processes.",
          "nickname": "geology"
        },
        {
          "id": "CMCC_ToEMM_Medicine",
          "fullname": "Medicine and Healthcare ToE Meta-Model",
          "name": "Medicine & Healthcare ToE Meta-Model",
          "description": "A unified model capturing foundational aspects of medicine and healthcare, including patient records, clinical trial data, treatment plans, and analytics.",
          "nickname": "medicine"
        },
        {
          "id": "CMCC_ToEMM_Legal",
          "fullname": "Legal Systems & Compliance ToE Meta-Model",
          "name": "Legal Systems & Compliance ToE Meta-Model",
          "description": "A unified model for legal systems, contracts, statutory frameworks, and regulatory compliance.",
          "nickname": "legal"
        },
        {
          "id": "CMCC_ToEMM_Climate",
          "fullname": "Climate Science and Environmental Modeling ToE Meta-Model",
          "name": "Climate Science ToE Meta-Model",
          "description": "A unified model for climate science and environmental modeling, capturing climate variables, ecosystems, pollution sources, and environmental data.",
          "nickname": "climate"
        },
        {
          "id": "CMCC_ToEMM_Cybersecurity",
          "fullname": "Cybersecurity ToE Meta-Model",
          "name": "Cybersecurity ToE Meta-Model",
          "description": "A unified model for cybersecurity covering threat models, vulnerabilities, IT asset mappings, incident logs, and security audits.",
          "nickname": "cybersecurity"
        },
        {
          "id": "CMCC_ToEMM_Sociology",
          "fullname": "Sociology and Anthropology ToE Meta-Model",
          "name": "Sociology & Anthropology ToE Meta-Model",
          "description": "A structured model capturing social structures, cultural norms, and interaction networks using survey data, demographic records, and social network relationships.",
          "nickname": "sociology"
        }
      ]
    }
  }
}