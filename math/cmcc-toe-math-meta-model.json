{
    "id": "CMCC_ToEMM_Math",    
    "meta-model": {
  "name": "CMCC Complete Mathematics TOE Meta Model",
  "description": "A unified meta-model capturing foundational mathematics (sets, elements, functions, algebraic structures, category theory, propositions, equations, etc.) in a single Snapshot-Consistent, declarative structure. All domain logic—like group axioms, function composition, theorem proofs—are expressed using lookups, aggregations, lambdas, and constraints.",
  "version": "v2.05",
  "nickname": "math",
  "meta": {
    "title": "CMCC Complete Mathematics ToE Meta-Model",
    "subtitle": "A Unified Declarative Framework for Abstract Structures, Axioms, and Proofs",
    "authors": [
      {
        "name": "EJ Alexandra",
        "contact": "start@anabstractlevel.com",
        "affiliations": [
          "SSoT.me",
          "EffortlessAPI.com"
        ]
      }
    ],
    "date": "March 2025",
    "abstract": "The Mathematics extension of the CMCC (Conceptual Model Completeness Conjecture) systematically represents abstract mathematical concepts—sets, elements, functions, propositions, equations, algebraic structures—under a single Snapshot-Consistent schema. Using five foundational primitives (S, D, L, A, F), it captures axioms, proofs, and domain relationships (e.g., group axioms, ring axioms, function surjectivity) in a purely declarative format, enabling cross-domain synergy with physics, chemistry, and beyond.",
    "executive_summary": {
      "key_points": [
        "Models foundational mathematics (sets, elements, structures, proofs) declaratively, through aggregator formulas and constraints.",
        "Eliminates the need for domain-specific programming languages or proof scripts by storing the 'what' (the rules) as first-class data.",
        "Demonstrates Turing-completeness via lambda-calculus–style aggregator functions and references to universal computational models.",
        "Seamlessly integrates with other CMCC domains (e.g., physics, chemistry) to unify advanced mathematics with real-world applications."
      ],
      "implications": [
        "Provides a universal environment for exploring proofs, theorems, and algebraic structures alongside other domains’ data.",
        "Supports flexible expansions—add new aggregator-based axioms or constraints without needing specialized theorem-proving code.",
        "Facilitates knowledge-sharing: once an axiom or proof is declared, other domains can reference it for consistent cross-domain logic."
      ],
      "narrative": [
        {
          "title": "CMCC Mathematics Extension",
          "content": [
            "Mathematics is famously broad, encompassing everything from the basics of set theory and arithmetic to higher structures like rings, fields, categories, and beyond. Traditional approaches involve specialized notations, proof assistants, or programming languages, often siloed from one another.",
            "In contrast, the CMCC Mathematics Model encodes these concepts within a single, self-describing schema. Each 'Set,' 'Element,' or 'Proposition' is a record in an Snapshot-Consistent datastore, with domain logic (axioms, aggregator checks for commutativity or associativity, etc.) expressed as formulas. Proofs become derivation steps, re-usable by other theorems or even other domain models (like the CMCC Physics or Chemistry models).",
            "By remaining purely declarative, this approach decouples syntax from semantics. Whether capturing something simple like the geometry of triangles or something advanced like category theory, the math extension inherits the same fundamental building blocks (S, D, L, A, F) that drive the entire CMCC framework. This ensures the utmost consistency, reusability, and cross-domain synergy in your knowledge representation."
          ]
        }
      ]
    }
  },
  "schema": {
    "entities": [
      {
        "name": "Set",
        "description": "A fundamental collection of mathematical objects. Includes properties like countability, cardinality, discrete/continuous classification, plus aggregator fields to compute subsets or check emptiness.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for this set."
          },
          {
            "name": "name",
            "type": "scalar",
            "datatype": "string",
            "description": "Optional symbolic name, e.g. 'ℕ', 'ℤ', 'A', etc."
          },
          {
            "name": "description",
            "type": "scalar",
            "datatype": "string",
            "description": "Free-text remarks about the nature of this set."
          },
          {
            "name": "countable",
            "type": "scalar",
            "datatype": "boolean",
            "description": "Indicates if the set is countably infinite or finite vs. uncountable."
          },
          {
            "name": "cardinality",
            "type": "scalar",
            "datatype": "string",
            "description": "Human-friendly cardinality label, e.g. 'finite', 'aleph_0', 'c', etc."
          },
          {
            "name": "discrete_or_continuous",
            "type": "scalar",
            "datatype": "string",
            "description": "Classification, e.g. 'discrete', 'continuous', or 'mixed'."
          },
          {
            "name": "parent_set_id",
            "type": "lookup",
            "target_entity": "Set",
            "foreign_key": false,
            "description": "Reference to a 'superset' or 'universe set' containing this set. Null if no parent."
          },
          {
            "name": "construction_rule",
            "type": "scalar",
            "datatype": "json",
            "description": "Optional JSON describing how this set is constructed, e.g. an inductive definition."
          }
        ],
        "lookups": [
          {
            "name": "elements",
            "target_entity": "Element",
            "type": "one_to_many",
            "join_condition": "Element.containing_set_id = this.id",
            "description": "All Element records that belong to this set."
          }
        ],
        "aggregations": [
          {
            "name": "is_empty",
            "type": "rollup",
            "formula": "COUNT(elements) = 0",
            "description": "True if this set has zero elements."
          },
          {
            "name": "is_finite",
            "type": "rollup",
            "formula": "countable AND cardinality != 'aleph_0'",
            "description": "Naive aggregator: if set is labeled countable but not infinite, treat as finite."
          },
          {
            "name": "cardinality_estimate",
            "type": "rollup",
            "formula": "IF is_finite THEN COUNT(elements) ELSE '∞ (or as specified by cardinality)'",
            "description": "Gives a naive numeric count if finite, else refers to cardinality field for infinite sets."
          },
          {
            "name": "min_element",
            "type": "rollup",
            "description": "Finds the minimum element if a strict ordering is known. Null if not found or no order defined.",
            "formula": "IF (some ordering is declared) THEN pick e in elements s.t. ∀x in elements, e <= x, else null"
          },
          {
            "name": "has_min_element",
            "type": "rollup",
            "description": "Checks if there is a well-defined minimum element among 'elements'.",
            "formula": "IF (min_element != null) THEN true ELSE false"
          },
          {
            "name": "has_max_element",
            "type": "rollup",
            "description": "Checks if there is a well-defined maximum element among 'elements'.",
            "formula": "IF (some ordering is declared AND an element e s.t. ∀x in elements: x ≤ e) THEN true ELSE false"
          },
          {
            "name": "sum_of_elements",
            "type": "rollup",
            "description": "If numeric, returns the sum of all elements. Null if non-numeric or infinite.",
            "formula": "IF (all e in elements are numeric) THEN SUM(elements.value) ELSE null"
          },
          {
            "name": "is_subset_of_integers",
            "type": "rollup",
            "description": "True if every element of this set is also in the 'integers' set. Null if 'integers' not found.",
            "formula": "IF LOOKUP('integers') != null THEN FOR ALL e in this.elements => e IN LOOKUP('integers').elements ELSE null"
          },
          {
            "name": "singleton_check",
            "type": "rollup",
            "description": "Checks if the set has exactly one element.",
            "formula": "COUNT(elements) = 1"
          },
          {
            "name": "average_of_elements",
            "type": "rollup",
            "description": "If numeric elements exist, returns the average. Null otherwise.",
            "formula": "IF (all e in elements are numeric) THEN AVERAGE(elements.value) ELSE null"
          },
          {
            "name": "supremum",
            "type": "rollup",
            "description": "For an ordered set, attempts to find the least upper bound among elements, or null if not well-defined.",
            "formula": "FindSupremum(elements)"
          },
          {
            "name": "power_set_size",
            "type": "rollup",
            "description": "Number of all subsets, i.e. 2^n if the set is finite with n elements.",
            "formula": "IF (is_finite) THEN POWER(2, COUNT(elements)) ELSE null"
          },
          {
            "name": "infimum",
            "type": "rollup",
            "description": "Least element or lower bound if numeric. Returns null if not well-defined or set is empty.",
            "formula": "ComputeInfimum(elements)"
          },
          {
            "name": "largest_element",
            "type": "rollup",
            "description": "Returns the maximum element if an order is declared and a maximum exists, otherwise null.",
            "formula": "IF (some ordering is declared) THEN MaxElement(elements) ELSE null"
          },
          {
            "name": "finite_subset_count",
            "type": "rollup",
            "description": "Same as power_set_size for a finite set. If infinite, returns null.",
            "formula": "IF (is_finite) THEN POWER(2, COUNT(elements)) ELSE null"
          },
          {
            "name": "count_of_even_elements",
            "type": "rollup",
            "description": "Counts how many elements are even integers, if numeric.",
            "formula": "IF all e in elements are integers THEN COUNT(e where e.value % 2 = 0) ELSE null"
          },
          {
            "name": "contains_only_positive_numbers",
            "type": "rollup",
            "description": "Checks if every numeric element in the set is > 0.",
            "formula": "IF all e in elements are numeric THEN (FOR ALL e in elements => e.value > 0) ELSE null"
          },
          {
            "name": "lowest_common_multiple",
            "type": "rollup",
            "description": "Computes LCM of all positive integers in the set, if applicable.",
            "formula": "IF all e in elements are positive integers THEN LCM(elements.value) ELSE null"
          },
          {
            "name": "contains_only_primes",
            "type": "rollup",
            "description": "True if every element in this set is a prime integer. Null if non-integer or empty.",
            "formula": "IF (all e in elements are integers) THEN (FOR ALL e in elements => isPrime(e.value)) ELSE null"
          },
          {
            "name": "max_gap_between_consecutive_elements",
            "type": "rollup",
            "description": "For a sorted set of integers, computes the largest difference between consecutive elements. Null if non-integer or empty.",
            "formula": "IF (all e in elements are integers) THEN (MAX( consecutiveDifferences(sorted(elements.value)) )) ELSE null"
          },
          {
            "name": "sum_of_squares",
            "type": "rollup",
            "description": "Sums the squares of each numeric element, or null if any element is non-numeric.",
            "formula": "IF (all e in elements are numeric) THEN SUM( e.value^2 for e in elements ) ELSE null"
          },
          {
            "name": "gcd_of_elements",
            "type": "rollup",
            "description": "Computes the GCD of all integer elements, or null if non-integer or empty.",
            "formula": "IF (all e in elements are integers AND COUNT(elements) > 0) THEN GCD(elements.value) ELSE null"
          },
          {
            "name": "standard_deviation",
            "type": "rollup",
            "description": "Sample standard deviation of numeric elements. Null if not numeric or too few elements.",
            "formula": "IF (all e in elements are numeric AND COUNT(elements) > 1) THEN ComputeStdDev(elements.value) ELSE null"
          },
          {
            "name": "closure_under_addition",
            "type": "rollup",
            "description": "Checks if for all x,y in the set, x + y is still in the set. Implementation conceptual; references a known addition operator if relevant.",
            "formula": "CheckClosureOverAddition(this.id)"
          },
          {
            "name": "accumulation_point_count",
            "type": "rollup",
            "description": "If subset of reals, attempts to count how many distinct accumulation points. Null otherwise.",
            "formula": "IF (discrete_or_continuous='continuous' OR all e in elements are real) THEN CountAccumulationPoints(elements) ELSE null"
          },
          {
            "name": "lowest_negative_element",
            "type": "rollup",
            "description": "Finds the minimum among negative elements if the set is numeric and has negative values.",
            "formula": "IF (all e in elements are numeric) THEN MIN(e in elements WHERE e.value < 0) ELSE null"
          },
          {
            "name": "contains_rational_numbers",
            "type": "rollup",
            "description": "Checks if every numeric element is a rational number (p/q). Returns null if set is non-numeric or empty.",
            "formula": "IF (all e in elements are numeric) THEN (FOR ALL e in elements => isRational(e.value)) ELSE null"
          },
          {
            "name": "contains_square_numbers_only",
            "type": "rollup",
            "description": "True if every integer element is a perfect square, false if any element is a non-square, null if non-integer or empty.",
            "formula": "IF (all e in elements are integers AND COUNT(elements) > 0) THEN (FOR ALL e in elements => isPerfectSquare(e.value)) ELSE null"
          },
          {
            "name": "has_primitive_root",
            "type": "rollup",
            "description": "For sets referencing modular arithmetic, checks if a generator (primitive root) exists. Conceptual, returns boolean/null.",
            "formula": "CheckPrimitiveRootExists(this.id)"
          }
        ],
        "lambdas": [
          {
            "name": "subset",
            "parameters": [
              "predicate"
            ],
            "description": "Returns a new set of the elements that satisfy the given predicate. E.g. 'x => x>0'.",
            "formula": "CreateSet( elements.filter(e => evaluate(predicate,e)) )"
          },
          {
            "name": "power_set",
            "parameters": [],
            "description": "Generates the power set (the set of all subsets). Implementation is conceptual, but declared here as a lambda.",
            "formula": "GenerateAllSubsets(this)"
          },
          {
            "name": "intersection",
            "parameters": [
              "other_set_id"
            ],
            "description": "Computes the set of Elements that are present in both sets (this and other_set).",
            "formula": "CreateSet( elements.filter(e => e IN LOOKUP(other_set_id).elements ) )"
          },
          {
            "name": "cartesian_product",
            "parameters": [
              "other_set_id"
            ],
            "description": "Returns the cartesian product of this set with another set. Implementation is conceptual.",
            "formula": "GenerateCartesianProduct(this.elements, LOOKUP(other_set_id).elements)"
          },
          {
            "name": "union",
            "parameters": [
              "other_set_id"
            ],
            "description": "Computes the union of this set with another set, returning a new set record or reference.",
            "formula": "CreateSet( DISTINCT( elements ∪ LOOKUP(other_set_id).elements ) )"
          },
          {
            "name": "difference",
            "parameters": [
              "other_set_id"
            ],
            "description": "All elements that are in this set but not in the other. Returns a new set reference.",
            "formula": "CreateSet( elements.filter(e => e NOT IN LOOKUP(other_set_id).elements) )"
          },
          {
            "name": "random_element",
            "parameters": [],
            "description": "Selects one element uniformly at random from the set, if the set is nonempty and sampling is supported.",
            "formula": "PickRandom(elements)"
          },
          {
            "name": "random_subset",
            "parameters": [],
            "description": "Selects a random subset of this set. Implementation conceptual, often requires random sampling from elements.",
            "formula": "GenerateRandomSubset(this.elements)"
          }
        ],
        "constraints": [
          {
            "name": "valid_cardinality",
            "formula": "cardinality IN ['finite','aleph_0','aleph_1','c','etc']",
            "error_message": "Unrecognized cardinality specification"
          }
        ]
      },
      {
        "name": "Element",
        "description": "An atomic or composite member of a Set. Can reference structured or raw data in 'value'.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for the element record."
          },
          {
            "name": "containing_set_id",
            "type": "lookup",
            "target_entity": "Set",
            "foreign_key": true,
            "description": "Points to which Set this element belongs."
          },
          {
            "name": "value_type",
            "type": "scalar",
            "datatype": "string",
            "description": "E.g. 'int','float','symbol','structured' to track what the element represents."
          },
          {
            "name": "value",
            "type": "scalar",
            "datatype": "json",
            "description": "Raw or structured representation of the element content. Possibly references a numeric or symbolic form."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "index_in_set",
            "type": "rollup",
            "formula": "RankWithin(containing_set_id.elements, this.id)",
            "description": "An optional aggregator to position the element within the set’s ordering (if any). If no ordering, returns null."
          },
          {
            "name": "is_positive",
            "type": "rollup",
            "description": "Checks if this element’s numeric value is > 0, if containing_set_id is integers/reals.",
            "formula": "IF (containing_set_id in [\"integers\",\"reals\"]) THEN (value > 0) ELSE null"
          },
          {
            "name": "absolute_value",
            "type": "rollup",
            "description": "If numeric, returns |value|. Otherwise null.",
            "formula": "IF (value_type in [\"int\",\"float\"]) THEN ABS(value) ELSE null"
          },
          {
            "name": "is_zero_element",
            "type": "rollup",
            "description": "Checks if this element is 0, for numeric types.",
            "formula": "IF value_type in ['int','float'] THEN (value == 0) ELSE null"
          },
          {
            "name": "negation",
            "type": "rollup",
            "description": "Returns the additive inverse if numeric, else null.",
            "formula": "IF value_type in ['int','float'] THEN (-value) ELSE null"
          },
          {
            "name": "prime_factorization",
            "type": "rollup",
            "description": "Returns prime factors of an integer, or null otherwise.",
            "formula": "IF value_type='int' THEN FactorInteger(value) ELSE null"
          },
          {
            "name": "is_prime",
            "type": "rollup",
            "description": "Checks if this element’s value is prime (only valid for int).",
            "formula": "IF (value_type='int') THEN CheckPrimality(value) ELSE null"
          },
          {
            "name": "digit_sum",
            "type": "rollup",
            "description": "Sum of the decimal digits if this element is an integer.",
            "formula": "IF (value_type='int') THEN SumOfDigits(value) ELSE null"
          },
          {
            "name": "count_of_distinct_prime_factors",
            "type": "rollup",
            "description": "Number of distinct prime factors if value_type='int'. Null otherwise.",
            "formula": "IF (value_type='int') THEN LENGTH(UNIQUE(PrimeFactorization(value))) ELSE null"
          },
          {
            "name": "complex_conjugate",
            "type": "rollup",
            "description": "If the element is a complex number, return its conjugate. Null if real-only or not complex.",
            "formula": "IF (value_type='complex') THEN Conjugate(value) ELSE null"
          }
        ],
        "lambdas": [],
        "constraints": []
      },
      {
        "name": "ArithmeticOperator",
        "description": "Represents a standard arithmetic operator (+, -, *, /, ^) with optional domain/codomain. Could also store matrix or group ops.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for this operator record."
          },
          {
            "name": "symbol",
            "type": "scalar",
            "datatype": "string",
            "description": "E.g. '+','-','*','/','^'."
          },
          {
            "name": "domain_set_id",
            "type": "lookup",
            "target_entity": "Set",
            "foreign_key": false,
            "description": "Optional reference to the set in which this operator is defined."
          },
          {
            "name": "codomain_set_id",
            "type": "lookup",
            "target_entity": "Set",
            "foreign_key": false,
            "description": "Optional reference to the set into which the operator maps results."
          },
          {
            "name": "description",
            "type": "scalar",
            "datatype": "string",
            "description": "Free-text about usage or constraints, e.g. 'addition on real numbers'."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "is_commutative",
            "type": "rollup",
            "description": "Indicates if the operator is commutative over its domain set. E.g. '+' on ℤ => true, '-' => false.",
            "formula": "CheckPairwiseCommutativity(symbol, domain_set_id)"
          },
          {
            "name": "is_associative",
            "type": "rollup",
            "description": "Checks if (a op b) op c = a op (b op c) for all a,b,c in domain_set_id, ignoring domain/codomain if not numeric.",
            "formula": "CheckPairwiseAssociativity(symbol, domain_set_id)"
          },
          {
            "name": "neutral_element",
            "type": "rollup",
            "description": "Finds e in domain_set_id such that e op x = x op e = x for all x, or returns null if none.",
            "formula": "SearchForIdentityElement(symbol, domain_set_id)"
          },
          {
            "name": "neutral_element_exists",
            "type": "rollup",
            "description": "Simpler variant checking if any identity element is found in the domain.",
            "formula": "IF neutral_element != null THEN true ELSE false"
          },
          {
            "name": "is_bounded",
            "type": "rollup",
            "description": "Checks if the operator yields outputs within a certain range for all inputs in domain_set_id. Implementation is conceptual.",
            "formula": "CheckBoundedness(symbol, domain_set_id)"
          },
          {
            "name": "is_idempotent",
            "type": "rollup",
            "description": "Verifies x op x = x for all x in the domain.",
            "formula": "CheckIdempotency(symbol, domain_set_id)"
          },
          {
            "name": "absorbing_element",
            "type": "rollup",
            "description": "Finds an element a such that a op x = a for all x in domain_set_id. Returns the element or null if none.",
            "formula": "FindAbsorbingElement(symbol, domain_set_id)"
          },
          {
            "name": "is_left_invertible",
            "type": "rollup",
            "description": "True if for every x in domain, ∃y s.t. y op x = identity. Implementation conceptual.",
            "formula": "CheckLeftInvertibility(symbol, domain_set_id)"
          },
          {
            "name": "closed_under_operator",
            "type": "rollup",
            "description": "Verifies that x op y remains in the domain for all x,y.",
            "formula": "FOR ALL x,y in domain_set_id => (x op y) in domain_set_id"
          },
          {
            "name": "range_in_domain",
            "type": "rollup",
            "description": "Constructs the set of {x op y | x,y in domain} and checks subset. Implementation conceptual.",
            "formula": "CreateSetOfOperationResults(symbol, domain_set_id)"
          },
          {
            "name": "exponentiation_table",
            "type": "rollup",
            "description": "If the domain is finite and operator is multiplication, enumerates x^y for x,y in domain. Null otherwise.",
            "formula": "IF (symbol='*' AND domain_set_id.is_finite) THEN BuildExponentTable(domain_set_id) ELSE null"
          },
          {
            "name": "is_associated_operator",
            "type": "rollup",
            "description": "Checks if this operator is recognized as the official operation in a referencing AlgebraicStructure record.",
            "formula": "ScanAlgebraicStructuresForOperator(this.id)"
          },
          {
            "name": "closure_under_operator_with_identity",
            "type": "rollup",
            "description": "Verifies closure plus presence of identity in domain_set_id for this operator. Returns bool or null.",
            "formula": "IF (CheckClosure(domain_set_id, symbol) AND FindIdentityElement(domain_set_id, symbol) != null) THEN true ELSE false"
          }
        ],
        "lambdas": [
          {
            "name": "restrict_operator_domain",
            "parameters": [
              "subset_set_id"
            ],
            "description": "Returns a new ArithmeticOperator record referencing a subset of the domain for which this operator is well-defined.",
            "formula": "CreateRestrictedOperator(this.id, subset_set_id)"
          }
        ],
        "constraints": []
      },
      {
        "name": "Proposition",
        "aggregations": [
          {
            "name": "all_dependencies_proven",
            "type": "rollup",
            "description": "Looks at 'depends_on' array. Returns true if each referenced Proposition is_proven == true.",
            "formula": "For each p in depends_on => p.is_proven => must be true. If all true => this aggregator= true."
          }
        ]
      },
      {
        "name": "Function",
        "description": "A mapping from a domain Set to a codomain Set. Fields to store rule definitions, aggregator checks for injectivity, surjectivity, etc.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for the function."
          },
          {
            "name": "name",
            "type": "scalar",
            "datatype": "string",
            "description": "Human-friendly label for the function, e.g. 'f' or 'sin'."
          },
          {
            "name": "domain_set_id",
            "type": "lookup",
            "target_entity": "Set",
            "foreign_key": true,
            "description": "Which set is the domain of this function."
          },
          {
            "name": "codomain_set_id",
            "type": "lookup",
            "target_entity": "Set",
            "foreign_key": true,
            "description": "Which set is the codomain for outputs."
          },
          {
            "name": "rule",
            "type": "scalar",
            "datatype": "json",
            "description": "Representation of how function maps inputs to outputs, e.g. a formula or a table."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "is_injective",
            "type": "rollup",
            "formula": "CheckInjectivity(rule)",
            "description": "Aggregator that determines if f(x1)=f(x2) => x1=x2 by scanning the rule or partial table."
          },
          {
            "name": "is_surjective",
            "type": "rollup",
            "formula": "CheckSurjectivity(rule,codomain_set_id)",
            "description": "Determines if the function’s range covers the entire codomain."
          },
          {
            "name": "is_bijective",
            "type": "rollup",
            "formula": "is_injective AND is_surjective",
            "description": "True if aggregator sees both injectivity and surjectivity."
          },
          {
            "name": "periodicity_check",
            "type": "rollup",
            "formula": "DetectIfExistsPeriod(rule, domain_set_id)",
            "description": "Indicates if there’s a smallest positive period p. E.g. for sin(x), p=2π. If none, returns null."
          },
          {
            "name": "is_total",
            "type": "rollup",
            "description": "Checks if the function is defined for every element in its domain set. If any missing mapping => false.",
            "formula": "Scan domain_set_id.elements => all have a mapped output in rule => true, else false"
          },
          {
            "name": "fixed_points",
            "type": "rollup",
            "description": "All elements x in the domain for which f(x) = x.",
            "formula": "FOR ALL x in domain_set_id.elements => if (ApplyRule(rule, x) = x) then collect x"
          },
          {
            "name": "image_set",
            "type": "rollup",
            "description": "The set of all distinct outputs in the codomain that f maps to.",
            "formula": "CreateSet( domain_set_id.elements.map(x => ApplyRule(rule,x)) )"
          },
          {
            "name": "surjectivity_ratio",
            "type": "rollup",
            "description": "Ratio of how many elements in the codomain are actually hit by f, over total codomain size if finite.",
            "formula": "IF (codomain_set_id.is_finite) THEN (COUNT(DISTINCT image_set) / COUNT(codomain_set_id.elements)) ELSE null"
          },
          {
            "name": "non_trivial_preimages_count",
            "type": "rollup",
            "description": "Count how many distinct output values have more than one input mapping to them.",
            "formula": "ComputeNumberOfOutputValuesWithMultiples(domain_set_id, rule)"
          },
          {
            "name": "coimage_set",
            "type": "rollup",
            "description": "Groups domain elements by their mapped output to create the coimage structure.",
            "formula": "ConstructCoimage(domain_set_id, rule)"
          },
          {
            "name": "rank",
            "type": "rollup",
            "description": "If finite domain/codomain, rank is the size of the image. Else null.",
            "formula": "IF (domain_set_id.is_finite AND codomain_set_id.is_finite) THEN COUNT(DISTINCT domain_set_id.elements.map(e => ApplyRule(rule,e))) ELSE null"
          },
          {
            "name": "max_fiber_size",
            "type": "rollup",
            "description": "Returns the largest cardinality among all preimages for a single codomain value.",
            "formula": "ComputeMaxPreimageSize(domain_set_id, rule)"
          },
          {
            "name": "injectivity_violations_list",
            "type": "rollup",
            "description": "All pairs (x1,x2) with x1 != x2 but f(x1) = f(x2).",
            "formula": "GatherInjectivityViolations(rule, domain_set_id)"
          },
          {
            "name": "antiderivative_check",
            "type": "rollup",
            "description": "If domain is real, tries symbolic integration and returns indefinite integral if possible.",
            "formula": "IF domain_set_id = 'reals' THEN AttemptSymbolicAntiderivative(rule) ELSE null"
          },
          {
            "name": "codomain_coverage_percentage",
            "type": "rollup",
            "description": "If codomain is finite, computes (|image_set| / |codomain|)*100.",
            "formula": "IF codomain_set_id.is_finite THEN (COUNT(DISTINCT image_set) / COUNT(codomain_set_id.elements)) * 100 ELSE null"
          },
          {
            "name": "limit_at_infinity",
            "type": "rollup",
            "description": "Attempts to evaluate lim(x→∞) of f(x) if domain is unbounded real. Returns numeric or symbolic result.",
            "formula": "IF (domain_set_id = 'reals') THEN EvaluateLimitAtInfinity(rule) ELSE null"
          },
          {
            "name": "derivative_expression",
            "type": "rollup",
            "description": "Symbolic derivative if domain is real and f is differentiable. Returns expression or null.",
            "formula": "IF (domain_set_id = 'reals') THEN DifferentiateExpression(rule) ELSE null"
          },
          {
            "name": "is_monotonic",
            "type": "rollup",
            "description": "Checks if f is strictly increasing, strictly decreasing, or neither, over real domain.",
            "formula": "IF (domain_set_id = 'reals') THEN CheckMonotonicity(rule) ELSE null"
          },
          {
            "name": "function_table",
            "type": "rollup",
            "description": "If domain is finite, returns a table mapping each input to its output.",
            "formula": "IF (domain_set_id.is_finite) THEN ConstructFunctionTable(domain_set_id.elements, rule) ELSE null"
          },
          {
            "name": "bounded_function_check",
            "type": "rollup",
            "description": "For real-valued f: domain->ℝ, checks if |f(x)| ≤ M < ∞ for all x. Null if not numeric or domain infinite.",
            "formula": "IF (domain_set_id='reals') THEN CheckFunctionBoundedness(rule) ELSE null"
          },
          {
            "name": "superadditive_check",
            "type": "rollup",
            "description": "If numeric, checks f(x+y) ≥ f(x) + f(y). Implementation conceptual. Returns bool or null.",
            "formula": "IF (domain_set_id='reals') THEN CheckSuperadditivity(rule) ELSE null"
          }
        ],
        "lambdas": [
          {
            "name": "compose",
            "parameters": [
              "other_function_id"
            ],
            "description": "Returns a new function that is composition of this function with other_function. 'this' is applied after other_function or vice versa.",
            "formula": "ComposeRules(this.rule, LOOKUP(other_function_id).rule)"
          },
          {
            "name": "inverse",
            "parameters": [],
            "description": "If the function is bijective, returns a new function that inverts the rule. Else null.",
            "formula": "IF is_bijective THEN InvertRule(rule) ELSE null"
          },
          {
            "name": "restrict_domain",
            "parameters": [
              "subset_set_id"
            ],
            "description": "Returns a partial function restricted to a subset of the original domain.",
            "formula": "CreateNewFunction( domain=subset_set_id, codomain=codomain_set_id, rule=rule restricted to that subset )"
          },
          {
            "name": "fiber_over_value",
            "parameters": [
              "target_value"
            ],
            "description": "Returns all x in domain such that f(x) = target_value.",
            "formula": "domain_set_id.elements.filter(x => ApplyRule(rule,x) = target_value)"
          },
          {
            "name": "compose_self",
            "parameters": [],
            "description": "Returns a new function that is f∘f if codomain and domain match.",
            "formula": "IF (domain_set_id = codomain_set_id) THEN ComposeRules(rule, rule) ELSE null"
          },
          {
            "name": "partial_eval",
            "parameters": [
              "subset_domain_id"
            ],
            "description": "Restricts the function’s application to a specified subset of the domain, returning a partial mapping object.",
            "formula": "CreateNewFunction( domain=subset_domain_id, codomain=codomain_set_id, rule=rule restricted )"
          }
        ],
        "constraints": []
      },
      {
        "name": "AlgebraicStructure",
        "description": "An algebraic or mathematical structure built on a base set, plus operations and relations. E.g. group, ring, field. Aggregators check axioms.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for the algebraic structure record."
          },
          {
            "name": "name",
            "type": "scalar",
            "datatype": "string",
            "description": "Label or short name, e.g. 'Ring of Integers'."
          },
          {
            "name": "base_set_id",
            "type": "lookup",
            "target_entity": "Set",
            "foreign_key": true,
            "description": "Which set underlies this structure."
          },
          {
            "name": "algebraic_structure_type",
            "type": "scalar",
            "datatype": "string",
            "description": "E.g. 'group','ring','field','module','vector_space'."
          },
          {
            "name": "algebraic_operations",
            "type": "scalar",
            "datatype": "json",
            "description": "Definition or references to operations used: { 'addition': '+', 'multiplication': '*' }. Possibly references ArithmeticOperator IDs."
          },
          {
            "name": "relations",
            "type": "scalar",
            "datatype": "json",
            "description": "Extra data about relation(s) used, e.g. equality, partial order, etc."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "is_group",
            "type": "rollup",
            "formula": "CheckGroupAxioms(algebraic_operations, base_set_id)",
            "description": "Confirms associativity, identity, inverses under the 'addition' operation if structure_type is 'group'."
          },
          {
            "name": "is_ring",
            "type": "rollup",
            "formula": "CheckRingAxioms(algebraic_operations, base_set_id)",
            "description": "Confirms ring axioms if structure_type is 'ring' (two operations, distributivity, etc.)."
          },
          {
            "name": "is_field",
            "type": "rollup",
            "formula": "CheckFieldAxioms(algebraic_operations, base_set_id)",
            "description": "Checks commutative ring with unity + multiplicative inverses for all non-zero elements, etc."
          },
          {
            "name": "is_integral_domain",
            "type": "rollup",
            "formula": "CheckIfNoZeroDivisors(base_set_id, algebraic_operations.multiplication)",
            "description": "True if ring has no zero divisors, ignoring edge cases unless structure_type is 'ring'."
          },
          {
            "name": "has_identity_for_all_ops",
            "type": "rollup",
            "description": "Checks if there is a single element that serves as identity for each operation in 'algebraic_operations'.",
            "formula": "CheckCommonIdentityElement(base_set_id, algebraic_operations)"
          },
          {
            "name": "all_inverses_exist",
            "type": "rollup",
            "description": "If the structure is supposed to be a group or field, ensures every non-zero element has an inverse w.r.t. each operation.",
            "formula": "For each op in algebraic_operations => checkInverses(base_set_id, op)"
          },
          {
            "name": "is_commutative_ring",
            "type": "rollup",
            "description": "If structure_type is 'ring', checks if addition and multiplication are commutative for all elements.",
            "formula": "IF (algebraic_structure_type='ring') THEN CheckRingCommutativity(base_set_id, algebraic_operations) ELSE null"
          },
          {
            "name": "potential_contradictions",
            "type": "rollup",
            "description": "Searches for other propositions that might contradict this one if both are proven.",
            "formula": "FindContradictoryPropositions(this.id)"
          },
          {
            "name": "similar_propositions",
            "type": "rollup",
            "description": "Returns a list of propositions with statements that match a certain similarity threshold to this statement.",
            "formula": "ComputePropositionSimilarity(this.statement)"
          },
          {
            "name": "operation_count",
            "type": "rollup",
            "description": "Counts how many distinct operations are defined in algebraic_operations JSON.",
            "formula": "COUNT_KEYS(algebraic_operations)"
          },
          {
            "name": "commutative_operations_list",
            "type": "rollup",
            "description": "Returns a list of operations that are verified to be commutative on base_set_id.",
            "formula": "For each op in algebraic_operations => if CheckCommutativity(op, base_set_id) => add op"
          },
          {
            "name": "center_of_structure",
            "type": "rollup",
            "description": "All elements z that commute with every x in base_set for each operation in algebraic_operations.",
            "formula": "FindCenter(base_set_id, algebraic_operations)"
          },
          {
            "name": "characteristic",
            "type": "rollup",
            "description": "For rings/fields, smallest n>0 s.t. n*1=0, or 0 if none. Implementation conceptual.",
            "formula": "ComputeCharacteristic(base_set_id, algebraic_operations)"
          },
          {
            "name": "commutative_operations_count",
            "type": "rollup",
            "description": "Counts how many operations in algebraic_operations are commutative over base_set_id.",
            "formula": "For each op in algebraic_operations => if CheckCommutativity(op, base_set_id) then increment count"
          },
          {
            "name": "zero_divisor_detection",
            "type": "rollup",
            "description": "Collects all (a,b) != (0,0) with a*b=0 in ring structures.",
            "formula": "IF algebraic_structure_type in ['ring','field'] THEN FindZeroDivisors(base_set_id, algebraic_operations) ELSE null"
          },
          {
            "name": "idempotent_elements_list",
            "type": "rollup",
            "description": "All elements e for which e op e = e (in the relevant operation).",
            "formula": "IF 'multiplication' in algebraic_operations THEN For all e => e * e = e ELSE null"
          },
          {
            "name": "operation_table",
            "type": "rollup",
            "description": "Constructs a Cayley/operation table if the domain set is finite and not too large.",
            "formula": "IF (domain_set_id.is_finite) THEN BuildOperationTable(this.id, domain_set_id) ELSE null"
          },
          {
            "name": "invertible_element_count",
            "type": "rollup",
            "description": "If the operator behaves group-like, counts how many elements have inverses. Implementation conceptual.",
            "formula": "CountInvertibleElements(this.id, domain_set_id)"
          },
          {
            "name": "commutator_subgroup",
            "type": "rollup",
            "description": "If the structure is a group, returns the subgroup generated by all commutators [a,b]. Null otherwise.",
            "formula": "IF algebraic_structure_type='group' THEN GenerateCommutatorSubgroup(base_set_id, algebraic_operations) ELSE null"
          },
          {
            "name": "maximal_ideals_list",
            "type": "rollup",
            "description": "If the structure is a ring, attempts to list its maximal ideals. Implementation conceptual.",
            "formula": "IF algebraic_structure_type='ring' THEN FindMaximalIdeals(base_set_id, algebraic_operations) ELSE null"
          },
          {
            "name": "dimension_if_vector_space",
            "type": "rollup",
            "description": "If this structure is a vector space, tries to compute dimension over its field. Null otherwise.",
            "formula": "IF algebraic_structure_type='vector_space' THEN ComputeVectorSpaceDimension(base_set_id) ELSE null"
          },
          {
            "name": "homomorphism_count",
            "type": "rollup",
            "description": "Counts how many Functions in the data are labeled or detected as homomorphisms from this structure to any other.",
            "formula": "SearchFunctionsForHomomorphisms(this.id)"
          },
          {
            "name": "group_center_cardinality",
            "type": "rollup",
            "description": "If structure_type='group', returns the size of the center Z(G). Null if not a group.",
            "formula": "IF (algebraic_structure_type='group') THEN COUNT(FindCenter(base_set_id, algebraic_operations)) ELSE null"
          }
        ],
        "lambdas": [
          {
            "name": "has_unit_element",
            "parameters": [],
            "description": "Checks if there is a neutral element for multiplication, relevant for ring/field. Returns the element or null if none.",
            "formula": "Scan base_set_id for e => ∀x, e*x = x*e = x. If found, return e else null"
          },
          {
            "name": "invoke_axiom",
            "parameters": [
              "axiom_proposition_id"
            ],
            "description": "Temporarily treat an axiom proposition as true for the proof steps of this proposition.",
            "formula": "AddPropositionDependency(this.id, axiom_proposition_id)"
          },
          {
            "name": "validate_structure_type",
            "parameters": [],
            "description": "Checks if the structure_type truly matches the aggregator results (e.g. is_ring, is_field, etc.).",
            "formula": "CompareDeclaredStructureTypeWithAxioms(this.id)"
          }
        ],
        "constraints": []
      },
      {
        "name": "Proposition",
        "description": "A formal statement (lemma, theorem, corollary). We can store its statement, proof steps, dependencies, aggregator to check if proven, etc.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for referencing this proposition."
          },
          {
            "name": "statement",
            "type": "scalar",
            "datatype": "string",
            "description": "Text or symbolic form of the proposition."
          },
          {
            "name": "result_type",
            "type": "scalar",
            "datatype": "string",
            "description": "E.g. 'lemma','proposition','theorem','corollary'."
          },
          {
            "name": "proof_type",
            "type": "scalar",
            "datatype": "string",
            "description": "E.g. 'formal','constructive','contradiction','outline'."
          },
          {
            "name": "derivation_steps",
            "type": "scalar",
            "datatype": "json",
            "description": "Detailed or partially detailed proof steps or references."
          },
          {
            "name": "depends_on",
            "type": "scalar",
            "datatype": "json",
            "description": "List of other Proposition IDs or theorems this result relies upon."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "is_proven",
            "type": "rollup",
            "formula": "ValidateProof(derivation_steps)",
            "description": "Yes/no aggregator verifying the proof steps are recognized as valid. Implementation is conceptual."
          },
          {
            "name": "is_trivial_proof",
            "type": "rollup",
            "formula": "IF LENGTH(derivation_steps) <= 2 THEN true ELSE false",
            "description": "Naive aggregator: if proof is extremely short, we label it 'trivial'."
          },
          {
            "name": "complexity_estimate",
            "type": "rollup",
            "description": "A naive measure of proof complexity, e.g. # of steps or references in derivation_steps.",
            "formula": "LENGTH(derivation_steps)"
          },
          {
            "name": "reference_count",
            "type": "rollup",
            "description": "How many distinct external references or theorems appear in 'depends_on'.",
            "formula": "IF depends_on != null THEN LENGTH(depends_on) ELSE 0"
          },
          {
            "name": "dependency_depth",
            "type": "rollup",
            "description": "Longest chain of nested depends_on references leading to axioms or base statements.",
            "formula": "ComputeDependencyDepth(this.id)"
          },
          {
            "name": "is_axiom",
            "type": "rollup",
            "description": "Returns true if result_type or proof_type indicates an axiom, or forcibly accepted with no dependencies.",
            "formula": "CheckIfAxiom(this.result_type, this.proof_type, this.depends_on)"
          },
          {
            "name": "references_in_proof",
            "type": "rollup",
            "description": "Parses derivation_steps to locate any cited references or external theorems.",
            "formula": "ExtractReferences(derivation_steps)"
          },
          {
            "name": "use_of_contradiction",
            "type": "rollup",
            "description": "Checks if proof uses a contradiction approach (assume ¬p => derive false).",
            "formula": "DetectProofByContradiction(derivation_steps)"
          },
          {
            "name": "statement_similarity_score",
            "type": "rollup",
            "description": "Compares proposition statement to known library, returns similarity measure [0..1].",
            "formula": "ComputeStatementSimilarity(this.statement)"
          },
          {
            "name": "is_equivalence_statement",
            "type": "rollup",
            "description": "True if statement has the form p <-> q or is logically a biconditional.",
            "formula": "CheckBiconditional(statement)"
          },
          {
            "name": "requires_choice_axiom",
            "type": "rollup",
            "description": "Heuristic aggregator to see if the proof steps rely on the Axiom of Choice.",
            "formula": "DetectAxiomOfChoiceUsage(derivation_steps)"
          },
          {
            "name": "equivalent_statements_list",
            "type": "rollup",
            "description": "Search for other Proposition statements that appear logically equivalent (p ⇔ q). Returns an array or null.",
            "formula": "ComputeEquivalentPropositions(this.id)"
          },
          {
            "name": "used_logical_axioms_list",
            "type": "rollup",
            "description": "Parses derivation_steps to detect references to standard logical axioms or proof rules.",
            "formula": "ScanProofForLogicalAxioms(derivation_steps)"
          },
          {
            "name": "corollary_generation_suggestions",
            "type": "rollup",
            "description": "Heuristic aggregator: suggests corollaries or immediate consequences that might be proven from this proposition.",
            "formula": "ComputePotentialCorollaries(this.id)"
          }
        ],
        "lambdas": [
          {
            "name": "remove_dependency",
            "parameters": [
              "prop_id"
            ],
            "description": "Removes a proposition from 'depends_on' if it’s no longer required or has been replaced.",
            "formula": "UpdateDependsOn(this.id, prop_id, 'remove')"
          },
          {
            "name": "mark_proof_as_complete",
            "parameters": [],
            "description": "Sets is_proven aggregator to true by adding a final step that references a recognized authority or proof checker.",
            "formula": "ValidateAndFinalizeProof(this.id)"
          },
          {
            "name": "apply",
            "parameters": [
              "context"
            ],
            "description": "Applies the proposition to a given context, e.g. rewriting or instantiation in a new domain.",
            "formula": "ApplyProposition(this, context)"
          },
          {
            "name": "apply_to_equation",
            "parameters": [
              "equation_id"
            ],
            "description": "Tries to unify the proposition’s statement with a given equation, e.g. if statement references 'a^2+b^2=c^2' and eqn is pythag.",
            "formula": "AttemptUnification(this.statement, LOOKUP(equation_id).equation_text)"
          }
        ],
        "constraints": []
      },
      {
        "name": "Equation",
        "description": "A symbolic expression representing an equality or functional relationship (polynomial, differential eqn, wave eqn, etc.). Useful in advanced math or cross-domain usage.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for the equation record."
          },
          {
            "name": "equation_text",
            "type": "scalar",
            "datatype": "string",
            "description": "Raw or human-readable form, e.g. 'x^2 + y^2 = z^2'."
          },
          {
            "name": "latex_repr",
            "type": "scalar",
            "datatype": "string",
            "description": "Optional LaTeX for nicer display."
          },
          {
            "name": "description",
            "type": "scalar",
            "datatype": "string",
            "description": "Remarks or usage context of the equation."
          },
          {
            "name": "related_sets",
            "type": "scalar",
            "datatype": "json",
            "description": "IDs or references to sets or variables the equation references, e.g. { 'x in ℝ','y in ℝ' }"
          },
          {
            "name": "is_polynomial",
            "type": "rollup",
            "description": "Examines equation_text to see if it’s a polynomial equation in standard variables, e.g. a1*x^n + ... = 0.",
            "formula": "CheckIfPolynomial(equation_text)"
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "is_linear_equation",
            "type": "rollup",
            "formula": "CheckIfLinear(equation_text)",
            "description": "Examines if the equation is linear in its variables. E.g. 'ax + b=0'."
          },
          {
            "name": "is_polynomial",
            "type": "rollup",
            "description": "Examines equation_text to see if it’s a polynomial equation in standard variables, e.g. a1*x^n + ... = 0.",
            "formula": "CheckIfPolynomial(equation_text)"
          },
          {
            "name": "degree",
            "type": "rollup",
            "description": "If the equation is a polynomial, returns the highest exponent found. Otherwise null.",
            "formula": "IF (is_polynomial) THEN DeterminePolynomialDegree(equation_text) ELSE null"
          },
          {
            "name": "discriminant",
            "type": "rollup",
            "description": "If polynomial is quadratic, returns b^2 - 4ac or the appropriate generalization. Else null.",
            "formula": "IF (degree=2) THEN ComputeQuadraticDiscriminant(equation_text) ELSE null"
          },
          {
            "name": "num_variables",
            "type": "rollup",
            "description": "Counts distinct variable symbols used in equation_text, e.g. {x, y, z}.",
            "formula": "ParseVariables(equation_text).length"
          },
          {
            "name": "is_homogeneous_polynomial",
            "type": "rollup",
            "description": "True if polynomial and every term has the same total degree. Else false or null.",
            "formula": "CheckHomogeneity(equation_text)"
          },
          {
            "name": "root_count",
            "type": "rollup",
            "description": "If domain is finite, count how many assignments satisfy the equation. Otherwise null or partial.",
            "formula": "CountFiniteSolutions(equation_text, related_sets)"
          },
          {
            "name": "is_solvable_by_radicals",
            "type": "rollup",
            "description": "Checks if polynomial degree ≤4 for symbolic solutions. True/false/unknown.",
            "formula": "DetermineSolvabilityByRadicals(equation_text)"
          },
          {
            "name": "symmetry_detection",
            "type": "rollup",
            "description": "Identifies which variables can be permuted without changing the equation’s form.",
            "formula": "AnalyzeEquationSymmetry(equation_text)"
          },
          {
            "name": "dimension_of_solution_space",
            "type": "rollup",
            "description": "For linear equations, estimates dimension of solution set. Implementation is conceptual.",
            "formula": "ComputeSolutionSpaceDimension(equation_text, related_sets)"
          },
          {
            "name": "definite_integral",
            "type": "rollup",
            "description": "For single-var real eqn, attempts ∫ f(x) dx from a to b if specified somewhere.",
            "formula": "IF (is_polynomial AND domain=ℝ) THEN EvaluateDefIntegral(equation_text, bounds) ELSE null"
          },
          {
            "name": "leading_coefficient",
            "type": "rollup",
            "description": "If polynomial, returns the coefficient of highest-degree term.",
            "formula": "IF is_polynomial THEN GetLeadingCoefficient(equation_text) ELSE null"
          },
          {
            "name": "evaluate_for_naturals",
            "type": "rollup",
            "description": "If related_sets includes ℕ, evaluates eqn for n=0..some range, collecting results or solutions.",
            "formula": "IF 'naturals' in related_sets THEN EvaluateEqnOverRange(equation_text, n=0..10) ELSE null"
          },
          {
            "name": "integer_solutions_count",
            "type": "rollup",
            "description": "Counts how many integer solutions exist if feasible. Implementation conceptual.",
            "formula": "IF (related_sets includes 'integers') THEN CountIntegerSolutions(equation_text) ELSE null"
          },
          {
            "name": "solutions_mod_n",
            "type": "rollup",
            "description": "Enumerates or counts solutions modulo a given n if the equation is integer-based. Implementation conceptual.",
            "formula": "IF (related_sets includes 'integers') THEN SolveModN(equation_text, n) ELSE null"
          },
          {
            "name": "numerical_solution_count",
            "type": "rollup",
            "description": "Estimates how many numeric solutions exist (finite/infinite) or returns null if unknown.",
            "formula": "AttemptNumericSolve(equation_text, related_sets)"
          },
          {
            "name": "dominant_term",
            "type": "rollup",
            "description": "Identifies which term in the equation (polynomial or rational form) dominates as |x|→∞. Null if not polynomial-like.",
            "formula": "FindDominantTerm(equation_text)"
          },
          {
            "name": "evaluate_at_infinity",
            "type": "rollup",
            "description": "Evaluates or approximates the limit of LHS (and possibly RHS) as x→∞/-∞. Returns symbolic or numeric result.",
            "formula": "CheckLimitAtInfinity(equation_text)"
          },
          {
            "name": "coefficient_vector",
            "type": "rollup",
            "description": "For polynomial equations, extracts the list of coefficients in standard form, e.g. x^3+4x-7 => [1,0,4,-7]. Null otherwise.",
            "formula": "IF (is_polynomial) THEN ParsePolynomialCoefficients(equation_text) ELSE null"
          }
        ],
        "lambdas": [
          {
            "name": "solve_equation",
            "parameters": [
              "var_list"
            ],
            "description": "Symbolically solves for the provided var(s) if feasible. Returns solutions or null if none found.",
            "formula": "ApplySymbolicSolver(equation_text, var_list)"
          },
          {
            "name": "simplify_equation",
            "parameters": [],
            "description": "Performs symbolic simplification, returning an updated equation text or new record.",
            "formula": "SymbolicallySimplify(equation_text)"
          },
          {
            "name": "partial_derivative",
            "parameters": [
              "var_name"
            ],
            "description": "If equation is differentiable, returns a new equation for d/d(var_name). Otherwise null.",
            "formula": "ComputePartialDerivative(equation_text, var_name)"
          }
        ],
        "constraints": []
      },
      {
        "name": "Category",
        "description": "Captures objects and morphisms in category theory. May store them as references to sets, functions, or other structures. Aggregators check composition closure, identity morphisms, etc.",
        "fields": [
          {
            "name": "id",
            "type": "scalar",
            "datatype": "string",
            "primary_key": true,
            "description": "Unique ID for the category."
          },
          {
            "name": "name",
            "type": "scalar",
            "datatype": "string",
            "description": "Label for the category."
          },
          {
            "name": "objects",
            "type": "scalar",
            "datatype": "json",
            "description": "Potentially a list of references to sets or algebraic structures that function as 'objects' in the category."
          },
          {
            "name": "morphisms",
            "type": "scalar",
            "datatype": "json",
            "description": "List or map describing morphisms (arrows) between objects, referencing 'Function' IDs or new definitions."
          }
        ],
        "lookups": [],
        "aggregations": [
          {
            "name": "is_small",
            "type": "rollup",
            "formula": "CheckIfObjectCollectionIsSetSized(objects)",
            "description": "Naive aggregator to see if the category is 'small' (if the class of objects is a set)."
          },
          {
            "name": "num_morphisms",
            "type": "rollup",
            "formula": "COUNT(morphisms) // or sum of their definitions if morphisms is array-like",
            "description": "A count aggregator for how many morphisms (arrows) are declared in this Category."
          },
          {
            "name": "has_zero_object",
            "type": "rollup",
            "description": "Detects if there’s an object that is both initial and terminal. For each object, check if it’s unique that all morphisms come from/to it in exactly one way. Returns true if found.",
            "formula": "Search objects => find candidate that’s both initial_object & terminal_object => if found => true else false"
          },
          {
            "name": "has_zero_object",
            "type": "rollup",
            "description": "Detects if there’s an object that is both initial and terminal. For each object, check if it’s unique that all morphisms come from/to it in exactly one way. Returns true if found.",
            "formula": "Search objects => find candidate that’s both initial_object & terminal_object => if found => true else false"
          },
          {
            "name": "object_count",
            "type": "rollup",
            "description": "Number of declared objects in the category.",
            "formula": "COUNT(objects)"
          },
          {
            "name": "morphism_count",
            "type": "rollup",
            "description": "Number of declared morphisms in the category (summing if 'morphisms' is an object map).",
            "formula": "IF (morphisms is array) THEN COUNT(morphisms) ELSE SUM(LENGTH(morphisms))"
          },
          {
            "name": "has_initial_object",
            "type": "rollup",
            "description": "Checks if there's an object I s.t. there's exactly one morphism from I to any object in the category.",
            "formula": "For each candidate I in objects => check uniqueness of morphisms(I -> X) for all X"
          },
          {
            "name": "has_binary_products",
            "type": "rollup",
            "description": "Checks if a product object exists for every pair of objects, with suitable projection morphisms.",
            "formula": "CheckBinaryProducts(objects, morphisms)"
          },
          {
            "name": "has_equalizers",
            "type": "rollup",
            "description": "Checks if for all parallel morphisms f,g an equalizer object and morphism exist.",
            "formula": "CheckEqualizers(objects, morphisms)"
          },
          {
            "name": "distinct_object_pairs_count",
            "type": "rollup",
            "description": "Counts ordered pairs (A,B) of distinct objects in the category. Implementation is straightforward.",
            "formula": "ComputeDistinctObjectPairs(objects)"
          },
          {
            "name": "functor_count",
            "type": "rollup",
            "description": "How many known Functor definitions originate from this category to others.",
            "formula": "CountFunctorsFromThisCategory(this.id)"
          },
          {
            "name": "object_isomorphism_pairs_count",
            "type": "rollup",
            "description": "Counts pairs of objects (A,B) that are isomorphic. Implementation conceptual.",
            "formula": "CountIsomorphicObjectPairs(objects, morphisms)"
          },
          {
            "name": "terminal_object_count",
            "type": "rollup",
            "description": "Counts how many objects T have exactly one morphism from every other object.",
            "formula": "CountTerminalObjects(objects, morphisms)"
          },
          {
            "name": "exponential_objects_check",
            "type": "rollup",
            "description": "Checks if the category has exponentials B^A for all A,B, with evaluation morphism.",
            "formula": "ScanForExponentialObjects(this.id)"
          },
          {
            "name": "number_of_endofunctors",
            "type": "rollup",
            "description": "Counts all functors from this category to itself in the stored data.",
            "formula": "CountEndofunctors(this.id)"
          },
          {
            "name": "auto_equivalences_count",
            "type": "rollup",
            "description": "Counts how many equivalences of categories from this cat to itself.",
            "formula": "IdentifyAutoEquivalences(this.id)"
          },
          {
            "name": "has_pullbacks",
            "type": "rollup",
            "description": "Checks if every diagram has a pullback object and morphisms. Implementation conceptual.",
            "formula": "AnalyzePullbacks(objects, morphisms)"
          },
          {
            "name": "has_pushouts",
            "type": "rollup",
            "description": "Checks if every cospan has a pushout object and morphisms. Implementation conceptual.",
            "formula": "AnalyzePushouts(objects, morphisms)"
          },
          {
            "name": "is_cartesian_closed",
            "type": "rollup",
            "description": "Verifies if the category has exponentials B^A with the usual universal property. Implementation conceptual.",
            "formula": "CheckCartesianClosedProperty(this.id)"
          },
          {
            "name": "automorphism_count",
            "type": "rollup",
            "description": "Counts isomorphisms object->itself across all objects, summing for a total number of 'auto' morphisms in this category.",
            "formula": "ComputeCategoryAutomorphisms(this.id)"
          },
          {
            "name": "inverse_morphism_count",
            "type": "rollup",
            "description": "Counts how many morphisms are invertible. Implementation conceptual, scanning morphisms for isomorphisms.",
            "formula": "CountInvertibleMorphisms(morphisms)"
          },
          {
            "name": "endofunction_count",
            "type": "rollup",
            "description": "If objects are sets, counts how many endofunctions exist for each object f: A->A, summing across the category. Null if infinite.",
            "formula": "Sum(For each Obj in objects => |Obj|^|Obj|) // conceptual"
          },
          {
            "name": "functor_composition_closure_check",
            "type": "rollup",
            "description": "Verifies that if functor F: Cat->Cat2 and G: Cat2->Cat3 exist, the composition G∘F is recognized as a functor as well.",
            "formula": "CheckFunctorComposition(this.id)"
          }
        ],
        "lambdas": [
          {
            "name": "functor",
            "parameters": [
              "target_category_id"
            ],
            "description": "Constructs a functor from this category to the target category if a mapping is defined or stored.",
            "formula": "ConstructFunctor(this, LOOKUP(target_category_id))"
          },
          {
            "name": "has_terminal_object",
            "parameters": [],
            "description": "Checks if there's an object T s.t. there's exactly one morphism from every other object to T. Implementation is aggregator-based.",
            "formula": "Scan objects => find candidate T => check for unique arrow from each object => T"
          }
        ],
        "constraints": [
          {
            "name": "composition_closed",
            "formula": "CheckCompositionClosure(morphisms)",
            "error_message": "Category must be closed under morphism composition."
          }
        ]
      }
    ]
  },
  "data": {
    "Set": [
      {
        "id": "naturals",
        "name": "ℕ",
        "description": "Natural numbers: 0,1,2,... Inductively defined.",
        "countable": true,
        "cardinality": "aleph_0",
        "discrete_or_continuous": "discrete",
        "parent_set_id": null,
        "construction_rule": {
          "base": 0,
          "successor": "n -> n+1"
        }
      },
      {
        "id": "integers",
        "name": "ℤ",
        "description": "All integers: negative, zero, positive. Countably infinite.",
        "countable": true,
        "cardinality": "aleph_0",
        "discrete_or_continuous": "discrete",
        "parent_set_id": null,
        "construction_rule": null
      },
      {
        "id": "reals",
        "name": "ℝ",
        "description": "Real numbers, uncountable. Common in analysis.",
        "countable": false,
        "cardinality": "c",
        "discrete_or_continuous": "continuous",
        "parent_set_id": null,
        "construction_rule": null
      }
    ],
    "Element": [
      {
        "id": "elem_natural_5",
        "containing_set_id": "naturals",
        "value_type": "int",
        "value": 5
      },
      {
        "id": "elem_integer_-3",
        "containing_set_id": "integers",
        "value_type": "int",
        "value": -3
      }
    ],
    "ArithmeticOperator": [
      {
        "id": "op_add_integers",
        "symbol": "+",
        "domain_set_id": "integers",
        "codomain_set_id": "integers",
        "description": "Addition on ℤ"
      }
    ],
    "Function": [
      {
        "id": "f_identity",
        "name": "Identity on ℤ",
        "domain_set_id": "integers",
        "codomain_set_id": "integers",
        "rule": {
          "type": "identity",
          "expression": "f(x)=x"
        }
      }
    ],
    "AlgebraicStructure": [
      {
        "id": "integer_ring",
        "name": "Ring of Integers",
        "base_set_id": "integers",
        "algebraic_structure_type": "ring",
        "algebraic_operations": {
          "addition": "op_add_integers",
          "multiplication": "*"
        },
        "relations": {
          "equality": "="
        }
      }
    ],
    "Proposition": [
      {
        "id": "prop_pythagorean",
        "statement": "For integer a,b,c, if a^2+b^2=c^2, then a,b,c is Pythag. triple",
        "result_type": "theorem",
        "proof_type": "outline",
        "derivation_steps": [
          "Rewrite eqn, factor, do gcd argument, etc."
        ],
        "depends_on": []
      }
    ],
    "Equation": [
      {
        "id": "eqn_pythag",
        "equation_text": "a^2 + b^2 = c^2",
        "latex_repr": "a^2 + b^2 = c^2",
        "description": "Classic Pythagorean relation",
        "related_sets": {
          "a,b,c": "integers"
        }
      }
    ],
    "Category": [
      {
        "id": "cat_sets",
        "name": "Category of Sets",
        "objects": [
          "naturals",
          "integers",
          "reals"
        ],
        "morphisms": {
          "f_identity_integers": {
            "domain": "integers",
            "codomain": "integers",
            "functionRef": "f_identity"
          }
        }
      }
    ]
  }
}
}